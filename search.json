[{"url":"/2021/07/27/4.分支管理/","content":"# 分支管理\n\n## 创建与合并分支\n\n- 默认本地仓库只有一条分支`main`\n\n  - `HEAD`指向`main`,`main`指向要提交的时间线\n\n- `git switch -c <新分支名>`:创建并切换新分支，指向`main`相同的提交\n\n  - 此时`HEAD`指向新分支。之后的提交都是在新分支下\n\n    ![img](https://www.liaoxuefeng.com/files/attachments/919022533080576/0)\n\n  - 不加`-c`表示切换分支\n\n- `git branch`：查看所有分支\n\n  - 当前分支名前会有一个*号\n\n- `git merge <分支名>`：合并指定分支的工作到当前分支下\n\n- `git branch -d <分支名>`：删除分支\n\n## 分支冲突\n\n- 合并冲突：\n\n  - 当创建多分支时，如果修改不同文件，则合并不会提示冲突\n\n  - 如果修改相同文件，合并时会提示冲突，需要手动修改冲突，确定文件的最终版本\n\n    ![img](https://www.liaoxuefeng.com/files/attachments/919023000423040/0)\n\n- Git用`<<<<<<<`，`=======`，`>>>>>>>`标记出不同分支的内容\n\n- 合并策略：\n\n  - 默认使用`Fast forward`，会直接将Master分支指向Develop分支。在这种模式下，删除分支后，会丢掉分支信息\n\n    ![bg2012070505(1)](C:\\Users\\Administrator.USER-20201209JD\\Desktop\\bg2012070505(1).png)\n\n  - ` git merge --no-ff -m \"merge with no-ff\" dev`\n\n    - 使用`--no-ff`参数后，会执行正常合并，在Master分支上生成一个新节点\n\n      ![bg2012070506(1)](C:\\Users\\Administrator.USER-20201209JD\\Desktop\\bg2012070506(1).png)\n\n- 合并分支时，加上`--no-ff`参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而`fast forward`合并就看不出来曾经做过合并\n\n## 分支管理策略\n\n![img](https://www.liaoxuefeng.com/files/attachments/919023260793600/0)\n\n- ==主分支main(master)==:代码库应该有一个、且仅有一个主分支。仅用来发布新版本，平时不能在上面干活.\n\n- ==工作分支dev==：日常开发。如果想正式对外发布，就在分支上，对Develop分支进行\"合并\"\n\n- **临时分支**：\n\n  - ==功能分支feature-xxx==：为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop\n\n    ![d4806f137df9563d148afb17a51a1134_bg2012070507](C:\\Users\\Administrator.USER-20201209JD\\Desktop\\d4806f137df9563d148afb17a51a1134_bg2012070507.png)\n\n  - ==预发布分支release-xxx==：指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支.\n\n  - ==修补bug分支fixbug-xxx==：修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支\n\n\n\n**扩展阅读**\n\n- [Git分支管理策略](http://www.ruanyifeng.com/blog/2012/07/git.html)\n\n"},{"url":"/2021/07/27/3.远程仓库/","content":"# 远程仓库\n\n## 配置SSH\n\n- 本地Git仓库和GitHub仓库之间的传输是通过SSH加密的、\n\n- 第1步：创建SSH Key。打开Shell（Windows下打开Git Bash），创建SSH Key：\n\n  ```\n  cd  ~/.ssh\t//检查本机是否有ssh,如果提示没有则需要创建\n  ssh-keygen -t rsa -C \"youremail@example.com\"\t//创建ssh,一路回车，使用默认值即可\n  cd ~/.ssh \t//进入文件\n  ll\t//查看是否存在有id_rsa（私匙）和id_rsa.pub（公匙）两个文件\n  cat id_rsa.pub\t//查看公匙\n  ```\n\n- 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面\n\n  - 点“Add SSH Key”，填上任意Title，在Key文本框里粘贴`id_rsa.pub`文件的内容\n\n- GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。\n\n## 本地仓库关联远程仓库\n\n### 命令\n\n- `git remote add origin <仓库地址>`：连接远程仓库\n  - 仓库地址选择git开头的那个\n  - 添加后，远程库的名字就是`origin`，这是Git默认的叫法，也可以改成别的\n- `git push -u <远程仓库名> <本地分支名>`：将当前本地仓库分支推送到远程仓库\n  - `-u`：第一次推送`master`分支时，加上`-u`参数，Git不但会把本地的`main`分支内容推送的远程新的`main`分支，还会把本地的`main`分支和远程的`main`分支关联起来，在以后的推送或者拉取时就可以简化命令,直接使用`git push`\n  - `<本地分支名>:<远程分支名>`：推送到远程仓库的分支重新命名\n- `git remote rm <远程仓库名>`：解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动\n- `git remote -v`：查看远程库信息\n\n## 克隆远程库\n\n### 命令\n\n- `git clone <仓库地址>`\n"},{"url":"/2021/07/27/2.本地仓库/","content":"# 本地仓库\n\n## 仓库版本控制\n\n- `git status`：查看本地仓库状态\n- `git diff`：查看仓库和之前版本的区别\n- `git log`：显示从最近的最远的提交日志\n  - `--grapt`：显示分支合并图\n  - `--pretty=oneline`：简化日志信息，将每个提交放在一行显示，**查看的提交数很大时非常有用**\n- `git reset --hard xxx`：回退仓库版本xxx\n  - `xxx`\n    - Git中用`head`表示当前版本，上个版本是`head^`，上上个版本是`head^^`,也可用`head~10`来表示上10个版本\n    - 直接用`git log`中提交`commit id（版本号）`前几位\n- `git reflog`：记录使用的每一次命令\n\n## 工作区和暂存区\n\n- ==工作区==：就是你在电脑里能看到的目录\n- ==版本库==：工作区有一个隐藏目录`.git`，这个不算工作区，而是Git的版本库\n  - 版本库中存在一个称为stage(或index)的==暂存区==，还有Git为为我们自动创建的第一个分支`main`，以及指向`master`的一个指针叫`HEAD`\n\n![img](https://www.liaoxuefeng.com/files/attachments/919020037470528/0)\n\n- 我们把文件往Git版本库里添加的时候，是分两步执行的：\n\n  第一步是用`git add`把文件添加进去，实际上就是把文件修改添加到暂存区；\n\n  第二步是用`git commit`提交更改，实际上就是把暂存区的所有内容提交到当前分支。\n\n  因为我们创建Git版本库时，Git自动为我们创建了唯一一个`master`分支，所以，现在，`git commit`就是往`master`分支上提交更改\n\n## 管理修改\n\n**为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件**\n\n- git每次都会对仓库内发生的修改情况进行记录，只要存在修改就会存在记录\n- 考虑这样一种情况：第一次修改 -> `git add` -> 第二次修改 -> `git commit`\n  - add会将第一次修改提交到暂存区，commit只会将暂存区的文件提交\n  - 但是这并不意味着第二次修改不存在了，我们可以再进行add后再提交，仍然可以提交第二次修改\n\n## 撤销修改\n\n- `git checkout` 可以用来新建或者切换分支， 也可以用来回退文件版本\n- 从 `Git 2.23` 版本开始引入了两个新的命令： \n  - `git switch` 切换分支\n  - `git restore`：还原工作区的文件\n    - `--staged`:将暂存区的文件从暂存区撤出，但不会更改文件的内容\n    - 如果文件还未add,那么不需要加上面参数；如果一级add,那么回退顺序应该是先回退暂存区，再回退文件（直接回退文件是没用的）\n- 如果修改被commit了，那么只能回退版本\n\n## 删除文件\n\n- 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用`rm`命令删了\n- 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，`git status`命令会立刻告诉你哪些文件被删除了\n- 现在你有两个选择，\n  - 一是确实要从版本库中删除该文件，那就用命令`git rm`删掉，并且`git commit`\n    - 或者用`git add <file>`删掉\n  - 另一种情况是删错了，因为版本库里还有，所以当然可以撤销修改\n- **注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！**\n\n"},{"title":"Git简介","url":"/2021/07/27/1.Git简介/","content":"\n\n\n# Git简介\n\n## Git起源\n\n- 在2002年以前，世界各地的志愿者把源代码文件通过==diff[^3]==的方式发给Linus，然后由Linus本人通过手工方式合并==代码==\n- 到了2002年,Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统\n- 2005,Linux社区牛人试图破解BitKeeper的协议，BitMover公司要收回Linux社区的免费使用权\n- Linus花了两周时间自己用C写了一个分布式版本控制系统——Git！一个月之内，Linux系统的源码已经由Git管理了\n\n\n\n## 版本控制系统[^1]\n\n- 集中式：\n  - 集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。\n  - 集中式版本控制系统最大的毛病就是必须联网才能工作，受限于网速\n- 分布式：\n  - 分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，工作的时候，就不需要联网\n  - 个人的对库文件的修改只需通过局域网推送给对方即可看到\n  - 分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已\n- Git是目前世界上最先进的==分布式版本控制系统[^2]==\n\n## 安装Git\n\n- Linux：直接用命令行安装\n\n- Win：在官网下载安装程序，并配置机器名字和地址\n\n- 具体操作互联网搜索即可\n\n- 第一次安装需要配置\n\n  ```shell\n  git config --global user.name \"xxx\"\n  ```\n  \n\n\n## 版本库\n\n- 版本库（*repository*)：可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”\n\n### 操作过程\n\n- `git init`：在指定目录中使用，可以将该目录变成Git可以管理的仓库\n  - 会在该目录下生成一个`.git`目录，是Git用来跟踪管理版本库的，一般不需改动\n  - 该仓库是一个本地仓库\n- `git add xxx`：把位于指定目录的文件添加到仓库\n- `git commit -m \"xxx\"`：将文件提交到仓库\n  - 一次commit会将之前所有的add都会提交 \n\n\n\n\n\n[^1]:一种软体工程技巧，籍以在开发的过程中，确保由不同人所编辑的同一档案都得到更新。版本控制透过文档控制(documentation control)记录程序各个模组的改动，并为每次改动编上序号\n[^2]:每个人都可以创建一个独立的代码仓库用于管理，各种版本控制的操作都可以在本地完成。每个人修改的代码都可以推送合并到另外一个代码仓库中\n[^3]:diff 命令比较文本文件,它能比较单个文件或者目录内容。\n\n\n\n**扩展阅读**\n\n- [百科-版本控制](https://baike.so.com/doc/5903265-6116166.html)\n- [集中式（SVN）和分布式（Git）版本控制系统的简单比较](https://www.cnblogs.com/wx1993/p/7680877.html)\n\n","tags":["Git学习"],"categories":["Git学习"]},{"title":"Github+Hexo搭建个人博客","url":"/2021/07/26/Github+Hexo搭建个人博客/","content":"\n\n\n# Github+Hexo搭建个人博客\n\n## 工具准备\n\n- git安装：直接官网下载即可\n- Node.js安装\n  - 官网下载后，可以配置一下依赖的安装环境，即配置环境变量\n- Hexo安装\n\n## 博客初始化\n\n\n\n## 主题相关配置\n\n- 根目录下`_config.yam`配置博客基本信息\n\n  ```yaml\n  ```\n\n- 配置网站头像\n\n- \n\n","categories":["测试"]}]