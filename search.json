[{"title":"1.Git简介","url":"/2021/07/27/1.Git%E7%AE%80%E4%BB%8B/","content":"<h1 id=\"git简介\"><a class=\"markdownIt-Anchor\" href=\"#git简介\"></a> Git简介</h1>\n<h2 id=\"git起源\"><a class=\"markdownIt-Anchor\" href=\"#git起源\"></a> Git起源</h2>\n<ul>\n<li>在2002年以前，世界各地的志愿者把源代码文件通过==diff<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>==的方式发给Linus，然后由Linus本人通过手工方式合并代码</li>\n<li>到了2002年,Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统</li>\n<li>2005,Linux社区牛人试图破解BitKeeper的协议，BitMover公司要收回Linux社区的免费使用权</li>\n<li>Linus花了两周时间自己用C写了一个分布式版本控制系统——Git！一个月之内，Linux系统的源码已经由Git管理了</li>\n</ul>\n<p><img src=\"/2021/07/27/1.Git%E7%AE%80%E4%BB%8B/..%5Cimg%5Cgit.png\" alt=\"git\"></p>\n<h2 id=\"版本控制系统\"><a class=\"markdownIt-Anchor\" href=\"#版本控制系统\"></a> 版本控制系统<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup></h2>\n<ul>\n<li>集中式：\n<ul>\n<li>集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。</li>\n<li>集中式版本控制系统最大的毛病就是必须联网才能工作，受限于网速</li>\n</ul>\n</li>\n<li>分布式：\n<ul>\n<li>分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，工作的时候，就不需要联网</li>\n<li>个人的对库文件的修改只需通过局域网推送给对方即可看到</li>\n<li>分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已</li>\n</ul>\n</li>\n<li>Git是目前世界上最先进的<mark>分布式版本控制系统<sup class=\"footnote-ref\"><a href=\"#fn3\" id=\"fnref3\">[3]</a></sup></mark></li>\n</ul>\n<h2 id=\"git-特性\"><a class=\"markdownIt-Anchor\" href=\"#git-特性\"></a> Git 特性</h2>\n<ul>\n<li>直接记录快照、而非差异比较\n<ul>\n<li>Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异</li>\n<li>实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接</li>\n</ul>\n</li>\n<li>近乎所有的操作都是本地执行</li>\n<li>时刻保持数据的完整性\n<ul>\n<li>在保存到 Git 之前，所有数据都要进行内容的<strong>校验和</strong>（checksum）计算，并将此结果作为数据的唯一标识和索引</li>\n<li>Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串。该字串由 40 个十六进制字符（0-9 及 a-f）组成。<em><strong>所有保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名</strong></em></li>\n</ul>\n</li>\n<li>多数操作仅添加数据</li>\n</ul>\n<h2 id=\"安装git\"><a class=\"markdownIt-Anchor\" href=\"#安装git\"></a> 安装Git</h2>\n<ul>\n<li>\n<p>Linux：直接用命令行安装</p>\n</li>\n<li>\n<p>Win：在官网下载安装程序，并配置机器名字和地址</p>\n</li>\n<li>\n<p>具体操作互联网搜索即可</p>\n</li>\n<li>\n<p>第一次安装需要配置</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\">git config --global user.name &quot;xxx&quot;<br>git config --global user.email &quot;email@example.com&quot;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"版本库\"><a class=\"markdownIt-Anchor\" href=\"#版本库\"></a> 版本库</h2>\n<ul>\n<li>版本库（<em>repository</em>)：可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”</li>\n<li>工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。\n<ul>\n<li>已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。</li>\n<li>而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"操作过程\"><a class=\"markdownIt-Anchor\" href=\"#操作过程\"></a> 操作过程</h3>\n<ul>\n<li><code>git init</code>：在指定目录中使用，可以将该目录变成Git可以管理的仓库\n<ul>\n<li>会在该目录下生成一个<code>.git</code>目录，是Git用来跟踪管理版本库的，一般不需改动</li>\n<li>该仓库是一个本地仓库</li>\n</ul>\n</li>\n<li><code>git add xxx</code>：把位于指定目录的文件添加到仓库</li>\n<li><code>git commit -m &quot;xxx&quot;</code>：将文件提交到仓库\n<ul>\n<li>一次commit会将之前所有的add都会提交</li>\n<li><code>-a</code>，自动将所有已跟踪的文件暂存起来一并提交</li>\n</ul>\n</li>\n</ul>\n<p><strong>扩展阅读</strong></p>\n<ul>\n<li><a href=\"https://baike.so.com/doc/5903265-6116166.html\">百科-版本控制</a></li>\n<li><a href=\"https://www.cnblogs.com/wx1993/p/7680877.html\">集中式（SVN）和分布式（Git）版本控制系统的简单比较</a></li>\n</ul>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>diff 命令比较文本文件,它能比较单个文件或者目录内容。 <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>一种软体工程技巧，籍以在开发的过程中，确保由不同人所编辑的同一档案都得到更新。版本控制透过文档控制(documentation control)记录程序各个模组的改动，并为每次改动编上序号 <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p>每个人都可以创建一个独立的代码仓库用于管理，各种版本控制的操作都可以在本地完成。每个人修改的代码都可以推送合并到另外一个代码仓库中 <a href=\"#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n","categories":["Git学习"],"tags":["Github"]},{"title":"1.初始MySQL","url":"/2021/10/01/1.%E5%88%9D%E5%A7%8BMySQL/","content":"<h1 id=\"初始mysql\"><a class=\"markdownIt-Anchor\" href=\"#初始mysql\"></a> 初始MySQL</h1>\n<h2 id=\"什么是数据库\"><a class=\"markdownIt-Anchor\" href=\"#什么是数据库\"></a> 什么是数据库</h2>\n<p>数据库 ( <strong>DataBase</strong> , 简称<strong>DB</strong> )</p>\n<ul>\n<li>\n<p><strong>概念</strong> : 长期存放在计算机内,有组织,可共享的大量数据的集合,是一个数据 “仓库”</p>\n</li>\n<li>\n<p><strong>作用</strong> : 存储和管理数据</p>\n</li>\n<li>\n<p><strong>数据库总览 :</strong></p>\n<ul>\n<li>关系型数据库 ( SQL )：关系型数据库通过外键关联来建立表与表之间的关系\n<ul>\n<li>MySQL , Oracle , SQL Server , SQLite , DB2 …</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>非关系型数据库 ( NOSQL,<em>Not Only SQL</em> )：非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定\n<ul>\n<li>Redis , MongoDB , …</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"什么是dbms\"><a class=\"markdownIt-Anchor\" href=\"#什么是dbms\"></a> 什么是DBMS</h2>\n<p>数据库管理系统 ( <strong>D</strong>ata<strong>B</strong>ase <strong>M</strong>anagement <strong>S</strong>ystem )</p>\n<p>数据库管理软件 , 科学组织和存储数据 , 高效地获取和维护数据</p>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JDAlgEhicQfyUeklefrUhYibIew3vo8N1zoy9ic2nOVVJWtjZsXg7TWsDDGhAI5rSGZ0tnQ6OIO8MBg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\">\n<blockquote>\n<p>MySQL本质上是一个数据库管理系统.</p>\n</blockquote>\n<h2 id=\"mysql简介\"><a class=\"markdownIt-Anchor\" href=\"#mysql简介\"></a> MySQL简介</h2>\n<p><strong>概念 :</strong> 是现在<strong>流行</strong>的<strong>开源</strong>的,<strong>免费</strong>的 <strong>关系型</strong>数据库</p>\n<p><strong>历史 :</strong> 由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。</p>\n<p><strong>特点 :</strong></p>\n<ul>\n<li>免费 , 开源数据库</li>\n<li>小巧 , 功能齐全</li>\n<li>使用便捷</li>\n<li>可运行于Windows或Linux操作系统</li>\n<li>可适用于中小型甚至大型网站应用（可以做集群）</li>\n</ul>\n<p><strong>官网 :</strong> <strong><a href=\"https://www.mysql.com/\">https://www.mysql.com/</a></strong></p>\n<h2 id=\"安装mysql\"><a class=\"markdownIt-Anchor\" href=\"#安装mysql\"></a> 安装MySQL</h2>\n<p><strong>建议使用压缩版，安装快，卸载容易</strong></p>\n<h3 id=\"安装步骤\"><a class=\"markdownIt-Anchor\" href=\"#安装步骤\"></a> 安装步骤</h3>\n<p>1、下载后得到zip压缩包.</p>\n<p>2、解压到自己想要安装到的目录，本人解压到的是<code>D:\\Environment\\mysql-5.7.19</code></p>\n<p>3、添加环境变量：我的电脑-&gt;属性-&gt;高级-&gt;（系统）环境变量</p>\n<figure class=\"highlight dos\"><table><tr><td class=\"code\"><pre><code class=\"hljs dos\">选择<span class=\"hljs-built_in\">PATH</span>,在其后面添加: 你的mysql 安装文件下面的bin文件夹<br></code></pre></td></tr></table></figure>\n<p>4、编辑 my.ini 文件 ,注意替换路径位置</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><code class=\"hljs routeros\">[mysqld]<br><span class=\"hljs-attribute\">basedir</span>=D:\\Program Files\\mysql-5.7\\<br><span class=\"hljs-attribute\">datadir</span>=D:\\Program Files\\mysql-5.7\\data\\<br><span class=\"hljs-attribute\">port</span>=3306<br>skip-grant-tables<br></code></pre></td></tr></table></figure>\n<p>5、启动管理员模式下的CMD，并将路径切换至mysql下的bin目录，然后输入<code>mysqld –install</code>(安装mysql)</p>\n<p>6、再输入  <code>mysqld --initialize-insecure --user=mysql</code> 初始化数据文件</p>\n<p>7、然后再次启动mysql <code>net start mysql</code></p>\n<p>然后用命令 <code>mysql –u root –p</code> 进入mysql管理界面（密码可为空）</p>\n<p>8、进入界面后更改root密码</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-keyword\">update</span> mysql.<span class=\"hljs-keyword\">user</span> <span class=\"hljs-keyword\">set</span> authentication_string=<span class=\"hljs-keyword\">password</span>(<span class=\"hljs-string\">&#x27;123456&#x27;</span>) <span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">user</span>=<span class=\"hljs-string\">&#x27;root&#x27;</span> <span class=\"hljs-keyword\">and</span> Host = <span class=\"hljs-string\">&#x27;localhost&#x27;</span>;<br><span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">USER</span> <span class=\"hljs-string\">&#x27;root&#x27;</span>@<span class=\"hljs-string\">&#x27;localhost&#x27;</span> IDENTIFIED <span class=\"hljs-keyword\">WITH</span> mysql_native_password <span class=\"hljs-keyword\">BY</span> <span class=\"hljs-string\">&#x27;123456&#x27;</span>; // mysql <span class=\"hljs-number\">8.0</span><br></code></pre></td></tr></table></figure>\n<p>9、刷新权限</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"code\"><pre><code class=\"hljs abnf\">flush privileges<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n<p>10、修改 my.ini文件删除最后一句skip-grant-tables</p>\n<p>11、重启mysql即可正常使用</p>\n<figure class=\"highlight dos\"><table><tr><td class=\"code\"><pre><code class=\"hljs dos\"><span class=\"hljs-built_in\">net</span> stop mysql<br><span class=\"hljs-built_in\">net</span> <span class=\"hljs-built_in\">start</span> mysql<br></code></pre></td></tr></table></figure>\n<p>12、连接上测试出现以下结果就安装好了</p>\n<blockquote>\n<p>如果出现问题，可以按如下操作：</p>\n<p>在mysql的安装目录下(即xxx/bin目录）运行mysqld --console查看报错信息</p>\n<p>根据错误信息去搜索解决方法</p>\n</blockquote>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JDAlgEhicQfyUeklefrUhYib5jn0ggWLtIrViavAcBpOXW2ick2ibI2un63gLrFMdtviamYxttX2knoPibQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\">\n<blockquote>\n<p>如果以前装过,现在需要重装,一定要将环境清理干净 .</p>\n</blockquote>\n<h3 id=\"可视化工具sqlyog\"><a class=\"markdownIt-Anchor\" href=\"#可视化工具sqlyog\"></a> 可视化工具SQLyog</h3>\n<p>使用SQLyog管理工具自己完成以下操作 :</p>\n<ul>\n<li>\n<p>连接本地MySQL数据库</p>\n</li>\n<li>\n<p>新建MySchool数据库</p>\n</li>\n<li>\n<ul>\n<li>字段</li>\n<li>GradeID : int(11) , Primary Key (pk)</li>\n<li>GradeName : varchar(50)</li>\n<li>数据库名称MySchool</li>\n<li>新建数据库表(grade)</li>\n</ul>\n</li>\n</ul>\n<p>在历史记录中可以看到相对应的数据库操作的语句 .</p>\n<p><strong><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JDAlgEhicQfyUeklefrUhYibEvvP8V27JN1wk2BDkph6PCOj45JfcnhJaibHsV6jVewwZZumapwTibicg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\"></strong></p>\n<blockquote>\n<p><strong>MySQL默认端口号 3306</strong></p>\n</blockquote>\n<p><strong>SQLyog中每一次操作都对应了sql语句，可以在历史记录中查看</strong></p>\n","categories":["MySql基础学习"],"tags":["MySql"]},{"title":"11.嵌入式SQL——ODBC（未完成）","url":"/2021/10/01/11.%E5%B5%8C%E5%85%A5%E5%BC%8FSQL%E2%80%94%E2%80%94ODBC/","content":"<h1 id=\"嵌入式sqlodbc未完成\"><a class=\"markdownIt-Anchor\" href=\"#嵌入式sqlodbc未完成\"></a> 嵌入式SQL——ODBC（未完成）</h1>\n<h2 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h2>\n<p><strong>程序基本流程</strong>(jdbc版）：</p>\n<ul>\n<li>加载驱动</li>\n<li>提供连接数据库用户信息 和 url</li>\n<li>连接成功，返回数据库对象</li>\n<li>执行SQL的对象</li>\n<li>执行SQL的对象 去 执行SQL,可能存在结果，查看返回结果</li>\n<li>释放连接</li>\n</ul>\n<h2 id=\"在c中连接数据库\"><a class=\"markdownIt-Anchor\" href=\"#在c中连接数据库\"></a> 在C++中连接数据库</h2>\n","categories":["MySql基础学习"],"tags":["MySql"]},{"title":"10.规范化数据库设计","url":"/2021/10/01/10.%E8%A7%84%E8%8C%83%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/","content":"<h1 id=\"规范化数据库设计\"><a class=\"markdownIt-Anchor\" href=\"#规范化数据库设计\"></a> 规范化数据库设计</h1>\n<h2 id=\"为什们需要设计\"><a class=\"markdownIt-Anchor\" href=\"#为什们需要设计\"></a> 为什们需要设计？</h2>\n<p><strong>当数据库比较复杂的时候，我们对数据库进行设计</strong></p>\n<ul>\n<li>糟糕的数据库设计\n<ul>\n<li>数据冗余，浪费空间</li>\n<li>（自带外键）数据库插入和删除麻烦</li>\n<li>程序的性能差</li>\n</ul>\n</li>\n<li>良好的数据库设计\n<ul>\n<li>节省内存空间</li>\n<li>保证数据库的完整性</li>\n<li>方便我们开发系统</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据库设计步骤\"><a class=\"markdownIt-Anchor\" href=\"#数据库设计步骤\"></a> 数据库设计步骤</h2>\n<ul>\n<li>分析需求：分析业务和需要处理的数据库的需求\n<ul>\n<li>分析要用的表，以及表中需要保存的信息</li>\n<li>提取和表相关的实体类，讲需求落实到表的每一个字段</li>\n</ul>\n</li>\n<li>概要设计：设计关系图E-R图\n<ul>\n<li>标识实体之间的关系</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"三大范式\"><a class=\"markdownIt-Anchor\" href=\"#三大范式\"></a> 三大范式</h2>\n<h3 id=\"第一范式1nf\"><a class=\"markdownIt-Anchor\" href=\"#第一范式1nf\"></a> 第一范式(1NF)</h3>\n<p><strong>原子性</strong>：要求数据库表的每一列都是不可分割的原子数据项</p>\n<h3 id=\"第二范式2nf\"><a class=\"markdownIt-Anchor\" href=\"#第二范式2nf\"></a> 第二范式(2NF)</h3>\n<p>前提：满足第一范式</p>\n<p><strong>要求表中的每一列都和主键相关库，而不能只与主键的某一部分相关（主要针对联合主键而言）</strong>、</p>\n<p>示例：联合主键（A,B)，但表中C、D和A、B相关，E和B相关，那么对于表（A,B,C,D,E）来说，就不满足第二范式。</p>\n<p>​\t\t 因为表的非主键列和主键不是完全相关，即不是：所有非主键列都是和（A,B)相关。</p>\n<p>​\t\t 那么就需要拆分表为（A,C,D)，(B，E)两个表</p>\n<h3 id=\"第三范式3nf\"><a class=\"markdownIt-Anchor\" href=\"#第三范式3nf\"></a> 第三范式(3NF)</h3>\n<p>前提：满足第二范式</p>\n<p><strong>确保表中的每一列数据都和主键直接相关，而不能间接相关（在2NF的基础上消除传递依赖）</strong></p>\n<p>示例：假设表中所有非主键列都完全依赖于主键（满足2NF），但是，有一列C实际上直接相关的是B（也就是说 主键-&gt;B-&gt;C,传递依赖也满足2NF)</p>\n<p>​\t\t 所以我们要把(B,C)单独成表，删除原表中的C(因为原表通过B就可以找到C的信息)</p>\n<blockquote>\n<p>规范型 和 性能的问题</p>\n<p>阿里：关联查询的表不超过3个</p>\n<ul>\n<li>考虑商业化的需求和目标，数据库的性能更重要</li>\n<li>故意给表增加一些冗余的字段（从多表查询变为单表查询）</li>\n<li>故意增加一些计算列（从大数据量降低为小数据量）</li>\n</ul>\n</blockquote>\n","categories":["MySql基础学习"],"tags":["MySql"]},{"title":"2.MySQL数据库简介","url":"/2021/10/01/2.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/","content":"<h1 id=\"mysql数据库简介\"><a class=\"markdownIt-Anchor\" href=\"#mysql数据库简介\"></a> MySQL数据库简介</h1>\n<h2 id=\"数据库控制\"><a class=\"markdownIt-Anchor\" href=\"#数据库控制\"></a> 数据库控制</h2>\n<p><strong>命令行操作数据库</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs mysql\">mysql -u root -p123456\t\t-- 连接数据库<br><br>update mysql.user set authentication_string=password(&#x27;123456&#x27;) where user=&#x27;root&#x27; and Host = &#x27;localhost&#x27;;\t-- 更新密码<br>flush privileges;\t-- 刷新权限<br><br>-----------------------------------------<br>show tables;\t\t-- 查看数据库所有的表<br>describe 表名；\t-- 显示数据库中表的信息<br><br>exit;\t-- 退出连接<br><br>--\t单行注释<br>/*  */\t-- 多行注释<br></code></pre></td></tr></table></figure>\n<h3 id=\"show-命令\"><a class=\"markdownIt-Anchor\" href=\"#show-命令\"></a> show 命令</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs mysql\">show databases; -- 显示mysql中所有数据库的名称。<br><br>-- 如果当前没有使用 use 选择数据库，那么对所有表操作都要带上其对应d<br>show tables或show tables from database_name; -- 显示当前数据库中所有表的名称。<br>show table status; -- 显示当前使用或者指定的database中的每个表的信息。信息包括表类型和表的最新更新时间。<br>show columns from database_name.table_name; -- 显示表中列名称。<br>\tdesc 表名\t\t-- 显示表的结构<br>show index from table_name; -- 显示表的索引。<br><br>show grants for user_name; -- 显示一个用户的权限，显示结果类似于grant 命令。<br>show status; -- 显示一些系统特定资源的信息，例如，正在运行的线程数量。<br>show variables; -- 显示系统变量的名称和值。<br>show processlist; -- 显示系统中正在运行的所有进程，也就是当前正在执行的查询。大多数用户可以查看他们自己的进程，但是如果他们拥有process权限，就可以查看所有人的进程，包括密码。<br>show privileges; -- 显示服务器所支持的不同权限。<br><br>show create database database_name; -- 显示create database 语句是否能够创建指定的数据库。<br>show create table table_name; -- 显示create database 语句是否能够创建指定的数据库。<br><br>show logs; -- 显示BDB存储引擎的日志。<br>show warnings; -- 显示最后一个执行的语句所产生的错误、警告和通知。<br>show errors; -- 只显示最后一个执行语句所产生的错误。<br><br>show [storage] engines; \t-- 显示安装后的可用存储引擎和默认引擎。<br>show character set;\t\t-- 显示服务器支持的数据集<br>show innodb status; -- 显示innoDB存储引擎的状态。<br></code></pre></td></tr></table></figure>\n<h2 id=\"数据库表的列类型\"><a class=\"markdownIt-Anchor\" href=\"#数据库表的列类型\"></a> 数据库表的列类型</h2>\n<h3 id=\"数值类型\"><a class=\"markdownIt-Anchor\" href=\"#数值类型\"></a> 数值类型</h3>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JZX1D0neUIMjSFiazUGK15QLXRrfmQjbUt3O7sLw0KKv9UtriaTr60JspXIZ69HkeOiagz86CE3a9Wg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\">\n<ul>\n<li><code>int(M)</code>：M指示最大显示宽度。显示宽度与存储大小或类似所包含值的范围无关</li>\n</ul>\n<h3 id=\"字符串类型\"><a class=\"markdownIt-Anchor\" href=\"#字符串类型\"></a> 字符串类型</h3>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JZX1D0neUIMjSFiazUGK15QsjOPftNfn1ibXSP8OIYnsJaaPC8da61jCzcbdkqbApibQWgQ7KBjYbuw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\">\n<h3 id=\"日期和时间型类型\"><a class=\"markdownIt-Anchor\" href=\"#日期和时间型类型\"></a> 日期和时间型类型</h3>\n<img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JZX1D0neUIMjSFiazUGK15Qcib3OwGtWEJkEE2biaa4jT3xokY1UicPT1MQcQNsa1EsjiaIqM1vvyUPjg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\" style=\"zoom:80%;\">\n<h3 id=\"null值\"><a class=\"markdownIt-Anchor\" href=\"#null值\"></a> NULL值</h3>\n<ul>\n<li>理解为 “没有值” 或 “未知值”</li>\n<li>不要用NULL进行算术运算 , 结果仍为NULL</li>\n</ul>\n<h2 id=\"数据库表的字段属性\"><a class=\"markdownIt-Anchor\" href=\"#数据库表的字段属性\"></a> 数据库表的字段属性</h2>\n<p><strong>UnSigned</strong></p>\n<ul>\n<li>无符号的</li>\n<li>声明该数据列不允许负数 .</li>\n</ul>\n<p><strong>ZEROFILL</strong></p>\n<ul>\n<li>0填充的</li>\n<li>不足位数的用0来填充 , 如int(3),5则为005</li>\n</ul>\n<p><strong>Auto_InCrement</strong></p>\n<ul>\n<li>\n<p><em>自动增长</em>的 , 每添加一条数据 , 自动在上一个记录数上加 1(默认)</p>\n</li>\n<li>\n<p>通常用于设置<strong>主键</strong> , 且为整数类型</p>\n</li>\n<li>\n<p>可定义起始值和步长</p>\n</li>\n<li>\n<ul>\n<li>当前表设置步长(AUTO_INCREMENT=100) : 只影响当前表</li>\n<li>SET @@auto_increment_increment=5 ; 影响所有使用自增的表(全局)</li>\n</ul>\n</li>\n</ul>\n<p><strong>NULL 和 NOT NULL</strong></p>\n<ul>\n<li>默认为NULL , 即该列允许为空</li>\n<li>如果设置为NOT NULL , 则该列必须有值</li>\n</ul>\n<p><strong>DEFAULT</strong></p>\n<ul>\n<li>用于设置默认值</li>\n<li>例如,性别字段,默认为&quot;男&quot; , 否则为 “女” ; 若无指定该列的值 , 则默认值为&quot;男&quot;的值</li>\n</ul>\n<blockquote>\n<p>拓展：阿里云项目数据库规范</p>\n<p>每一个表都要有这几个字段</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs mysql\">id\t\t主键<br>version\t\t乐观锁<br>is_delete\t伪删除<br>gmt_create\t创建时间<br>gmt_update\t修改时间<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"数据库表的引擎\"><a class=\"markdownIt-Anchor\" href=\"#数据库表的引擎\"></a> 数据库表的引擎</h2>\n<p><strong>默认使用 INNODB</strong></p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>InnoDB</th>\n<th>MYISAM</th>\n<th>Memory</th>\n<th>Archive</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>存储限制</td>\n<td>64TB</td>\n<td>256TB</td>\n<td>RAM</td>\n<td>None</td>\n</tr>\n<tr>\n<td>支持<mark>事务<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></mark></td>\n<td><strong>Y</strong></td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n</tr>\n<tr>\n<td>支持<mark>全文索引<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup></mark></td>\n<td>N</td>\n<td><strong>Y</strong></td>\n<td>N</td>\n<td></td>\n</tr>\n<tr>\n<td>支持哈希索引</td>\n<td>N</td>\n<td>N</td>\n<td><strong>Y</strong></td>\n<td>N</td>\n</tr>\n<tr>\n<td>支持数据缓存</td>\n<td><strong>Y</strong></td>\n<td>N</td>\n<td>N/A</td>\n<td>N</td>\n</tr>\n<tr>\n<td>支持外键</td>\n<td><strong>Y</strong></td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>选择策略：\n<ul>\n<li>如果要提供提交、回滚、崩溃恢复能力的事物安全（ACID兼容）能力，并要求实现并发控制，InnoDB是一个好的选择</li>\n<li>如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较高的处理效率</li>\n<li>如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎\n<ul>\n<li>MySQL中使用该引擎作为临时表，存放查询的中间结果</li>\n</ul>\n</li>\n<li>如果只有INSERT和SELECT操作，可以选择Archive，Archive支持高并发的插入操作，但是本身不是事务安全的。\n<ul>\n<li>Archive非常适合存储归档数据，如记录日志信息可以使用Archive</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据库表的在物理空间的位置\"><a class=\"markdownIt-Anchor\" href=\"#数据库表的在物理空间的位置\"></a> 数据库表的在物理空间的位置</h2>\n<ul>\n<li>\n<p>MySQL数据表以文件方式存放在磁盘中</p>\n</li>\n<li>\n<ul>\n<li>包括表文件 , 数据文件 , 以及数据库的选项文件</li>\n<li>位置 : Mysql安装目录<code>\\data\\</code>下存放数据表 . 目录名对应数据库名 , 该目录下文件名对应数据表</li>\n</ul>\n</li>\n<li>\n<p>文件类型：</p>\n<ul>\n<li><code>*.frm</code> ：存储表的列信息（表的结构）</li>\n<li><code>*.MYD</code> ：数据文件</li>\n<li><code>*.MYI</code>：索引文件</li>\n<li><code>*.ibd</code>：数据+索引</li>\n</ul>\n</li>\n<li>\n<p>具体文件介绍</p>\n<table>\n<thead>\n<tr>\n<th>文件结构名称</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ibdata1</td>\n<td>系统数据字典信息（元数据信息），undo表空间数据</td>\n</tr>\n<tr>\n<td>ib_logfiel0~ib_logfile1</td>\n<td>REDO日志文件，事务日志文件</td>\n</tr>\n<tr>\n<td>ibtmp1</td>\n<td>临时表空间磁盘位置，存储临时表</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>ibdata1存储所有InnoDB引擎的表的元信息和undo信息</p>\n<p>各个表.idb文件存储自己的数据行和索引信息</p>\n</blockquote>\n</li>\n<li>\n<p>一张InnoDB表由一个 <code>*.frm</code>文件 、一个<code>*.idb</code>文件, 以及上一级目录的<code>ibdata1</code>文件；</p>\n<p>一张MyISAM表由<code>.frm</code>、<code>MYD</code>、<code>MYI</code>组成</p>\n</li>\n</ul>\n<h2 id=\"数据库表的字符集\"><a class=\"markdownIt-Anchor\" href=\"#数据库表的字符集\"></a> 数据库表的字符集</h2>\n<p>我们可为数据库,数据表,数据列设定不同的字符集，设定方法 :</p>\n<ul>\n<li>\n<p>创建时通过命令来设置 , 如 : <code>CREATE TABLE 表名()CHARSET = utf8;</code></p>\n</li>\n<li>\n<p>如无设定 , 则根据MySQL数据库配置文件<code>my.ini</code> 中的参数设定</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">character-set-server</span>=utf8<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>不建修改配置文件，这样会导致sql语句的移植性降低</p>\n</blockquote>\n<h2 id=\"数据库表的外键了解\"><a class=\"markdownIt-Anchor\" href=\"#数据库表的外键了解\"></a> 数据库表的外键（了解）</h2>\n<h3 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\"></a> 概念</h3>\n<p>如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键。</p>\n<p>由此可见，外键表示了两个关系之间的相关联系。以另一个关系的外键作主关键字的表被称为<strong>主表</strong>，具有此外键的表被称为主表的<strong>从表</strong>。</p>\n<blockquote>\n<p>引用别人的表——主表；</p>\n<p>被别人引用的表——从表；</p>\n</blockquote>\n<h3 id=\"作用\"><a class=\"markdownIt-Anchor\" href=\"#作用\"></a> 作用</h3>\n<p>保持数据<strong>一致性</strong>，<strong>完整性</strong>，主要目的是控制存储在外键表中的数据<strong>约束</strong>，使两张表形成关联。</p>\n<blockquote>\n<p>主表中的外键只能引用外表中的对应列的值或使用空值。</p>\n</blockquote>\n<h3 id=\"mysql命令操作\"><a class=\"markdownIt-Anchor\" href=\"#mysql命令操作\"></a> MySQL命令操作</h3>\n<ul>\n<li>\n<p>创建外键</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs mysql\">-- 创建外键的方式一 : 创建子表同时创建外键<br><br>-- 年级表 (id\\年级名称)<br>CREATE TABLE `grade` (<br>`gradeid` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#x27;年级ID&#x27;,<br>`gradename` VARCHAR(50) NOT NULL COMMENT &#x27;年级名称&#x27;,<br>PRIMARY KEY (`gradeid`)<br>) ENGINE=INNODB DEFAULT CHARSET=utf8<br><br>-- 学生信息表 (学号,姓名,性别,年级,手机,地址,出生日期,邮箱,身份证号)<br>CREATE TABLE `student` (<br>`studentno` INT(4) NOT NULL COMMENT &#x27;学号&#x27;,<br>`studentname` VARCHAR(20) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;,<br>`sex` TINYINT(1) DEFAULT &#x27;1&#x27; COMMENT &#x27;性别&#x27;,<br>`gradeid` INT(10) DEFAULT NULL COMMENT &#x27;年级&#x27;,<br>PRIMARY KEY (`studentno`),<br>KEY `FK_gradeid` (`gradeid`),\t-- 定义外键key<br>CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`)\t-- 给外键添加约束（执行引用）<br>) ENGINE=INNODB DEFAULT CHARSET=utf8<br><br>--------------------------------------------<br>-- 创建外键方式二 : 创建子表完毕后,修改子表字段 添加外键约束<br>ALTER TABLE `student`<br>ADD CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>删除外键</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs mysql\">-- 删除外键<br>ALTER TABLE student DROP FOREIGN KEY FK_gradeid;<br>-- 发现执行完上面的,索引还在,所以还要删除索引<br>-- 注:这个索引是建立外键的时候默认生成的<br>ALTER TABLE student DROP INDEX FK_gradeid;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>删除具有主外键关系的表时 , 要先删子表 , 后删主表</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>以上操作都是<strong>物理外键</strong>、数据库级别的外键，不建议使用</p>\n<ul>\n<li>原因：对于数据库的所有外键的每次插入、更新和删除后，数据库服务器进行完整性检查是一个耗费时间和资源的过程，它可能影响性能</li>\n</ul>\n<p><strong>最佳实践</strong></p>\n<ul>\n<li>数据库就是单纯的表，只用来存数据，只有行、列</li>\n<li>我们想使用多张表，想使用外键，可以使用程序实现（联合查询）</li>\n</ul>\n</blockquote>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><strong>事务</strong>是在数据库上按照一定的逻辑顺序执行的任务序列,是并发控制的单位。这些操作要么都做，要么都不做，不可分割 <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p><strong>原理</strong>是先定义一个词库，然后在文章中查找每个词条(term)出现的频率和位置，把这样的频率和位置信息按照词库的顺序归纳 <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n","categories":["MySql基础学习"],"tags":["MySql"]},{"title":"3.MySQL数据库DDL操作","url":"/2021/10/01/3.MySQL%E6%95%B0%E6%8D%AE%E5%BA%93DDL%E6%93%8D%E4%BD%9C/","content":"<h1 id=\"mysql数据库ddl操作\"><a class=\"markdownIt-Anchor\" href=\"#mysql数据库ddl操作\"></a> MySQL数据库DDL操作</h1>\n<h2 id=\"基本知识\"><a class=\"markdownIt-Anchor\" href=\"#基本知识\"></a> 基本知识</h2>\n<ul>\n<li>\n<p>命令行操作数据库，所有SQL语句都要有<code>;</code>结尾</p>\n</li>\n<li>\n<p>如果数据库中的表名或字段名是一个关键字，那么可以加上**``**来标记</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs mysql\">select `user` from student\t\t-- user是关键字<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><strong>DDL语言（数据定义语言）</strong>：定义和管理数据对象，如数据库、数据表等</p>\n<ul>\n<li><code>create</code>、<code>drop</code>、<code>alter</code></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JZX1D0neUIMjSFiazUGK15QOGpDicLzwS6NJVAeLECu2rx2qboGU36S9hXLov0x0c5vzZAceySSXnA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\"></p>\n<h2 id=\"操作数据库了解\"><a class=\"markdownIt-Anchor\" href=\"#操作数据库了解\"></a> 操作数据库（了解）</h2>\n<ul>\n<li>\n<p>创建数据库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs mysql\">create database &lt;if not exists&gt; 数据库名 character set utf8 colate utf_8_general_ci<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>删除数据库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs mysql\">drop database &lt;if exists&gt; 数据库名<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>使用数据库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs mysql\">use 数据库名<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>查看数据库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs mysql\">show databases<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"操作表\"><a class=\"markdownIt-Anchor\" href=\"#操作表\"></a> 操作表</h2>\n<ul>\n<li>\n<p>创建表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs mysql\">-- 格式<br>create table &lt;if not exists&gt; `表名`（<br>\t`字段名` 列类型 &lt;属性&gt; &lt;索引&gt; &lt;注释&gt;,<br>\t......<br>）&lt;表类型&gt; &lt;字符集设置&gt; &lt;注释&gt;<br><br>-- 示例<br>create table if not exists `student`(<br>    `id` int(4) not null auto_increment commit `学号`,<br>    `name` varchar(30) not null default `匿名`,<br>    primary key(`id`)\t-- 建议单独列出来<br>)engine=innodb charset=utf8<br></code></pre></td></tr></table></figure>\n<ul>\n<li>表和字段 尽量使用 `` 括起来，防止使用关键字</li>\n<li>字符串使用单引号括起来</li>\n<li>所有语句后面加 <code>,</code>，最后一个不用加</li>\n</ul>\n</li>\n<li>\n<p>修改表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs mysql\">修改表名 : ALTER TABLE 旧表名 RENAME AS 新表名<br>添加字段 : ALTER TABLE 表名 ADD 字段名 列属性[属性]<br>修改字段 : <br>ALTER TABLE 表名 MODIFY 字段名 列类型[属性]\t\t\t\t-- 只能修改约束<br>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 列属性[属性]\t\t-- 重命名 + 修改约束<br>删除字段 : ALTER TABLE 表名 DROP 字段名<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>删除表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs mysql\">drop table if exists b<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n","categories":["MySql基础学习"],"tags":["MySql"]},{"title":"2.本地仓库","url":"/2021/07/27/2.%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/","content":"<h1 id=\"本地仓库\"><a class=\"markdownIt-Anchor\" href=\"#本地仓库\"></a> 本地仓库</h1>\n<h2 id=\"仓库版本控制\"><a class=\"markdownIt-Anchor\" href=\"#仓库版本控制\"></a> 仓库版本控制</h2>\n<ul>\n<li>\n<p><code>git status</code>：查看本地仓库状态</p>\n</li>\n<li>\n<p><code>git diff</code>：比较工作区和暂存区修改</p>\n<ul>\n<li><code>git diff head</code>：比较工作区和暂存区快照的差异</li>\n<li><code>git diff --cached head</code>：比较暂存区和最近一次commit后的修改</li>\n</ul>\n</li>\n<li>\n<p><code>git log</code>：显示从最近开始的提交过的版本信息（<strong>包含多种选项，具体情况使用</strong>）</p>\n<ul>\n<li><code>- n</code>：限制数量</li>\n<li><code>-p</code>：展开显示每次提交内容的差异</li>\n<li><code>--author=&quot;xxx&quot;</code>:按提交者名字搜索并显示（非整个单词匹配）</li>\n<li><code>--grep=&quot;xxx&quot;</code>：按指定内容搜索并显示</li>\n<li><code>-- &lt;file&gt;</code>：仅显示包含指定文件修改的commit</li>\n<li><code>--graph</code>：显示分支操作图</li>\n<li><code>--pretty=oneline</code>：显示日志简化信息，每条信息只占一行</li>\n</ul>\n<p><code>gitk</code><strong>可以启动图形化工具来查阅提交历史</strong></p>\n</li>\n<li>\n<p><code>git reset xxx</code>：回退到仓库版本xxx（之后的版本不保留）</p>\n<ul>\n<li><code>--hard</code>：回退的同时，同时会修改工作区到回退版本</li>\n<li><code>xxx</code>\n<ul>\n<li>Git中用<code>head</code>表示当前版本，上个版本是<code>head^</code>，上上个版本是<code>head^^</code>,也可用<code>head~10</code>来表示上10个版本</li>\n<li>直接用<code>git log</code>中显示<code>commit id（版本号）</code>前几位</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>git revert xxx</code></p>\n<ul>\n<li>撤销某次commit操作（之后的操作仍然保留）</li>\n</ul>\n</li>\n<li>\n<p><code>git reflog</code>：查看本地所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）</p>\n</li>\n<li>\n<p><code>git mv &lt;文件名&gt; &lt;文件新名&gt;</code>：重新命名文件</p>\n<ul>\n<li>同样需要提交修改</li>\n<li>git理解为一次移动操作</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"工作区和暂存区\"><a class=\"markdownIt-Anchor\" href=\"#工作区和暂存区\"></a> 工作区和暂存区</h2>\n<ul>\n<li><mark>工作区</mark>：就是你在电脑里能看到的目录</li>\n<li><mark>版本库</mark>：工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库\n<ul>\n<li>版本库中存在一个称为stage(或index)的<mark>暂存区</mark>，还有Git为为我们自动创建的第一个分支<code>main</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://www.liaoxuefeng.com/files/attachments/919020037470528/0\" alt=\"img\"></p>\n<ul>\n<li>\n<p>我们把文件往Git版本库里添加的时候，是分两步执行的：</p>\n<p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p>\n<p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>\n<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改</p>\n</li>\n</ul>\n<h2 id=\"管理修改\"><a class=\"markdownIt-Anchor\" href=\"#管理修改\"></a> 管理修改</h2>\n<p><strong>为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件</strong></p>\n<ul>\n<li>git每次都会对仓库内发生的修改情况进行记录，只要存在修改就会存在记录</li>\n<li>考虑这样一种情况：第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code>\n<ul>\n<li>add会将第一次修改提交到暂存区，commit只会将暂存区的文件提交</li>\n<li>但是这并不意味着第二次修改不存在了，我们可以再进行add后再提交，仍然可以提交第二次修改</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"撤销操作\"><a class=\"markdownIt-Anchor\" href=\"#撤销操作\"></a> 撤销操作</h2>\n<ul>\n<li><code>git checkout</code> 可以用来新建或者切换分支， 也可以用来回退文件版本</li>\n<li>从 <code>Git 2.23</code> 版本开始引入了两个新的命令：\n<ul>\n<li><code>git switch</code> 切换分支</li>\n<li><code>git restore &lt;文件名&gt;</code>：撤销对文件的修改，还原<strong>工作区</strong>的文件\n<ul>\n<li><code>--staged</code>:将<strong>暂存区</strong>的文件从暂存区撤出，但不会更改文件的内容</li>\n<li>所有如果想完全撤销提交到暂存区的文件，顺序是：暂存区撤销-&gt;工作区撤销</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>git commit --amend</code>：修改最后一次的提交\n<ul>\n<li>紧跟着上次提交使用，可以修改上次提交的说明</li>\n<li>如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 <code>--amend</code> 提交\n<ul>\n<li>两次<code>commit</code>但产生一次提交</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>如果修改被commit了，那么只能回退版本</li>\n</ul>\n<h2 id=\"删除文件\"><a class=\"markdownIt-Anchor\" href=\"#删除文件\"></a> 删除文件</h2>\n<ul>\n<li>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了</li>\n<li>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了</li>\n<li>现在你有两个选择，\n<ul>\n<li>一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>\n<ul>\n<li>或者用<code>git add &lt;file&gt;</code>删掉</li>\n</ul>\n</li>\n<li>另一种情况是删错了，因为版本库里还有，所以当然可以撤销修改\n<ul>\n<li>注意这里说的是版本库，所以包括add的文件</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</strong></li>\n<li><code>git rm --cached &lt;文件名&gt;</code>：将文件从版本库中删除，但是工作区中不删除</li>\n</ul>\n","categories":["Git学习"],"tags":["Github"]},{"title":"3.远程仓库","url":"/2021/07/27/3.%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/","content":"<h1 id=\"远程仓库\"><a class=\"markdownIt-Anchor\" href=\"#远程仓库\"></a> 远程仓库</h1>\n<h2 id=\"配置ssh\"><a class=\"markdownIt-Anchor\" href=\"#配置ssh\"></a> 配置SSH</h2>\n<ul>\n<li>\n<p>本地Git仓库和GitHub仓库之间的传输是通过SSH加密的、</p>\n</li>\n<li>\n<p>第1步：创建SSH Key。打开Shell（Windows下打开Git Bash），创建SSH Key：</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"code\"><pre><code class=\"hljs jboss-cli\"><span class=\"hljs-keyword\">cd</span>  ~<span class=\"hljs-string\">/.ssh</span>\t<span class=\"hljs-string\">//</span>检查本机是否有ssh,如果提示没有则需要创建<br>ssh-keygen -t rsa -C <span class=\"hljs-string\">&quot;youremail@example.com&quot;</span>\t<span class=\"hljs-string\">//</span>创建ssh,一路回车，使用默认值即可<br><span class=\"hljs-keyword\">cd</span> ~<span class=\"hljs-string\">/.ssh</span> \t<span class=\"hljs-string\">//</span>进入文件<br>ll\t<span class=\"hljs-string\">//</span>查看是否存在有id_rsa（私匙）和id_rsa.pub（公匙）两个文件<br>cat id_rsa.pub\t<span class=\"hljs-string\">//</span>查看公匙<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面</p>\n<ul>\n<li>点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容</li>\n</ul>\n</li>\n<li>\n<p>GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>\n</li>\n</ul>\n<h2 id=\"本地仓库关联远程仓库\"><a class=\"markdownIt-Anchor\" href=\"#本地仓库关联远程仓库\"></a> 本地仓库关联远程仓库</h2>\n<p><img src=\"http://kmknkk.oss-cn-beijing.aliyuncs.com/image/git.jpg\" alt=\"img\"></p>\n<h3 id=\"命令\"><a class=\"markdownIt-Anchor\" href=\"#命令\"></a> 命令</h3>\n<ul>\n<li>\n<p><code>git remote add origin &lt;仓库地址&gt;</code>：连接远程仓库(并未拉取文件)</p>\n<ul>\n<li>仓库地址选择git开头的那个</li>\n<li>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的</li>\n</ul>\n</li>\n<li>\n<p><code>git fetch &lt;远程主机名&gt; &lt;分支名&gt;</code>:从远程库抓取指定分支的所有commit到本地远程库</p>\n<ul>\n<li>去掉<code>&lt;分支名&gt;</code>将会抓取远程所有分支的修改</li>\n<li>该命令首先会把抓取的数据保存在一个<code>FETCH_HEAD</code>的临时记录中，通过<code>git log -p FETCH_HEAD</code>可以查看刚获取的更新信息。如果确认无误，可以通过<code>git merge FETCH_HEAD</code>合并到当前分支</li>\n<li><code>&lt;分支名&gt;:&lt;本地分支名&gt;</code>会自动合并，但是要保证该命令不是在要合并的分支下进行</li>\n</ul>\n</li>\n<li>\n<p><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code>：将远程主机的某个分支的更新取回，并与本地指定的分支合并</p>\n<ul>\n<li>如果合并的分支时当前分支，冒号后可省略</li>\n<li>当前分支要用于跟踪该远端仓库分支才可拉取</li>\n</ul>\n</li>\n<li>\n<p><code>git push -u origin &lt;本地分支名&gt;</code>：将当前本地仓库分支推送到远程仓库上相同名字的分支</p>\n<ul>\n<li><code>-u</code>：第一次推送<code>master</code>分支时，加上<code>-u</code>参数，Git不但会把本地的<code>main</code>分支内容推送的远程新的<code>main</code>分支，还会把本地的<code>main</code>分支和远程的<code>main</code>分支关联起来，在以后的推送或者拉取时就可以简化命令,直接使用<code>git push</code>\n<ul>\n<li>实际上实现了一个跟踪分支的效果，本地分支会自动跟踪对应远程分支</li>\n<li>可在创建分支时用<code>--track &lt;本地分支名&gt; &lt;远程分支名&gt;</code>来跟踪</li>\n</ul>\n</li>\n<li><code>&lt;本地分支名&gt;:&lt;远程分支名&gt;</code>：推送到远程仓库的分支重新命名\n<ul>\n<li>如果没有会为远程库创建对应分支</li>\n</ul>\n</li>\n<li>如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"远程库操作\"><a class=\"markdownIt-Anchor\" href=\"#远程库操作\"></a> 远程库操作</h2>\n<h3 id=\"命令-2\"><a class=\"markdownIt-Anchor\" href=\"#命令-2\"></a> 命令</h3>\n<ul>\n<li><code>git clone &lt;仓库地址&gt;</code>：克隆远程参考所有文件</li>\n<li><code>git remote rm &lt;远程仓库名&gt;</code>：解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动</li>\n<li><code>git remote -v</code>：显示所有远程库对应的克隆地址</li>\n<li><code>git remote show &lt;远程仓库名字&gt;</code>：查看远程仓库的详细信息</li>\n<li><code>git remote rename &lt;远程仓库名&gt; &lt;远程仓库新名&gt;</code>：修改某个远程参考在本地的简称\n<ul>\n<li>对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 <code>pb/master</code> 分支现在成了 <code>paul/master</code></li>\n</ul>\n</li>\n</ul>\n<p><strong>扩展阅读</strong></p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/runnerjack/p/9342362.html\">git fetch &amp; pull详解</a></li>\n</ul>\n","categories":["Git学习"],"tags":["Github"]},{"title":"4.MySQL数据库DML操作","url":"/2021/10/01/4.MySQL%E6%95%B0%E6%8D%AE%E5%BA%93DML%E6%93%8D%E4%BD%9C/","content":"<h1 id=\"mysql数据库dml操作\"><a class=\"markdownIt-Anchor\" href=\"#mysql数据库dml操作\"></a> MySQL数据库DML操作</h1>\n<h2 id=\"基本知识\"><a class=\"markdownIt-Anchor\" href=\"#基本知识\"></a> 基本知识</h2>\n<ul>\n<li><strong>DML（数据库管理语言）</strong>：用于操作数据库对象中包含的数据\n<ul>\n<li><code>insert</code>、<code>update</code>、<code>delete</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"添加insert\"><a class=\"markdownIt-Anchor\" href=\"#添加insert\"></a> 添加insert</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs mysql\">-- 语法<br>INSERT INTO 表名&lt;(字段1,字段2,字段3,...)&gt; VALUES(&#x27;值1&#x27;,&#x27;值2&#x27;,&#x27;值3&#x27;)<br></code></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>’ 字段1,字段2…’ 该部分可省略 , 但添加的值务必与表结构,数据列,<strong>顺序相对应,且数量一致</strong> .</p>\n</li>\n<li>\n<p>可同时插入多条数据 , values 后用英文逗号隔开</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> `stu`(`name`) <span class=\"hljs-keyword\">values</span>(<span class=\"hljs-string\">&#x27;张三&#x27;</span>),(<span class=\"hljs-string\">&#x27;李四&#x27;</span>) <br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"修改update\"><a class=\"markdownIt-Anchor\" href=\"#修改update\"></a> 修改update</h2>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 语法</span><br>UPDATE 表名 <span class=\"hljs-keyword\">SET</span> column_name<span class=\"hljs-operator\">=</span><span class=\"hljs-keyword\">value</span> <span class=\"hljs-operator\">&lt;</span>,column_name2<span class=\"hljs-operator\">=</span>value2,...<span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-operator\">&lt;</span><span class=\"hljs-keyword\">WHERE</span> <span class=\"hljs-keyword\">condition</span><span class=\"hljs-operator\">&gt;</span>;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>value 为修改后的数据 , 可以为变量 , 具体值, 表达式或者<strong>嵌套的SELECT结果</strong></li>\n<li>condition 为筛选条件 , 如不指定则修改该表的所有列数据</li>\n</ul>\n<h2 id=\"删除delete\"><a class=\"markdownIt-Anchor\" href=\"#删除delete\"></a> 删除delete</h2>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 语法</span><br><span class=\"hljs-keyword\">DELETE</span> <span class=\"hljs-keyword\">FROM</span> 表名 <span class=\"hljs-operator\">&lt;</span><span class=\"hljs-keyword\">WHERE</span> <span class=\"hljs-keyword\">condition</span><span class=\"hljs-operator\">&gt;</span>;\t<br></code></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>只会删除数据，不会删除表的结构</p>\n<blockquote>\n<p><strong>Delete删除的问题</strong></p>\n<p>删除完毕后，重启数据库后，</p>\n<p>如果引擎是InnoDB，自增列从1开始 （因为是存在内存中的，断电即失）；</p>\n<p>如果引擎是MyISAM，继续自增（存在文件中）</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>truncate命令</strong></p>\n<p>作用：用于完全清空表数据 , 但表结构 , 索引 , 约束等不变 ;</p>\n<p>语法：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">TRUNCATE</span> <span class=\"hljs-operator\">&lt;</span><span class=\"hljs-keyword\">table</span><span class=\"hljs-operator\">&gt;</span> 表名;<br><br><span class=\"hljs-comment\">-- 清空年级表</span><br><span class=\"hljs-keyword\">TRUNCATE</span> grade<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意：区别于delete命令</strong></p>\n<ul>\n<li>相同 : 都能删除数据 , 不删除表结构 , 但TRUNCATE速度更快</li>\n<li>不同 :\n<ul>\n<li>使用TRUNCATE TABLE 重新设置AUTO_INCREMENT计数器(自增归0)</li>\n<li>使用TRUNCATE TABLE不会对事务有影响 （事务后面会说）</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n","categories":["MySql基础学习"],"tags":["MySql"]},{"title":"6.MySQL函数","url":"/2021/10/01/6.MySQL%E5%87%BD%E6%95%B0/","content":"<h1 id=\"mysql函数\"><a class=\"markdownIt-Anchor\" href=\"#mysql函数\"></a> MySQL函数</h1>\n<h2 id=\"常用函数\"><a class=\"markdownIt-Anchor\" href=\"#常用函数\"></a> 常用函数</h2>\n<blockquote>\n<p>以下示例中具体数字都可以用字段表示</p>\n</blockquote>\n<h3 id=\"数学运算\"><a class=\"markdownIt-Anchor\" href=\"#数学运算\"></a> 数学运算</h3>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">abs</span>(<span class=\"hljs-number\">-8</span>)\t\t\t<span class=\"hljs-comment\">-- 绝对值</span><br><span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">ceiling</span>(<span class=\"hljs-number\">8.3</span>)\t\t<span class=\"hljs-comment\">-- 向上取整</span><br><span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">floor</span>(<span class=\"hljs-number\">8.3</span>)\t\t<span class=\"hljs-comment\">-- 向下取整</span><br><span class=\"hljs-keyword\">select</span> rand()\t\t\t<span class=\"hljs-comment\">-- 返回一个0-1之间的随机数</span><br><span class=\"hljs-keyword\">select</span> sing(<span class=\"hljs-number\">-10</span>)\t\t<span class=\"hljs-comment\">-- 判断一个数的符号，负数返回-1、正数返回1</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"字符串操作\"><a class=\"markdownIt-Anchor\" href=\"#字符串操作\"></a> 字符串操作</h3>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">char_length</span>(<span class=\"hljs-string\">&#x27;xxxx&#x27;</span>)\t\t\t\t\t<span class=\"hljs-comment\">-- 显示字符串的长度</span><br><span class=\"hljs-keyword\">select</span> concat(<span class=\"hljs-string\">&#x27;姓名&#x27;</span>，name)\t\t\t  \t  <span class=\"hljs-comment\">-- 拼接字符串</span><br><span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">insert</span>(<span class=\"hljs-string\">&#x27;my name&#x27;</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;your&#x27;</span>)\t\t\t<span class=\"hljs-comment\">-- 在某个位置开始替换掉一定长度内原来的字符 示例结果：youry name</span><br><span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">lower</span>(<span class=\"hljs-string\">&#x27;Name&#x27;</span>)\t\t\t\t<span class=\"hljs-comment\">-- 大写转小写</span><br><span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">upper</span>(<span class=\"hljs-string\">&#x27;Name&#x27;</span>)\t\t\t\t<span class=\"hljs-comment\">-- 小写转大写</span><br><span class=\"hljs-keyword\">select</span> instr(<span class=\"hljs-string\">&#x27;MySQL&#x27;</span>，<span class=\"hljs-string\">&#x27;SQL&#x27;</span>)\t\t\t<span class=\"hljs-comment\">-- 返回第一次出现字串的索引(注意不是下标),不存在就返回0</span><br><span class=\"hljs-keyword\">select</span> replace(<span class=\"hljs-string\">&#x27;MySQL learn&#x27;</span>,<span class=\"hljs-string\">&#x27;learn&#x27;</span>,<span class=\"hljs-string\">&#x27;study&#x27;</span>)\t<span class=\"hljs-comment\">-- 替换指定的字符串</span><br><span class=\"hljs-keyword\">select</span> substr(<span class=\"hljs-string\">&#x27;MySQL learn&#x27;</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">6</span>)\t<span class=\"hljs-comment\">-- 截取指定的字符串（源字符串，截取的位置，截取的长度)</span><br><span class=\"hljs-keyword\">select</span> reverse(<span class=\"hljs-string\">&#x27;MySQL learn&#x27;</span>)\t\t<span class=\"hljs-comment\">-- 翻转字符串</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>\n<p><code>instr</code>不区分大小写</p>\n<blockquote>\n<p>mysql 进行模糊查询时，可使用内部函数 instr，替代传统的 like 方式，并且速度更快。</p>\n<p><code>select * from book where instr(bookName,'经')&gt;0</code></p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"时间和日期函数\"><a class=\"markdownIt-Anchor\" href=\"#时间和日期函数\"></a> 时间和日期函数</h3>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">current_date</span>()\t\t<span class=\"hljs-comment\">-- 查询当前的日期</span><br><span class=\"hljs-keyword\">select</span> now()\t\t\t<span class=\"hljs-comment\">-- 查询当前的时间（月份+时间）</span><br><span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">localtime</span>()\t\t<span class=\"hljs-comment\">-- 获取本地时间</span><br><span class=\"hljs-keyword\">select</span> sysdate()\t\t<span class=\"hljs-comment\">-- 获取系统时间</span><br><br><span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">year</span><span class=\"hljs-operator\">/</span><span class=\"hljs-keyword\">month</span><span class=\"hljs-operator\">/</span><span class=\"hljs-keyword\">day</span><span class=\"hljs-operator\">/</span><span class=\"hljs-keyword\">hour</span><span class=\"hljs-operator\">/</span><span class=\"hljs-keyword\">minute</span><span class=\"hljs-operator\">/</span><span class=\"hljs-keyword\">second</span>(now())<br></code></pre></td></tr></table></figure>\n<h3 id=\"系统函数\"><a class=\"markdownIt-Anchor\" href=\"#系统函数\"></a> 系统函数</h3>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">user</span>()\t<span class=\"hljs-comment\">-- 显示当前用户</span><br><span class=\"hljs-keyword\">select</span> version()\t<span class=\"hljs-comment\">-- 显示mysql版本信息</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"聚合函数\"><a class=\"markdownIt-Anchor\" href=\"#聚合函数\"></a> 聚合函数</h2>\n<table>\n<thead>\n<tr>\n<th>函数名称</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>count()</td>\n<td></td>\n</tr>\n<tr>\n<td>sum()</td>\n<td></td>\n</tr>\n<tr>\n<td>avg()</td>\n<td></td>\n</tr>\n<tr>\n<td>max()</td>\n<td></td>\n</tr>\n<tr>\n<td>min()</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>Q: count(*)、count(字段名)、count(1)区别？</p>\n<p>A: count(字段名)会忽略对应字段的空值，其余两个不会忽略</p>\n<p><strong>count(字段名)效率更快</strong></p>\n</blockquote>\n<h2 id=\"数据库级别的md5扩展\"><a class=\"markdownIt-Anchor\" href=\"#数据库级别的md5扩展\"></a> 数据库级别的MD5（扩展）</h2>\n<p>MD5: <strong>信息摘要算法</strong>,主要增强算法复杂度和不可逆</p>\n<blockquote>\n<p>具体值的md5是一样的</p>\n</blockquote>\n<p><strong>函数md5(未加密数据)</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 示例</span><br>update testmd5 <span class=\"hljs-keyword\">set</span> pwd<span class=\"hljs-operator\">=</span>md5(pwd) <span class=\"hljs-keyword\">where</span> id <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> testmd5 <span class=\"hljs-keyword\">values</span>(<span class=\"hljs-number\">5</span>,md5(<span class=\"hljs-string\">&#x27;12345&#x27;</span>))<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>Q: 如何校验用户输入的密码是否正确？</p>\n<p>A: 将用户的密码先用md5加密后，再去对比加密后的密文是否相同即可</p>\n</blockquote>\n","categories":["MySql基础学习"],"tags":["MySql"]},{"title":"4.分支管理","url":"/2021/08/03/4.%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/","content":"<h1 id=\"分支管理\"><a class=\"markdownIt-Anchor\" href=\"#分支管理\"></a> 分支管理</h1>\n<h2 id=\"创建与合并分支\"><a class=\"markdownIt-Anchor\" href=\"#创建与合并分支\"></a> 创建与合并分支</h2>\n<ul>\n<li>\n<p><code>HEAD指针</code>：指向你正在工作中的本地分支的指针</p>\n</li>\n<li>\n<p>默认本地仓库只有一条分支<code>main</code></p>\n<ul>\n<li><code>HEAD</code>指向<code>main</code>,<code>main</code>指向要提交的时间线</li>\n</ul>\n</li>\n<li>\n<p><code>git switch &lt;分支名&gt;</code>:切换分支</p>\n<ul>\n<li>\n<p><code>-c</code> 创建并切换分支，分支指向<code>main</code>相同的提交</p>\n</li>\n<li>\n<p>此时<code>HEAD</code>指向新分支。之后的提交都是在新分支下</p>\n<p><img src=\"/2021/08/03/4.%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/0.png\" alt=\"img\"></p>\n<ul>\n<li><code>HEAD</code>指向正在工作的本地分支，随该分支一起移动</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>git branch</code>：查看本地所有分支</p>\n<ul>\n<li>当前分支名前会有一个*号</li>\n<li><code>-a</code>：查看本地和远程仓库所有分支</li>\n<li><code>-r</code>：查看远程仓库分支</li>\n<li><code>-v</code>：查看各分支最后一个提交对象的信息</li>\n<li><code>--merged</code>：查看哪些分支是当前分支的直接上游\n<ul>\n<li>一般来说，列表中没有 <code>*</code> 的分支通常都可以用 <code>git branch -d</code> 来删掉。原因很简单，既然已经把它们所包含的工作整合到了其他分支，删掉也不会损失什么</li>\n</ul>\n</li>\n<li><code>--no-merged</code>：查看尚未合并的工作\n<ul>\n<li>由于这些分支中还包含着尚未合并进来的工作成果，所以简单地用 <code>git branch -d</code> 删除该分支会提示错误，因为那样做会丢失数据</li>\n<li><code>-D</code>：强制删除</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><code>git merge &lt;分支名&gt;</code>：合并指定分支的工作到当前分支下</p>\n</li>\n<li>\n<p><code>git branch -d &lt;分支名&gt;</code>：删除分支</p>\n<ul>\n<li><code>-D</code>：删除一个没有被合并过得分支</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"实际操作总结\"><a class=\"markdownIt-Anchor\" href=\"#实际操作总结\"></a> 实际操作总结</h3>\n<ul>\n<li>如果分支切换时，该分支的暂存区或者工作目录里，存在还没有提交的修改，会和你即将检出的分支产生冲突从而阻止 Git 为你切换分支\n<ul>\n<li>要么提交修改，要么使用<code>git stash</code>暂存</li>\n</ul>\n</li>\n<li>分支切换后，Git 会把工作目录的内容恢复为检出某分支时它所指向的那个提交对象的快照</li>\n</ul>\n<h2 id=\"分支冲突\"><a class=\"markdownIt-Anchor\" href=\"#分支冲突\"></a> 分支冲突</h2>\n<ul>\n<li>\n<p><strong>单线的历史分支不存在任何需要解决的分歧</strong></p>\n</li>\n<li>\n<p>合并冲突：</p>\n<ul>\n<li>\n<p>当创建多分支时，如果修改不同文件，则合并不会提示冲突</p>\n<ul>\n<li>任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出</li>\n</ul>\n</li>\n<li>\n<p>如果在不同分支中修改相同文件，合并时会提示冲突，需要手动修改冲突，确定文件的最终版本</p>\n<ul>\n<li>删除标记</li>\n</ul>\n<p><img src=\"/2021/08/03/4.%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/1.png\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容</p>\n<ul>\n<li><code>=======</code> 隔开的上半部分，是 <code>HEAD</code>中的内容，下半部分是在合并分支中的内容</li>\n</ul>\n</li>\n<li>\n<p>合并策略：</p>\n<ul>\n<li>\n<p>默认使用<code>Fast forward</code>，会直接将Master分支指向Develop分支。在这种模式下，删除分支后，会丢掉分支信息</p>\n<img src=\"/2021/08/03/4.%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/2.png\" alt=\"img\" style=\"zoom:80%;\">\n</li>\n<li>\n<p><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code></p>\n<ul>\n<li>\n<p>使用<code>--no-ff</code>参数后，会执行正常合并，在Master分支上生成一个新节点</p>\n<img src=\"/2021/08/03/4.%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/3.png\" alt=\"img\" style=\"zoom:80%;\">\n</li>\n<li>\n<p>当合并的分支，没有祖先关系（即两个不同线分支），Git会用两个分支以及它们的共同祖先进行一次简单的三方合并计算，然后创建一个分支存放合并结果</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并</p>\n</li>\n</ul>\n<h2 id=\"分支管理策略\"><a class=\"markdownIt-Anchor\" href=\"#分支管理策略\"></a> 分支管理策略</h2>\n<p><img src=\"/2021/08/03/4.%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/4.png\" alt=\"img\"></p>\n<ul>\n<li>\n<p><mark>主分支main(master)</mark>:代码库应该有一个、且仅有一个主分支。仅用来发布新版本，平时不能在上面干活.</p>\n</li>\n<li>\n<p><mark>工作分支dev</mark>：日常开发。如果想正式对外发布，就在分支上，对Develop分支进行&quot;合并&quot;</p>\n</li>\n<li>\n<p><strong>临时分支</strong>：</p>\n<ul>\n<li>\n<p><mark>功能分支feature-xxx</mark>：为了开发某种特定功能，从<code>dev分支</code>上面分出来的。开发完成后，要再并入dev</p>\n<img src=\"/2021/08/03/4.%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/5.png\" alt=\"img\" style=\"zoom:80%;\">\n</li>\n<li>\n<p><mark>预发布分支release-xxx</mark>：指发布正式版本之前（即合并到<code>main分支</code>之前），我们可能需要有一个预发布的版本进行测试。预发布分支是从<code>dev分支</code>上面分出来的，预发布结束以后，必须合并进<code>dev和main分支</code>.</p>\n</li>\n<li>\n<p><mark>修补bug分支fixbug-xxx</mark>：修补bug分支是从<code>main分支</code>上面分出来的。修补结束以后，再合并进<code>main和dev分支</code></p>\n<ul>\n<li>\n<p>bug突然出现，如何保存当前的工作?恢复工作？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs she\">git stash\t//把当前工作现场“储藏”起来，等以后恢复现场后继续工作<br>git stash list\t//查看该分支保存的状态<br>git stash pop\t//在该分支下，恢复之前保存的状态，并删除该记录（如果状态属于该分支会删除，如果不属于相当于一个合并操作）<br>git stash apply &lt;名字&gt;\t//恢复指定的状态<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>修补<code>main分支</code>后，如何在<code>dev分支</code>上进行同样的修改操作？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs she\">git chery-pick &lt;commit编号&gt;\t//复制一个特定的提交到当前分支<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"多人协作\"><a class=\"markdownIt-Anchor\" href=\"#多人协作\"></a> 多人协作</h2>\n<ul>\n<li>\n<p>当从远程仓库克隆时，实际上Git自动把本地的<code>main</code>分支和远程的<code>main</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code></p>\n<ul>\n<li>\n<p>用 <code>(远程仓库名)/(分支名)</code> 这样的形式表示远程分支</p>\n</li>\n<li>\n<p>它们是一些无法移动的本地分支，只有在 Git 进行网络交互时才会更新</p>\n<img src=\"/2021/08/03/4.%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/6.png\" alt=\"img\" style=\"zoom:80%;\">\n</li>\n</ul>\n</li>\n<li>\n<p>分支推送策略：</p>\n<ul>\n<li><code>main</code>分支是主分支，因此要时刻与远程同步；</li>\n<li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>\n<li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li>\n<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>\n</ul>\n</li>\n<li>\n<p>工作模式：</p>\n<ol>\n<li>\n<p>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p>\n</li>\n<li>\n<p>如果推送失败，则<strong>因为远程分支比你的本地新</strong>，需要先用<code>git pull</code>试图合并来保证本地和远程同步；</p>\n<img src=\"/2021/08/03/4.%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/7.png\" alt=\"img\" style=\"zoom:80%;\">\n<ul>\n<li>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</li>\n</ul>\n</li>\n<li>\n<p>如果合并有冲突，则解决冲突，并在本地提交；</p>\n</li>\n<li>\n<p>用<code>git status</code>查看当前状态、寻找冲突的文件，手动修改</p>\n</li>\n<li>\n<p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"rebase\"><a class=\"markdownIt-Anchor\" href=\"#rebase\"></a> rebase</h2>\n<ul>\n<li>\n<p>作用：rebase操作可以把本地未push的分叉提交历史整理成直线；</p>\n</li>\n<li>\n<p>目的：使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>\n</li>\n<li>\n<p>示例：</p>\n<p><img src=\"/2021/08/03/4.%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/8.png\" alt=\"img\"></p>\n<ul>\n<li>\n<p>通过<code>merge</code>合并这两个分支，会产生一个新的提交对象（C5）</p>\n</li>\n<li>\n<pre class=\"highlight\"><code class=\"shel\">$ git checkout experiment\n$ git rebase master\n    First, rewinding head to replay your work on top of it...\n    Applying: added staged command\n</code></pre>\n<p>会在在 C3 里产生的变化补丁在 C4 的基础上重新打一遍</p>\n</li>\n</ul>\n</li>\n<li>\n<p>原理：回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支 <code>experiment</code>）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支 <code>master</code>）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写 <code>experiment</code> 的提交历史，使它成为 <code>master</code> 分支的直接下游</p>\n<p><img src=\"/2021/08/03/4.%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/9.png\" alt=\"img\"></p>\n</li>\n<li>\n<p>命令：<code>git rebase [主分支] [特性分支]</code> 命令会先取出特性分支 ，然后在主分支上重演</p>\n<ul>\n<li>特性分支必须是从主分支直接分出来的，一步一步走</li>\n<li><code>git rebase --onto &lt;主分支&gt; &lt;特性分支1&gt; &lt;特性分支2&gt;</code>\n<ul>\n<li>特性分支1从主分支分出，特性分支2从特性分支1分出</li>\n<li>取出 <code>主分支</code> 分支，找出 <code>特性分支2</code> 分支和 <code>特性分支1</code> 分支的共同祖先之后的变化，然后把它们在 <code>主分支</code> 上重演一遍</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>注意：<strong>一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。</strong></p>\n</li>\n</ul>\n<h2 id=\"相关命令\"><a class=\"markdownIt-Anchor\" href=\"#相关命令\"></a> 相关命令</h2>\n<ul>\n<li><code>git remote</code>：查看远程库的信息\n<ul>\n<li><code>-v</code>：显示更详细的信息，显示可以抓取和推送的地址</li>\n</ul>\n</li>\n<li><code>git push origin --delete &lt;远程分支名&gt;</code>：删除远程分支\n<ul>\n<li><code>git clone -b &lt;指定分支名&gt; &lt;远程仓库地址&gt;</code>：克隆远程库指定分支到本地库</li>\n</ul>\n</li>\n<li></li>\n</ul>\n<p><strong>扩展阅读</strong></p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2012/07/git.html\">Git分支管理策略</a></li>\n</ul>\n","categories":["Git学习"],"tags":["Github"]},{"title":"5.MySQL数据库DQL操作","url":"/2021/10/01/5.MySQL%E6%95%B0%E6%8D%AE%E5%BA%93DQL%E6%93%8D%E4%BD%9C/","content":"<h1 id=\"mysql数据库dql操作\"><a class=\"markdownIt-Anchor\" href=\"#mysql数据库dql操作\"></a> MySQL数据库DQL操作</h1>\n<h2 id=\"基本知识\"><a class=\"markdownIt-Anchor\" href=\"#基本知识\"></a> 基本知识</h2>\n<ul>\n<li><strong>DQL(数据库查询语言)</strong>：用于查询数据库数据\n<ul>\n<li>select</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"语法\"><a class=\"markdownIt-Anchor\" href=\"#语法\"></a> 语法</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs mysql\">SELECT &lt;ALL | DISTINCT&gt;\t\t-- 是否去重<br>&#123;* | [table.field1[as alias1][,table.field2[as alias2]][,...]]&#125;\t-- 设置最终结果显示d<br>FROM table_name [as table_alias]<br>  [left | right | inner join table_name2]  -- 联合查询<br>  [WHERE ...]  -- 指定结果需满足的条件<br>  [GROUP BY ...]  -- 指定结果按照哪几个字段来分组<br>  [HAVING]  -- 过滤分组的记录必须满足的次要条件<br>  [ORDER BY ...]  -- 指定查询记录按一个或多个条件排序<br>  [LIMIT &#123;[offset,]row_count | row_countOFFSET offset&#125;];<br>   -- 指定查询的记录从哪条至哪条<br>   <br>-- 在这里[]代表可选的\t<br></code></pre></td></tr></table></figure>\n<h2 id=\"sql执行顺序\"><a class=\"markdownIt-Anchor\" href=\"#sql执行顺序\"></a> SQL执行顺序</h2>\n<p><img src=\"https://img-blog.csdn.net/20180729102302530?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppYWRhamluZzI2Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"img\"></p>\n<h2 id=\"数据库的列表达式\"><a class=\"markdownIt-Anchor\" href=\"#数据库的列表达式\"></a> 数据库的列（表达式）</h2>\n <figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">select</span> version() \t<span class=\"hljs-comment\">-- 查询系统版本（函数）</span><br><span class=\"hljs-keyword\">select</span> <span class=\"hljs-number\">10</span><span class=\"hljs-operator\">*</span><span class=\"hljs-number\">3</span><span class=\"hljs-number\">-1</span> <span class=\"hljs-keyword\">as</span> 计算机结果\t<span class=\"hljs-comment\">-- 用来计算（表达式）</span><br><span class=\"hljs-keyword\">select</span> @<span class=\"hljs-variable\">@auto</span>_increament_increament <span class=\"hljs-comment\">-- 查询自增的步长（变量）</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>数据库中的表达式</strong>：文本值、列、NULL、函数，计算表达式、系统变量</p>\n</blockquote>\n<h2 id=\"where条件字句\"><a class=\"markdownIt-Anchor\" href=\"#where条件字句\"></a> Where条件字句</h2>\n<ul>\n<li>作用：检索数据中符合条件的值</li>\n</ul>\n<h3 id=\"逻辑运算符\"><a class=\"markdownIt-Anchor\" href=\"#逻辑运算符\"></a> 逻辑运算符</h3>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A and B    &amp;&amp;</td>\n<td>逻辑与</td>\n</tr>\n<tr>\n<td>A or B    ||</td>\n<td>逻辑或</td>\n</tr>\n<tr>\n<td>not A=1  !</td>\n<td>逻辑非</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"模糊查询比运算符\"><a class=\"markdownIt-Anchor\" href=\"#模糊查询比运算符\"></a> 模糊查询：比运算符</h3>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A is null</td>\n<td>如果A为NULL，结果为真</td>\n</tr>\n<tr>\n<td>A is not null</td>\n<td></td>\n</tr>\n<tr>\n<td>A between xx and xx</td>\n<td>A在xx 和 xx 之间</td>\n</tr>\n<tr>\n<td>A like ‘xxx’</td>\n<td>A和 xxx匹配</td>\n</tr>\n<tr>\n<td>A in (xx,xxx)</td>\n<td>A被包含在(xx,xxx)里面</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>匹配原则：正则匹配</p>\n<p>%：匹配任意个字符</p>\n<p>_：只匹配一个字符</p>\n</blockquote>\n<h2 id=\"联表查询join\"><a class=\"markdownIt-Anchor\" href=\"#联表查询join\"></a> 联表查询Join</h2>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 示例</span><br>slelect A.num,B.name<br><span class=\"hljs-keyword\">from</span> A <span class=\"hljs-operator\">&lt;</span><span class=\"hljs-keyword\">left</span> <span class=\"hljs-operator\">|</span> <span class=\"hljs-keyword\">inner</span> <span class=\"hljs-operator\">|</span> <span class=\"hljs-keyword\">right</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">join</span> B   A.num <span class=\"hljs-operator\">=</span> B.num<br></code></pre></td></tr></table></figure>\n<p><strong>Left join</strong>：显示左边所有的数据，即使B种没有匹配的对应值也会显示；而B种数据在A种没有匹配的就不会显示</p>\n<p><strong>Right join</strong>：和上面说法相反</p>\n<p><strong>Inner join</strong>：只会显示A、B均有匹配的值，所以不会出现未匹配的数据</p>\n<h3 id=\"自连接\"><a class=\"markdownIt-Anchor\" href=\"#自连接\"></a> 自连接</h3>\n<p>自己的表和自己的表连接，<strong>核心：一张表拆成两张一样的表</strong></p>\n<blockquote>\n<p>将表多次命别名，相当于两个表进行操作</p>\n</blockquote>\n<h2 id=\"分页和排序\"><a class=\"markdownIt-Anchor\" href=\"#分页和排序\"></a> 分页和排序</h2>\n<h3 id=\"排序\"><a class=\"markdownIt-Anchor\" href=\"#排序\"></a> 排序</h3>\n<p><strong>根据指定字段排列行数据</strong></p>\n<ul>\n<li>\n<p>升序ASC：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">order</span> <span class=\"hljs-keyword\">by</span> [列名]   <span class=\"hljs-comment\">-- 默认升序</span><br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>降序DESC</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">order</span> <span class=\"hljs-keyword\">by</span> [列名] <span class=\"hljs-keyword\">desc</span>  <span class=\"hljs-comment\">-- 降序排列</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"分页\"><a class=\"markdownIt-Anchor\" href=\"#分页\"></a> 分页</h3>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 示例：每页只显示五条数据</span><br><span class=\"hljs-keyword\">select</span> ...<br><span class=\"hljs-keyword\">order</span> <span class=\"hljs-keyword\">by</span> xx<br>limit <span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">5</span>\t<span class=\"hljs-comment\">-- （n - 1）*pageSize</span><br><span class=\"hljs-comment\">-- 【pageSize:页面大小；n:当前页；（n-1）*pageSize:数据起始位置；数据总数/pageSize=当前页数】</span><br></code></pre></td></tr></table></figure>\n<p><strong>格式</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\">limit [查询起始下标]，[往下显示的行数]<br><br><span class=\"hljs-comment\">--------</span><br>limit <span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">5</span> <span class=\"hljs-comment\">-- 从第2行数据开始（不包括第2行)，往下显示5个数据</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>所以，如果我们要实现分页的效果，实际上是处理起始数据的行数选择，根据公式（ n - 1)*pageSize 来确定起始数据。</p>\n<p>即，如果想显示第2页数据，（2-1）*5=5，所以起始数据填 5，数据显示从第6行 - 第10行</p>\n</blockquote>\n<blockquote>\n<p>瀑布流：一般图片才会采用</p>\n<p>根据进度条的位置，不断加载数据</p>\n</blockquote>\n<h2 id=\"子查询和嵌套查询\"><a class=\"markdownIt-Anchor\" href=\"#子查询和嵌套查询\"></a> 子查询和嵌套查询</h2>\n<p>where (这个值是计算出来的)</p>\n<p><strong>本质</strong>：在where语句中嵌套一个查询</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 示例 查询选修了数据库-1的学生</span><br><span class=\"hljs-keyword\">select</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">from</span> student<br><span class=\"hljs-keyword\">where</span> studentNo <span class=\"hljs-operator\">=</span> (<br>    <span class=\"hljs-keyword\">select</span> studentNo <span class=\"hljs-keyword\">from</span> subject<br>    <span class=\"hljs-keyword\">where</span> subject <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;数据库-1&#x27;</span><br>)<br><br><span class=\"hljs-comment\">-- 也可以联表查询</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>使用子查询，要注意where 里面的子查询返回的列要等于结果。</p>\n<p>所以一般来说，子查询只返回一列结果</p>\n</blockquote>\n<h2 id=\"group-by\"><a class=\"markdownIt-Anchor\" href=\"#group-by\"></a> Group by</h2>\n<p>根据某个字段分组统计</p>\n<ul>\n<li>可以结合聚合函数统计各组数据</li>\n<li>分组筛选的条件不能用<code>where</code>,要用<code>having</code>来筛选各组</li>\n</ul>\n","categories":["MySql基础学习"],"tags":["MySql"]},{"title":"5.标签管理","url":"/2021/08/03/5.%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/","content":"<h1 id=\"标签管理\"><a class=\"markdownIt-Anchor\" href=\"#标签管理\"></a> 标签管理</h1>\n<h2 id=\"标签简介\"><a class=\"markdownIt-Anchor\" href=\"#标签简介\"></a> 标签简介</h2>\n<ul>\n<li>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个<strong>快照</strong>。</li>\n<li>tag相较于commit号，更好记。</li>\n</ul>\n<h2 id=\"创建标签\"><a class=\"markdownIt-Anchor\" href=\"#创建标签\"></a> 创建标签</h2>\n<ol>\n<li>切换到需要打标签的分支上</li>\n<li>输入命令<code>git tag &lt;name&gt;</code>，为该分支的最新提交打标签\n<ul>\n<li>如果想要为特定提交打标签，则需要找到commit号(<code>git log</code>)</li>\n<li>用命令<code>git tag &lt;name&gt; &lt;commit号&gt;</code></li>\n</ul>\n</li>\n<li><code>git tag</code>查看所有标签\n<ul>\n<li>标签不是按时间顺序列出的，而是按字母排列的</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"相关命令\"><a class=\"markdownIt-Anchor\" href=\"#相关命令\"></a> 相关命令</h3>\n<ul>\n<li><code>git show &lt;tag名字&gt;</code>：查看标签信息</li>\n<li><code>git tag -a &lt;标签名&gt; -m &quot;xxx&quot;</code>:创建带有说明的标签</li>\n</ul>\n<p><strong>注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</strong></p>\n<h2 id=\"操作标签\"><a class=\"markdownIt-Anchor\" href=\"#操作标签\"></a> 操作标签</h2>\n<h3 id=\"相关命令-2\"><a class=\"markdownIt-Anchor\" href=\"#相关命令-2\"></a> 相关命令</h3>\n<ul>\n<li><code>git tag -d &lt;标签名&gt;</code>：删除本地仓库标签\n<ul>\n<li>如果标签已经被推送到远程仓库，那先删除本地仓库标签\n<ul>\n<li>用<code>git push origin :refs/tags/&lt;标签名&gt;</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>git tag -l '正则表达式'</code>：根据特定的搜索模式列出符合条件的标签</li>\n<li><code>git push origin &lt;标签名&gt;</code>：推送标签到远程仓库</li>\n<li><code>git push origin --tags</code>:一次性推送全部尚未推送到远程仓库的本地标签</li>\n</ul>\n","categories":["Git学习"],"tags":["Github"]},{"title":"6.自定义Git","url":"/2021/08/03/6.%E8%87%AA%E5%AE%9A%E4%B9%89Git/","content":"<h1 id=\"自定义git\"><a class=\"markdownIt-Anchor\" href=\"#自定义git\"></a> 自定义Git</h1>\n<h2 id=\"配置git\"><a class=\"markdownIt-Anchor\" href=\"#配置git\"></a> 配置Git</h2>\n<ul>\n<li>\n<p>三种配置文件</p>\n<ul>\n<li><code>/etc/gitconfig</code> 文件：系统中对所有用户都普遍适用的配置。若使用 <code>git config</code> 时用 <code>--system</code> 选项，读写的就是这个文件。</li>\n<li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户。若使用 <code>git config</code> 时用 <code>--global</code> 选项，读写的就是这个文件。</li>\n<li>当前项目的 git 目录中的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 <code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code> 中的同名变量。</li>\n</ul>\n</li>\n<li>\n<p><code>git config --global user.name &quot;xxx&quot;</code>\t配置每次提交记录名称<br>\n<code>git config --global user.email &quot;email@example.com&quot;</code>\t配置每次提交个人信息</p>\n</li>\n<li>\n<p><code>git config --global color.ui true</code>：让Git显示颜色</p>\n</li>\n<li>\n<p><code>git config --list</code>：检查已有的配置信息</p>\n<ul>\n<li><code>git config &lt;环境变量名&gt;</code>：检查特定环境变量的设定</li>\n</ul>\n</li>\n<li>\n<p><code>git config --global alias.&lt;别名&gt; &lt;实际名字&gt;</code>：配置别名</p>\n<ul>\n<li>每个仓库的Git配置文件都放在<code>.git/config</code>文件中,别名就在<code>[alias]</code>后面</li>\n<li><code>git config --edig</code>：打开当前用户的git配置并编辑\n<ul>\n<li><code>--global</code>:打开当前用户git的全局配置并编辑</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"忽略特殊文件\"><a class=\"markdownIt-Anchor\" href=\"#忽略特殊文件\"></a> 忽略特殊文件</h2>\n<ul>\n<li>\n<p>忽略文件的原则是：</p>\n<ol>\n<li>忽略操作系统自动生成的文件，比如缩略图等；</li>\n<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的<code>.class</code>文件；</li>\n<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li>\n</ol>\n</li>\n<li>\n<p>在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件</p>\n<ul>\n<li>如果你确实想添加该文件，可以用<code>-f</code>强制添加到Git</li>\n<li>或者你发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查</li>\n</ul>\n</li>\n<li>\n<p><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理！</p>\n</li>\n<li>\n<p>把指定文件排除在<code>.gitignore</code>规则外的写法就是<code>!+文件名</code></p>\n</li>\n</ul>\n<h2 id=\"搭建git服务器\"><a class=\"markdownIt-Anchor\" href=\"#搭建git服务器\"></a> 搭建Git服务器</h2>\n<p>搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的<code>apt</code>命令就可以完成安装。</p>\n<p>假设你已经有<code>sudo</code>权限的用户账号，下面，正式开始安装。</p>\n<ul>\n<li>第一步，安装<code>git</code>：</li>\n</ul>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><code class=\"hljs routeros\">$ sudo apt-<span class=\"hljs-builtin-name\">get</span> install git<br></code></pre></td></tr></table></figure>\n<ul>\n<li>第二步，创建一个<code>git</code>用户，用来运行<code>git</code>服务：</li>\n</ul>\n<figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-variable\">$ </span>sudo adduser git<br></code></pre></td></tr></table></figure>\n<ul>\n<li>第三步，创建证书登录：</li>\n</ul>\n<p>收集所有需要登录的用户的公钥，就是他们自己的<code>id_rsa.pub</code>文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</p>\n<ul>\n<li>第四步，初始化Git仓库：</li>\n</ul>\n<p>先选定一个目录作为Git仓库，假定是<code>/srv/sample.git</code>，在<code>/srv</code>目录下输入命令：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"code\"><pre><code class=\"hljs ada\">$ sudo git init <span class=\"hljs-comment\">--bare sample.git</span><br></code></pre></td></tr></table></figure>\n<p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以<code>.git</code>结尾。然后，把owner改为<code>git</code>：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-variable\">$ </span>sudo chown -R <span class=\"hljs-symbol\">git:</span>git sample.git<br></code></pre></td></tr></table></figure>\n<ul>\n<li>第五步，禁用shell登录：</li>\n</ul>\n<p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑<code>/etc/passwd</code>文件完成。找到类似下面的一行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">git:</span><span class=\"hljs-symbol\">x:</span><span class=\"hljs-number\">1001</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">1001</span><span class=\"hljs-symbol\">:</span>,,,<span class=\"hljs-symbol\">:/home/git</span><span class=\"hljs-symbol\">:/bin/bash</span><br></code></pre></td></tr></table></figure>\n<p>改为：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-symbol\">git:</span><span class=\"hljs-symbol\">x:</span><span class=\"hljs-number\">1001</span><span class=\"hljs-symbol\">:</span><span class=\"hljs-number\">1001</span><span class=\"hljs-symbol\">:</span>,,,<span class=\"hljs-symbol\">:/home/git</span><span class=\"hljs-symbol\">:/usr/bin/git-shell</span><br></code></pre></td></tr></table></figure>\n<p>这样，<code>git</code>用户可以正常通过ssh使用git，但无法登录shell，因为我们为<code>git</code>用户指定的<code>git-shell</code>每次一登录就自动退出。</p>\n<ul>\n<li>第六步，克隆远程仓库：</li>\n</ul>\n<p>现在，可以通过<code>git clone</code>命令克隆远程仓库了，在各自的电脑上运行：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-variable\">$ </span>git clone git@&lt;服务器地址&gt;<span class=\"hljs-symbol\">:/srv/sample</span>.git<br>Cloning into <span class=\"hljs-string\">&#x27;sample&#x27;</span>...<br><span class=\"hljs-symbol\">warning:</span> You appear to have cloned an empty repository.<br></code></pre></td></tr></table></figure>\n<p>剩下的推送就简单了。</p>\n<h3 id=\"管理公钥\"><a class=\"markdownIt-Anchor\" href=\"#管理公钥\"></a> 管理公钥</h3>\n<p>如果团队很小，把每个人的公钥收集起来放到服务器的<code>/home/git/.ssh/authorized_keys</code>文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用<a href=\"https://github.com/res0nat0r/gitosis\">Gitosis</a>来管理公钥。</p>\n<p>这里我们不介绍怎么玩<a href=\"https://github.com/res0nat0r/gitosis\">Gitosis</a>了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。</p>\n<h3 id=\"管理权限\"><a class=\"markdownIt-Anchor\" href=\"#管理权限\"></a> 管理权限</h3>\n<p>有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。<a href=\"https://github.com/sitaramc/gitolite\">Gitolite</a>就是这个工具。</p>\n<p>这里我们也不介绍<a href=\"https://github.com/sitaramc/gitolite\">Gitolite</a>了，不要把有限的生命浪费到权限斗争中。</p>\n","categories":["Git学习"],"tags":["Github"]},{"title":"7.事务","url":"/2021/10/01/7.%E4%BA%8B%E5%8A%A1/","content":"<h1 id=\"事务\"><a class=\"markdownIt-Anchor\" href=\"#事务\"></a> 事务</h1>\n<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h2>\n<p><strong>事务</strong>：事务里面的操作，要么都成功，要么都失败</p>\n<h2 id=\"事务原则acid\"><a class=\"markdownIt-Anchor\" href=\"#事务原则acid\"></a> 事务原则：ACID</h2>\n<ul>\n<li>\n<p>原子性：同一个事务中的操作同时成功或失败，不能只发生一个</p>\n</li>\n<li>\n<p>一致性：事务操作前后的数据完整性一致</p>\n</li>\n<li>\n<p>隔离性：多个用户同时操作，相互不会影响</p>\n</li>\n<li>\n<p>持久性：事务一旦提交就不可逆</p>\n<blockquote>\n<p>如果事务没有提交，那么数据状态保持不变；</p>\n<p>如果事务已经提交，那么无论发生什么事情，数据的状态都会保持提交后的状态</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"事务的隔离级别\"><a class=\"markdownIt-Anchor\" href=\"#事务的隔离级别\"></a> 事务的隔离级别</h2>\n<h3 id=\"脏读\"><a class=\"markdownIt-Anchor\" href=\"#脏读\"></a> 脏读</h3>\n<p>一个事务读取了另一个事务未提交的数据</p>\n<h3 id=\"不可重复读\"><a class=\"markdownIt-Anchor\" href=\"#不可重复读\"></a> 不可重复读</h3>\n<p>在一个事务内读取表中的某一行数据，多次读取结果不同</p>\n<blockquote>\n<p>这个不一定是错误，只是场合不对</p>\n</blockquote>\n<h3 id=\"幻读虚读\"><a class=\"markdownIt-Anchor\" href=\"#幻读虚读\"></a> 幻读（虚读）</h3>\n<p>一个事务内读取到了别的事务插入的数据，导致前后读取不一致</p>\n<blockquote>\n<p>Q: 不可重复读和幻读的区别？</p>\n<p>A: 表面上看，似乎两者都表现为两次读取的结果不一致。但不可重复读的重点在于<code>update</code>和<code>delete</code>,而幻读的重点在于<code>insert</code></p>\n<p>​\t所以说，幻读和不可重复读的最大区别在于 <strong>如何通过锁机制来解决它们产生的问题</strong></p>\n<p>​\t（幻读需要锁表，不可重复读应该只用锁对应的行？）</p>\n</blockquote>\n<h2 id=\"mysql事务操作\"><a class=\"markdownIt-Anchor\" href=\"#mysql事务操作\"></a> MySQL事务操作</h2>\n<ul>\n<li>MySQL是默认开启事务自动提交的</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">set</span> autocommit <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span> \t<span class=\"hljs-comment\">-- 关闭事务自动提交</span><br><span class=\"hljs-keyword\">set</span> autocimmit <span class=\"hljs-operator\">=</span><span class=\"hljs-number\">1</span> \t<span class=\"hljs-comment\">-- 开启</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>手动处理事务的sql编写逻辑</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">start</span> transaction  <span class=\"hljs-comment\">-- 标记一个事务的开始，从这个之后的sql都在同一个事务内</span><br><span class=\"hljs-keyword\">insert</span> xxx<br><span class=\"hljs-keyword\">insert</span> xxx<br><span class=\"hljs-keyword\">commit</span> \t\t<span class=\"hljs-comment\">-- 事务结束，提交，数据持久化。只有提交后，上面的操作才能持久化保存</span><br><br><span class=\"hljs-keyword\">rollback</span> \t<span class=\"hljs-comment\">-- 如果失败实施回滚：回到原来的样子。如果已经commit，那么回滚后还是改变后的结果；但如果还没有commit，回滚后是最初w</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>\n<p><code>savepoint 保存点名</code> ：定义事务处理过程中的保存点</p>\n<p><code>rollback to savepoint 保存点名</code>：回滚的保存点</p>\n<p><code>release savepoint 保存点名</code>：撤销保存点</p>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["MySql基础学习"],"tags":["MySql"]},{"title":"18.索引","url":"/2021/10/01/8.%E7%B4%A2%E5%BC%95/","content":"<h1 id=\"索引\"><a class=\"markdownIt-Anchor\" href=\"#索引\"></a> 索引</h1>\n<h2 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h2>\n<ul>\n<li>MySQL官方对索引的定义：索引是帮助MySQL获取数据的<strong>数据结构</strong></li>\n</ul>\n<h2 id=\"分类\"><a class=\"markdownIt-Anchor\" href=\"#分类\"></a> 分类</h2>\n<h3 id=\"主键索引primary-key\"><a class=\"markdownIt-Anchor\" href=\"#主键索引primary-key\"></a> 主键索引(primary key)</h3>\n<ul>\n<li>主键的列值唯一、不可为空</li>\n<li>唯一的标识，只能有一个列作为主键</li>\n</ul>\n<h3 id=\"唯一索引unique-key\"><a class=\"markdownIt-Anchor\" href=\"#唯一索引unique-key\"></a> 唯一索引(unique key)</h3>\n<ul>\n<li>索引的列值必须唯一，可以为空</li>\n<li>多个列都可以设置为唯一索引</li>\n</ul>\n<blockquote>\n<p>如果是组合索引，则列值的组合必须唯一</p>\n</blockquote>\n<h3 id=\"常规索引keyindex\"><a class=\"markdownIt-Anchor\" href=\"#常规索引keyindex\"></a> 常规索引(key/index)</h3>\n<ul>\n<li>最基本的索引，不具备唯一性，仅加快查询速度。</li>\n</ul>\n<h3 id=\"全文索引fulltext\"><a class=\"markdownIt-Anchor\" href=\"#全文索引fulltext\"></a> 全文索引(FullText)</h3>\n<ul>\n<li>在特定的数据库引擎才有</li>\n<li>快速定位数据</li>\n</ul>\n<blockquote>\n<p>是目前搜索引擎使用的一种关键技术。它能够利用多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能筛选出想要的结果。3.2开始支持全文索引，但无法正确支持中文；5.7.6开始内置ngram全文检索插件，用来支持中文。</p>\n<p>旧版的全文索引只能用在MyISAM数据库引擎的表上，但5.6.24上InnoDB也加入了全文索引。不够只支持char、varchar和text的字段类型。</p>\n</blockquote>\n<p></p>\n<h2 id=\"使用\"><a class=\"markdownIt-Anchor\" href=\"#使用\"></a> 使用</h2>\n<h3 id=\"创建表时给字段增加索引\"><a class=\"markdownIt-Anchor\" href=\"#创建表时给字段增加索引\"></a> 创建表时给字段增加索引</h3>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">primary</span> key xx()<br><span class=\"hljs-keyword\">unique</span> key xx()<br>key xx()<br></code></pre></td></tr></table></figure>\n<h3 id=\"创建完毕后增加索引\"><a class=\"markdownIt-Anchor\" href=\"#创建完毕后增加索引\"></a> 创建完毕后增加索引</h3>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">alter</span> <span class=\"hljs-keyword\">table</span> 表名 <span class=\"hljs-keyword\">add</span> fulltext index 索引名(列名)\t\t<span class=\"hljs-comment\">-- 添加全文索引</span><br><br><span class=\"hljs-comment\">---------------</span><br><span class=\"hljs-keyword\">create</span> 索引类型 <span class=\"hljs-keyword\">on</span> 表名(列名)\t<span class=\"hljs-comment\">--  </span><br></code></pre></td></tr></table></figure>\n<h3 id=\"显示表所有的索引信息\"><a class=\"markdownIt-Anchor\" href=\"#显示表所有的索引信息\"></a> 显示表所有的索引信息</h3>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">show</span> index <span class=\"hljs-keyword\">from</span> 表名\t\t<span class=\"hljs-comment\">-- 显示表中所有索引信息</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"索引原则\"><a class=\"markdownIt-Anchor\" href=\"#索引原则\"></a> 索引原则</h2>\n<ul>\n<li>索引不是越多越好</li>\n<li>不要对经常变动的数据加索引</li>\n<li>小数据量的表不需要加索引</li>\n<li>索引一般加在常用来查询的字段上</li>\n</ul>\n<h2 id=\"explain简介拓展\"><a class=\"markdownIt-Anchor\" href=\"#explain简介拓展\"></a> explain简介（拓展）</h2>\n<p><strong>explain模拟优化器执行SQL语句</strong>，在5.6以及以后的版本中，<code>select update delete insert</code>均可用，从而知道mysql是如何处理sql语句，分析查询语句或者表结构的性能瓶颈。</p>\n<h3 id=\"作用\"><a class=\"markdownIt-Anchor\" href=\"#作用\"></a> 作用</h3>\n<ol>\n<li>表的读取顺序</li>\n<li>数据读取操作的操作类型</li>\n<li>哪些索引可以使用</li>\n<li>哪些索引被实际使用</li>\n<li>表之间的引用</li>\n<li>每张表有多少行被优化器查询</li>\n</ol>\n<h3 id=\"用法\"><a class=\"markdownIt-Anchor\" href=\"#用法\"></a> 用法</h3>\n<p><strong>explain+SQL语句</strong></p>\n<ul>\n<li>执行计划包含的信息：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>信息</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>查询的序号，包含一组数字，表示查询中执行select子句或操作表的顺序</td>\n</tr>\n<tr>\n<td>select_type</td>\n<td>查询类型，主要用于区别普通查询，联合查询，子查询等的复杂查询</td>\n</tr>\n<tr>\n<td>table</td>\n<td>输出的行所引用的表</td>\n</tr>\n<tr>\n<td>type</td>\n<td>显示联结类型，显示查询使用了何种类型，按照从最佳到最坏类型排序</td>\n</tr>\n<tr>\n<td>possible_keys</td>\n<td>指出MySQL能使用哪个索引在该表中找到行</td>\n</tr>\n<tr>\n<td>key</td>\n<td>显示MySQL实际决定使用的键(索引)</td>\n</tr>\n<tr>\n<td>key_len</td>\n<td>表示索引中使用的字节数</td>\n</tr>\n<tr>\n<td>ref</td>\n<td>显示索引的哪一列被使用了，如果有可能是一个常数，哪些列或常量被用于查询索引列上的值</td>\n</tr>\n<tr>\n<td><strong>rows</strong></td>\n<td>根据表统计信息以及索引选用情况，大致估算出找到所需的记录所需要读取的行数</td>\n</tr>\n<tr>\n<td>Extra</td>\n<td>包含不适合在其他列中显示，但是十分重要的额外信息</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>**id：**id相同，执行顺序从上往下；id不同，id值越大，优先级越高，越先执行</p>\n</li>\n<li>\n<p><strong>select_type</strong>：</p>\n<ul>\n<li>simple ——简单的select查询，查询中不包含子查询或者UNION</li>\n<li>primary ——查询中若包含任何复杂的子部分，最外层查询被标记</li>\n<li>subquery——在select或where列表中包含了子查询</li>\n<li>derived——在from列表中包含的子查询被标记为derived（衍生），MySQL会递归执行这些子查询，把结果放到临时表中</li>\n<li>union——如果第二个select出现在UNION之后，则被标记为UNION，如果union包含在from子句的子查询中，外层select被标记为derived</li>\n<li>union result: UNION 的结果</li>\n</ul>\n</li>\n<li>\n<p><strong>type</strong>:</p>\n<ul>\n<li>\n<p>system：表中仅有一行（=系统表）这是const联结类型的一个特例。</p>\n</li>\n<li>\n<p>const：表示通过索引一次就找到，const用于比较primary key或者unique索引。因为只匹配一行数据，所以如果将主键置于where列表中，mysql能将该查询转换为一个常量</p>\n</li>\n<li>\n<p>eq_ref:唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于唯一索引或者主键扫描</p>\n</li>\n<li>\n<p>ref:非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，可能会找多个符合条件的行，属于查找和扫描的混合体</p>\n</li>\n<li>\n<p>range:只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是where语句中出现了between,in等范围的查询。这种范围扫描索引扫描比全表扫描要好，因为它开始于索引的某一个点，而结束另一个点，不用全表扫描</p>\n</li>\n<li>\n<p>index:index 与all区别为index类型只遍历索引树。通常比all快，因为索引文件比数据文件小很多。</p>\n</li>\n<li>\n<p>all：遍历全表以找到匹配的行</p>\n</li>\n</ul>\n<blockquote>\n<p>注意:一般保证查询至少达到range级别，最好能达到ref。\\</p>\n</blockquote>\n</li>\n<li>\n<p><strong>key</strong>: 如果没有选择索引,键是NULL。查询中如果使用覆盖索引，则该索引和查询的select字段重叠。</p>\n</li>\n<li>\n<p><strong>key_length</strong>: 该列计算查询中使用的索引的长度在不损失精度的情况下，长度越短越好。</p>\n<p>​\t\t\t\t\t 如果键是NULL,则长度为NULL。该字段显示为索引字段的最大可能长度，并非实际使用长度。</p>\n</li>\n<li>\n<p><strong>Extra</strong>:</p>\n<ul>\n<li>\n<p>Using filesort：说明mysql会对数据适用一个外部的索引排序。而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成排序操作称为“文件排序”</p>\n</li>\n<li>\n<p>Using temporary: 使用了临时表保存中间结果。mysql在查询结果排序时使用临时表，常见于排序order by和分组查询group by</p>\n</li>\n<li>\n<p>Using index: 表示相应的select操作用使用覆盖索引，避免访问了表的数据行。</p>\n<p>​\t\t\t\t\t如果同时出现using where，表名索引被用来执行索引键值的查找；如果没有同时出现using where，表名索引用来读取数据而非执行查询动作。</p>\n</li>\n<li>\n<p>Using where : 表明使用where过滤</p>\n</li>\n<li>\n<p>using join buffer: 使用了连接缓存</p>\n</li>\n<li>\n<p>impossible where: where子句的值总是false，不能用来获取任何元组</p>\n</li>\n<li>\n<p>select tables optimized away：在没有group by子句的情况下，基于索引优化Min、max操作或者对于MyISAM存储引擎优化count（*），不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化</p>\n</li>\n<li>\n<p>distinct：优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"索引的数据结构扩展\"><a class=\"markdownIt-Anchor\" href=\"#索引的数据结构扩展\"></a> 索引的数据结构（扩展）</h2>\n<p>阅读：<a href=\"https://blog.codinglabs.org/articles/theory-of-mysql-index.html\">https://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>\n","categories":["MySql基础学习"],"tags":["MySql"]},{"title":"Github+Hexo搭建个人博客","url":"/2021/08/05/Github+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":"<h1 id=\"githubhexo搭建个人博客\"><a class=\"markdownIt-Anchor\" href=\"#githubhexo搭建个人博客\"></a> Github+Hexo搭建个人博客</h1>\n<h2 id=\"工具准备\"><a class=\"markdownIt-Anchor\" href=\"#工具准备\"></a> 工具准备</h2>\n<ul>\n<li>\n<p>git安装：直接官网下载即可</p>\n</li>\n<li>\n<p>Node.js安装</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/biehongli/p/12756256.html\">Node的安装与环境变量的配置</a></li>\n</ul>\n</li>\n<li>\n<p>Hexo安装</p>\n<ol>\n<li>\n<p>先创建一个文件夹blog，然后<code>cd</code>到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。</p>\n</li>\n<li>\n<p>输入命令</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"code\"><pre><code class=\"hljs avrasm\">npm install -g hexo-<span class=\"hljs-keyword\">cli</span><br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>用<code>hexo -v</code>查看版本</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"博客初始化\"><a class=\"markdownIt-Anchor\" href=\"#博客初始化\"></a> 博客初始化</h2>\n<ul>\n<li>\n<p>进入之前创建的文件夹blog，这个文件夹下直接右键git bash打开</p>\n</li>\n<li>\n<p>按顺序输入命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\">hexo init<br>hexo generate<br>hexo serve<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>浏览器输入地址 <code>localhost:4000</code>，网页如果成功显示，则说明成功</p>\n</li>\n</ul>\n<h2 id=\"部署博客\"><a class=\"markdownIt-Anchor\" href=\"#部署博客\"></a> 部署博客</h2>\n<ol>\n<li>\n<p>配置博客部署地址</p>\n<ul>\n<li>\n<p>先在Github上创建一个仓库名为<code>&lt;你的用户名&gt;.github.io</code>的仓库</p>\n</li>\n<li>\n<p>打开根目录下的<code>_config.yml</code>文件，找到 Deployment 这个地方，把刚才新建的 Repository 的地址贴过来，然后指定分支为 main 分支</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-comment\"># Deployment</span><br><span class=\"hljs-comment\">## Docs: https://hexo.io/docs/deployment.html</span><br><span class=\"hljs-attr\">deploy:</span><br>  <span class=\"hljs-attr\">type:</span> <span class=\"hljs-string\">git</span><br>  <span class=\"hljs-attr\">repo:</span> &#123;<span class=\"hljs-string\">git</span> <span class=\"hljs-string\">repo</span> <span class=\"hljs-string\">ssh</span> <span class=\"hljs-string\">address</span>&#125;<br>  <span class=\"hljs-attr\">branch:</span> <span class=\"hljs-string\">main</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>安装一个支持 Git 的部署插件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>安装成功之后，执行部署命令。运行成功后，在仓库中就能看到有新文件上传</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\">hexo deploy<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"配置站点信息\"><a class=\"markdownIt-Anchor\" href=\"#配置站点信息\"></a> 配置站点信息</h2>\n<ol>\n<li>\n<p>修改根目录下的 _config.yml 文件，找到 Site 区域，这里面可以配置站点标题 title、副标题 subtitle 等内容、关键字 keywords 等内容</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-comment\"># Site</span><br><span class=\"hljs-attr\">title:</span> <span class=\"hljs-string\">&lt;网站标签页名字&gt;</span><br><span class=\"hljs-attr\">subtitle:</span> <span class=\"hljs-string\">xxxx</span><br><span class=\"hljs-attr\">description:</span><br><span class=\"hljs-attr\">keywords:</span> <span class=\"hljs-string\">&quot;c++ 刷题，xxx&quot;</span><br><span class=\"hljs-attr\">author:</span> <br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>设置一下语言，如果要设置为汉语的话可以将 language 的字段设置为 zh-CN，修改如下</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">language:</span> <span class=\"hljs-string\">zh-CN</span><br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"主题相关配置\"><a class=\"markdownIt-Anchor\" href=\"#主题相关配置\"></a> 主题相关配置</h2>\n<ul>\n<li>\n<p>不同主题配置可以在GitHub上找帮助文档进行设置</p>\n</li>\n<li>\n<p>这里提供一个链接，设置<strong>next主题</strong>教程</p>\n<p><a href=\"https://mp.weixin.qq.com/s/3li0n8REcU1DviwWiEYw_A\">https://mp.weixin.qq.com/s/3li0n8REcU1DviwWiEYw_A</a></p>\n</li>\n</ul>\n<h2 id=\"使用出现的问题\"><a class=\"markdownIt-Anchor\" href=\"#使用出现的问题\"></a> 使用出现的问题</h2>\n<ul>\n<li>\n<p>如何上传带图片的博客？</p>\n<ol>\n<li>修改根目录下<code>_config.yam</code>的配置项<code>post_asset_folder</code>为true</li>\n<li>下载插件<code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></li>\n<li>添加md文件时，同时添加一个同名的文件夹，里面放图片，md里面使用<code>![img](&lt;文件夹名&gt;/图片名)</code>即可</li>\n</ol>\n<ul>\n<li><strong>如果是通过npm镜像下，可能不是最新的，需要修改<code>Blog\\node_modules\\hexo-asset-image\\index.js</code>里面<code>var endPos=link.length-1</code></strong></li>\n</ul>\n</li>\n</ul>\n","categories":["杂项"],"tags":["杂"]},{"title":"LeetCode 1","url":"/2021/07/28/LeetCode%201/","content":"<h1 id=\"leetcode-1\"><a class=\"markdownIt-Anchor\" href=\"#leetcode-1\"></a> LeetCode 1</h1>\n<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h2>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/two-sum/\">https://leetcode-cn.com/problems/two-sum/</a></li>\n<li>给定一个整数数组和一个target,从数组中选择两个相加等于target的值，返回选择的两个的数组下标</li>\n<li>同一个元素不能被重复选,且只会有一个结果</li>\n</ul>\n<h2 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h2>\n<ul>\n<li>\n<p>返回下标，说明不能排序，那么不能使用多指针法；</p>\n</li>\n<li>\n<p>题目只是要求，同一个元素不能被重复选，并没有说最终结果中不能有重复的元素，所以可以使用哈希法或<code>find()</code>函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//方法一 find()函数找，时间复杂度高</span><br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">twoSum</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums, <span class=\"hljs-keyword\">int</span> target)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;nums.<span class=\"hljs-built_in\">size</span>();i++)&#123;<br>        <span class=\"hljs-keyword\">int</span> temp=target-nums[i];<br>        <span class=\"hljs-keyword\">auto</span> index=<span class=\"hljs-built_in\">find</span>(nums.<span class=\"hljs-built_in\">begin</span>(),nums.<span class=\"hljs-built_in\">end</span>(),temp);<br>        <span class=\"hljs-keyword\">int</span> t=index-nums.<span class=\"hljs-built_in\">begin</span>();<br>        <span class=\"hljs-keyword\">if</span>(index!=nums.<span class=\"hljs-built_in\">end</span>()&amp;&amp;t!=i)&#123;\t<span class=\"hljs-comment\">//确保不是同一元素</span><br>            <span class=\"hljs-keyword\">return</span> &#123;i,t&#125;;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>&#125;;<br>\t&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//方法二 哈希法</span><br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">twoSum</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums, <span class=\"hljs-keyword\">int</span> target)</span> </span>&#123;<br>    unordered_map&lt;<span class=\"hljs-keyword\">int</span>,<span class=\"hljs-keyword\">int</span>&gt; mp;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;nums.<span class=\"hljs-built_in\">size</span>();i++)&#123;<br>        mp[nums[i]]=i+<span class=\"hljs-number\">1</span>;    <span class=\"hljs-comment\">//记录索引，这题题目明确说 只有一个答案才可以这样做的</span><br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;nums.<span class=\"hljs-built_in\">size</span>();i++)&#123;<br>        <span class=\"hljs-keyword\">int</span> temp=mp[target-nums[i]];<br>        <span class=\"hljs-keyword\">if</span>(temp!=<span class=\"hljs-number\">0</span>&amp;&amp;temp<span class=\"hljs-number\">-1</span>!=i)&#123;     /<br>            <span class=\"hljs-keyword\">return</span> &#123;i,temp<span class=\"hljs-number\">-1</span>&#125;;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"> <span class=\"hljs-comment\">/*官方题解 哈希</span><br><span class=\"hljs-comment\"> 注意和自己的方法二的不同，方法二是针对此题明确一个答案才可以那样。</span><br><span class=\"hljs-comment\"> 因为法二在记录索引是，相同的nums[i]的值会被覆盖，之会存在一个索引。</span><br><span class=\"hljs-comment\"> 但是，因为只有一个答案，所以如果有相同的值，那么要么是用不到的，要么一定是两个相同值就是最终的答案；否则不可能只有一个解</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">twoSum</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums, <span class=\"hljs-keyword\">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt; hashtable;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; nums.<span class=\"hljs-built_in\">size</span>(); ++i) &#123;<br>            <span class=\"hljs-keyword\">auto</span> it = hashtable.<span class=\"hljs-built_in\">find</span>(target - nums[i]);<br>            <span class=\"hljs-keyword\">if</span> (it != hashtable.<span class=\"hljs-built_in\">end</span>()) &#123;<br>                <span class=\"hljs-keyword\">return</span> &#123;it-&gt;second, i&#125;;<br>            &#125;<br>            hashtable[nums[i]] = i;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> &#123;&#125;;<br>    &#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n","categories":["刷题记录"],"tags":["LeetCode刷题","C++"]},{"title":"9.权限管理和备份","url":"/2021/10/01/9.%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%92%8C%E5%A4%87%E4%BB%BD/","content":"<h1 id=\"权限管理和备份\"><a class=\"markdownIt-Anchor\" href=\"#权限管理和备份\"></a> 权限管理和备份</h1>\n<h2 id=\"用户管理\"><a class=\"markdownIt-Anchor\" href=\"#用户管理\"></a> 用户管理</h2>\n<h3 id=\"sqlyog可视化管理\"><a class=\"markdownIt-Anchor\" href=\"#sqlyog可视化管理\"></a> SQLyog可视化管理</h3>\n<p>略</p>\n<h3 id=\"sql命令操作\"><a class=\"markdownIt-Anchor\" href=\"#sql命令操作\"></a> SQL命令操作</h3>\n<p><strong>用户表：mysql.user</strong></p>\n<p>本质：对表进行操作</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 创建用户</span><br><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">user</span> syy identified <span class=\"hljs-keyword\">by</span> <span class=\"hljs-string\">&#x27;12345&#x27;</span><br><br><span class=\"hljs-comment\">-- 修改用户密码</span><br><span class=\"hljs-keyword\">set</span> password <span class=\"hljs-operator\">=</span> password(<span class=\"hljs-string\">&#x27;111111&#x27;</span>)\t<span class=\"hljs-comment\">-- 低版本可用</span><br><span class=\"hljs-keyword\">alter</span> <span class=\"hljs-keyword\">user</span> <span class=\"hljs-string\">&#x27;root&#x27;</span>@<span class=\"hljs-string\">&#x27;localhost&#x27;</span> identified <span class=\"hljs-keyword\">by</span> <span class=\"hljs-string\">&#x27;111111&#x27;</span>\t<span class=\"hljs-comment\">-- mysql8版本</span><br><br><span class=\"hljs-comment\">-- 重命名</span><br>rename <span class=\"hljs-keyword\">user</span> syy <span class=\"hljs-keyword\">to</span> syy2<br><br><span class=\"hljs-comment\">-- 用户授权  *.* 所有库的所有表</span><br><span class=\"hljs-keyword\">grant</span> [<span class=\"hljs-keyword\">all</span> privileges] <span class=\"hljs-keyword\">on</span> 库.表 <span class=\"hljs-keyword\">to</span> syy2\t<span class=\"hljs-comment\">-- all privileges 不包括 grant权限</span><br><br><span class=\"hljs-comment\">-- 查看权限</span><br><span class=\"hljs-keyword\">show</span> grants <span class=\"hljs-keyword\">for</span> syy2<br><span class=\"hljs-keyword\">show</span> grants <span class=\"hljs-keyword\">for</span> root<span class=\"hljs-variable\">@localhost</span>\t\t<span class=\"hljs-comment\">-- 查看用户权限要加主机</span><br><br><span class=\"hljs-comment\">-- 撤销权限(哪些权限、在哪个库撤销、给谁撤销)</span><br><span class=\"hljs-keyword\">revoke</span> <span class=\"hljs-keyword\">all</span> privileges <span class=\"hljs-keyword\">on</span> <span class=\"hljs-operator\">*</span>.<span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">from</span> syy2<br><br><span class=\"hljs-comment\">-- 删除用户</span><br><span class=\"hljs-keyword\">drop</span> <span class=\"hljs-keyword\">user</span> syy2<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>@</code>后面是用户表host的内容，要和修改的用户名对应才行</li>\n</ul>\n<blockquote>\n<p>host中%，是设置远程连接，运行任何ip访问该账户</p>\n</blockquote>\n<h2 id=\"mysql-备份\"><a class=\"markdownIt-Anchor\" href=\"#mysql-备份\"></a> MySQL 备份</h2>\n<p><strong>为什们要备份？</strong></p>\n<ul>\n<li>保证重要的数据不丢失</li>\n<li>进行数据转移</li>\n</ul>\n<h3 id=\"备份方式\"><a class=\"markdownIt-Anchor\" href=\"#备份方式\"></a> 备份方式</h3>\n<ul>\n<li>\n<p>直接拷贝物理文件，<code>data文件</code></p>\n</li>\n<li>\n<p>在SQLyog这种可视化工具中手动转出</p>\n<ul>\n<li>sql转储，导出一个<code>.sql</code>文件，执行该文件后会生成导出的库和表</li>\n</ul>\n</li>\n<li>\n<p>使用命令行导出</p>\n<ul>\n<li>\n<p><code>mysqldump</code>命令</p>\n<blockquote>\n<p>备份原理是通过协议连接到 <code>MySQL</code> 数据库，将需要备份的数据查询出来，将查询出的数据转换成对应的<code>insert</code> 语句，当我们需要还原这些数据时，只要执行这些 <code>insert</code> 语句，即可将对应的数据还原</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-comment\">-- 基本格式</span><br>mysqldump <span class=\"hljs-operator\">-</span>h[ip] <span class=\"hljs-operator\">-</span>u[用户名] <span class=\"hljs-operator\">-</span>p[密码] <span class=\"hljs-operator\">-</span>P[端口号]  数据库名  表名 <span class=\"hljs-operator\">&gt;</span>导出的文件名.<span class=\"hljs-keyword\">sql</span><br><span class=\"hljs-comment\">-- 导出所有的数据库</span><br>mysqldump <span class=\"hljs-operator\">-</span>uroot <span class=\"hljs-operator\">-</span>p123456 <span class=\"hljs-comment\">--all-databases &gt;D:/all.sql</span><br><br><span class=\"hljs-comment\">-- 导出多个指定表 或 数据库内所有表</span><br>mysqldump <span class=\"hljs-operator\">-</span>uroot <span class=\"hljs-operator\">-</span>p123456 school student class <span class=\"hljs-operator\">&gt;</span>D:<span class=\"hljs-operator\">/</span>a.sql<br>mysqldump <span class=\"hljs-operator\">-</span>uroot <span class=\"hljs-operator\">-</span>p123456 school <span class=\"hljs-operator\">&gt;</span>D:<span class=\"hljs-operator\">/</span>b.sql<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>导入</strong></p>\n<p>先在命令行中登录MySQL</p>\n<blockquote>\n<p>如果是导入一张表，需要切换到对应需要导入的数据库；</p>\n<p>如果是导入一个数据库，则不用</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><code class=\"hljs sql\">source d:<span class=\"hljs-operator\">/</span>all.sql<br></code></pre></td></tr></table></figure>\n","categories":["MySql基础学习"],"tags":["MySql"]},{"title":"LeetCode 1047","url":"/2021/07/28/LeetCode%201047/","content":"<h1 id=\"leetcode-1047\"><a class=\"markdownIt-Anchor\" href=\"#leetcode-1047\"></a> LeetCode 1047</h1>\n<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h2>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/\">https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/</a></li>\n<li>从string中删除所有相邻且相同的字符，删除后继续重复操作</li>\n</ul>\n<h2 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h2>\n<ul>\n<li>\n<p>想当于两个元素的匹配问题，考虑用栈</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">removeDuplicates</span><span class=\"hljs-params\">(string s)</span> </span>&#123;<br>        stack&lt;<span class=\"hljs-keyword\">char</span>&gt; sk;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;s[i];i++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(!sk.<span class=\"hljs-built_in\">empty</span>()&amp;&amp;sk.<span class=\"hljs-built_in\">top</span>()==s[i])  sk.<span class=\"hljs-built_in\">pop</span>();\t\t<span class=\"hljs-comment\">//这里要加非空判断，因为后续也可能出现栈为空的情况</span><br>            <span class=\"hljs-keyword\">else</span> sk.<span class=\"hljs-built_in\">push</span>(s[i]);<br>        &#125;<br>        string p=<span class=\"hljs-string\">&quot;&quot;</span>;<br>        <span class=\"hljs-keyword\">while</span>(!sk.<span class=\"hljs-built_in\">empty</span>())&#123;<br>            p+=sk.<span class=\"hljs-built_in\">top</span>();<br>            sk.<span class=\"hljs-built_in\">pop</span>();<br>        &#125;<br>        <span class=\"hljs-built_in\">reverse</span>(p.<span class=\"hljs-built_in\">begin</span>(),p.<span class=\"hljs-built_in\">end</span>());<br>        <span class=\"hljs-keyword\">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n","categories":["刷题记录"],"tags":["LeetCode刷题","C++"]},{"title":"LeetCode 142","url":"/2021/07/28/LeetCode%20142/","content":"<h1 id=\"leetcode-142\"><a class=\"markdownIt-Anchor\" href=\"#leetcode-142\"></a> LeetCode 142</h1>\n<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h2>\n<ul>\n<li>在一个链表中，确定是否有环。如果有，确定环的起始结点位置</li>\n</ul>\n<h2 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h2>\n<ul>\n<li>\n<p>确定有环：快慢指针法</p>\n</li>\n<li>\n<p>确定环起始位置：<img src=\"/2021/07/28/LeetCode%20142/%5C%E6%89%80%E6%9C%89%E5%9B%BE%E7%89%87%5C%E7%8E%AF.png\" alt=\"环\"></p>\n<figure class=\"highlight excel\"><table><tr><td class=\"code\"><pre><code class=\"hljs excel\">(x+y)*<span class=\"hljs-number\">2</span>=(x+y)+<span class=\"hljs-built_in\">n</span>(<span class=\"hljs-comment\">y+z</span>)\t//这里<span class=\"hljs-built_in\">n</span>(<span class=\"hljs-comment\">y+z</span>)是快指针多走的<br>x=<span class=\"hljs-built_in\">n</span>(<span class=\"hljs-comment\">y+z</span>)-y=(<span class=\"hljs-built_in\">n</span>-<span class=\"hljs-number\">1</span>)(y+z)+z\t//x是我们要求的<br>注意到（<span class=\"hljs-built_in\">n</span>-<span class=\"hljs-number\">1</span>)(y+z)是环的长度，z、x分别拿出来看就可知道如何找到入口<br></code></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">ListNode *<span class=\"hljs-title\">detectCycle</span><span class=\"hljs-params\">(ListNode *head)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(head==<span class=\"hljs-literal\">NULL</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>        ListNode* slow=head;<br>        ListNode* fast=head;<br>        <span class=\"hljs-keyword\">int</span> flag=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">while</span>(fast != <span class=\"hljs-literal\">NULL</span> &amp;&amp; fast-&gt;next != <span class=\"hljs-literal\">NULL</span>)&#123;\t<span class=\"hljs-comment\">//注意判断</span><br>            slow=slow-&gt;next;\t<span class=\"hljs-comment\">//慢指针</span><br>            fast=fast-&gt;next-&gt;next;\t<span class=\"hljs-comment\">//快指针</span><br>            <span class=\"hljs-keyword\">if</span>(slow==fast)&#123; <span class=\"hljs-comment\">//有环</span><br>                flag=<span class=\"hljs-number\">1</span>;<br>                <span class=\"hljs-keyword\">break</span>;<br>            &#125;    <br>        &#125;<br>        <span class=\"hljs-comment\">//这部分，可以直接放在前面的if里面的</span><br>        <span class=\"hljs-keyword\">if</span>(flag==<span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>        ListNode* temp=head;<br>        <span class=\"hljs-keyword\">while</span>(temp!=fast)&#123;<br>            fast=fast-&gt;next;<br>            temp=temp-&gt;next;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> temp;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n","categories":["刷题记录"],"tags":["LeetCode刷题","C++"]},{"title":"LeetCode 15","url":"/2021/07/28/LeetCode%2015/","content":"<h1 id=\"leetcode-15\"><a class=\"markdownIt-Anchor\" href=\"#leetcode-15\"></a> LeetCode 15</h1>\n<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h2>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/3sum\">https://leetcode-cn.com/problems/3sum</a></li>\n<li>从一个数组中，找到所有的三个不同位置的数字，相加等于0</li>\n<li>返回所有的相加等于0的三个数字，且结果不重复</li>\n</ul>\n<h2 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h2>\n<ul>\n<li>\n<p>理解题目要求，三个数字位置要不同,三个数字组成的结果不重复，最后按组返回所有的三个数字</p>\n</li>\n<li>\n<p>返回最终集合不能重复，所以这题不好用哈希法，因为哈希会把所有的结果都选出来，那么就可能三个数字组成的集合是重复的</p>\n<p>所以，考虑多指针法，而正好题目只需我们返回最终的值，那么可以将数据排序</p>\n</li>\n<li>\n<p>如何确定指针数？</p>\n<ul>\n<li>首页一个排好序的数组，指针的移动方向就两个——前、后，所以移动指针可以有两个</li>\n<li>这题要求选三个，所以我们当然要选三个指针指向最终的结果</li>\n</ul>\n</li>\n<li>\n<p>如何去重？</p>\n<ul>\n<li>\n<p>因为排好序，所以相同的数据都集中在一起，只需判断此时的数据和之前的数据是否相同</p>\n<p>如果相同，则不处理该数据；</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    vector&lt;vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt; <span class=\"hljs-built_in\">threeSum</span>(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt; result;<br>        <span class=\"hljs-built_in\">sort</span>(nums.<span class=\"hljs-built_in\">begin</span>(),nums.<span class=\"hljs-built_in\">end</span>());\t<span class=\"hljs-comment\">//排序</span><br>        <span class=\"hljs-keyword\">int</span> L=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;L;i++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(nums[i]&gt;<span class=\"hljs-number\">0</span>)\t<span class=\"hljs-comment\">//剪枝</span><br>                <span class=\"hljs-keyword\">break</span>;<br>            <span class=\"hljs-keyword\">int</span> j=i+<span class=\"hljs-number\">1</span>;<br>            <span class=\"hljs-keyword\">int</span> k=L<span class=\"hljs-number\">-1</span>;<br>            <span class=\"hljs-keyword\">if</span>(i&gt;<span class=\"hljs-number\">0</span>&amp;&amp;nums[i]==nums[i<span class=\"hljs-number\">-1</span>]) <span class=\"hljs-keyword\">continue</span>;\t<span class=\"hljs-comment\">//去重</span><br>            <span class=\"hljs-keyword\">while</span>(k&gt;j)&#123;<br>                <span class=\"hljs-keyword\">if</span>(nums[i] + nums[j] + nums[k]&gt;<span class=\"hljs-number\">0</span>)\t<span class=\"hljs-comment\">//移动指针</span><br>\t\t\t\t\tk--;<br>\t\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(nums[i] + nums[j] + nums[k]&lt;<span class=\"hljs-number\">0</span>)<br>\t\t\t\t\tj++;<br>\t\t\t\t<span class=\"hljs-keyword\">else</span>&#123;<br>\t\t\t\t\tresult.<span class=\"hljs-built_in\">push_back</span>(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&#123;nums[i], nums[j], nums[k]&#125;);\t<span class=\"hljs-comment\">//获得结果</span><br>\t\t\t\t\t<span class=\"hljs-keyword\">while</span>(nums[k]==nums[k<span class=\"hljs-number\">-1</span>]&amp;&amp;k&gt;j)   k--;\t<span class=\"hljs-comment\">//去重</span><br>                    <span class=\"hljs-keyword\">while</span>(nums[j]==nums[j+<span class=\"hljs-number\">1</span>]&amp;&amp;k&gt;j)   j++;<br>\t\t\t\t\t<span class=\"hljs-comment\">//继续寻找</span><br>                    j++;<br>                    k--;<br>\t\t\t\t&#125;<br>            &#125;<br><br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n","categories":["刷题记录"],"tags":["LeetCode刷题","C++"]},{"title":"LeetCode 18","url":"/2021/07/28/LeetCode%2018/","content":"<h1 id=\"leetcode-18\"><a class=\"markdownIt-Anchor\" href=\"#leetcode-18\"></a> LeetCode 18</h1>\n<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h2>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/4sum/\">https://leetcode-cn.com/problems/4sum/</a></li>\n<li>给你一个数组和一个目标值target，判断数组中是否能找到四个不同位置的值相加等于target</li>\n<li>答案中不包含重复的集合</li>\n</ul>\n<h2 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h2>\n<ul>\n<li>\n<p>和之前[3Sum](LeetCode <a href=\"http://15.md\">15.md</a>)基本相同，只是需要四个数字</p>\n</li>\n<li>\n<p>指针数：2个活动指针+2个固定移动指针</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    vector&lt;vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt; <span class=\"hljs-built_in\">fourSum</span>(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums, <span class=\"hljs-keyword\">int</span> target) &#123;<br>        vector&lt;vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt; result;<br>        <span class=\"hljs-built_in\">sort</span>(nums.<span class=\"hljs-built_in\">begin</span>(),nums.<span class=\"hljs-built_in\">end</span>());<br>        <span class=\"hljs-keyword\">int</span> L=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;L;i++)&#123;<br>            <span class=\"hljs-comment\">//if(nums[i]&gt;target)  continue;\t这个剪枝是错误的</span><br>            <span class=\"hljs-keyword\">if</span>(i&gt;<span class=\"hljs-number\">0</span>&amp;&amp;nums[i]==nums[i<span class=\"hljs-number\">-1</span>]) <span class=\"hljs-keyword\">continue</span>;\t<span class=\"hljs-comment\">//相同的去重操作</span><br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=i+<span class=\"hljs-number\">1</span>;j&lt;L;j++)&#123;\t\t\t<span class=\"hljs-comment\">//两个固定指针，两重循环</span><br>                <span class=\"hljs-keyword\">if</span>(j&gt;i+<span class=\"hljs-number\">1</span>&amp;&amp;nums[j]==nums[j<span class=\"hljs-number\">-1</span>]) <span class=\"hljs-keyword\">continue</span>;\t\t<span class=\"hljs-comment\">//注意一下第二重循环的去重条件</span><br>                <span class=\"hljs-keyword\">int</span> left=j+<span class=\"hljs-number\">1</span>;<br>                <span class=\"hljs-keyword\">int</span> right=L<span class=\"hljs-number\">-1</span>;<br>                <span class=\"hljs-keyword\">while</span>(right&gt;left)&#123;<br>                    <span class=\"hljs-keyword\">if</span>((<span class=\"hljs-keyword\">long</span> <span class=\"hljs-keyword\">long</span> )nums[i]+nums[j]+nums[left]+nums[right]&gt;target)\t<span class=\"hljs-comment\">//这里的类型v</span><br>                        right--;<br>                    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>((<span class=\"hljs-keyword\">long</span> <span class=\"hljs-keyword\">long</span> )nums[i]+nums[j]+nums[left]+nums[right]&lt;target)<br>                        left++;<br>                    <span class=\"hljs-keyword\">else</span>&#123;<br>                        result.<span class=\"hljs-built_in\">push_back</span>(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&#123;nums[i], nums[j], nums[left],nums[right]&#125;);<br>                        <span class=\"hljs-keyword\">while</span>(nums[right]==nums[right<span class=\"hljs-number\">-1</span>]&amp;&amp;right&gt;left) right--;<br>                        <span class=\"hljs-keyword\">while</span>(nums[left]==nums[left+<span class=\"hljs-number\">1</span>]&amp;&amp;right&gt;left) left++;<br>                        right--;<br>                        left++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>​</p>\n</li>\n</ul>\n<p>​</p>\n","categories":["刷题记录"],"tags":["LeetCode刷题","C++"]},{"title":"LeetCode 19","url":"/2021/07/28/LeetCode%2019/","content":"<h1 id=\"leetcode-19\"><a class=\"markdownIt-Anchor\" href=\"#leetcode-19\"></a> LeetCode 19</h1>\n<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h2>\n<h2 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h2>\n","categories":["刷题记录"],"tags":["LeetCode刷题","C++"]},{"title":"LeetCode 239","url":"/2021/07/28/LeetCode%20239/","content":"<h1 id=\"leetcode-239\"><a class=\"markdownIt-Anchor\" href=\"#leetcode-239\"></a> LeetCode 239</h1>\n<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h2>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/sliding-window-maximum/\">https://leetcode-cn.com/problems/sliding-window-maximum/</a></li>\n<li>给定一个整形数组，固定滑动窗口长度，窗口从左到右每次滑动一个元素，返回每次窗口的最大值</li>\n</ul>\n<h2 id=\"思路1\"><a class=\"markdownIt-Anchor\" href=\"#思路1\"></a> 思路1</h2>\n<ul>\n<li>\n<p>滑动窗口的模拟，容易想到使用队列</p>\n</li>\n<li>\n<p>难点是如何找到每次窗口的最大值，如果在次窗口中暴力求解，O（N^2）会超时。考虑最好在每次窗口滑动时，就能确定最大值。</p>\n</li>\n<li>\n<p>找最大值需要比较排序，考虑<mark>优先队列</mark>可以确保每次最大值都在窗口的第一个。问题又来了，因为排序后数字的位置改变，每次移出窗口的数不一定是优先队列中最左边的数，如何来确认呢？</p>\n</li>\n<li>\n<p>因为我们只需要找到每次的最大值，<strong>不需要关心队列里到底有哪些数字</strong>。而最大值永远在优先队列的最左边，我们只需判断每次移动后，该最大值是否被移出队列即可。</p>\n<p>每次移出窗口的数组下标是确定的，所以我们可以同时保存值和下标，这样就算排序后数组位置改变，我们还是可以确定是否目前的最大值是否被移出。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">maxSlidingWindow</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums, <span class=\"hljs-keyword\">int</span> k)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br>        priority_queue&lt;pair&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt; &gt; q;\t\t<span class=\"hljs-comment\">//同时保存值和下标</span><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; k; ++i) &#123;<br>            q.<span class=\"hljs-built_in\">emplace</span>(nums[i], i);\t<br>        &#125;<br>        vector&lt;<span class=\"hljs-keyword\">int</span>&gt; ans = &#123;q.<span class=\"hljs-built_in\">top</span>().first&#125;;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = k; i &lt; n; ++i) &#123;<br>            q.<span class=\"hljs-built_in\">emplace</span>(nums[i], i);<br>            <span class=\"hljs-keyword\">while</span> (q.<span class=\"hljs-built_in\">top</span>().second &lt;= i - k) &#123;\t<span class=\"hljs-comment\">//i-k之前的数都是应该被移出的</span><br>                q.<span class=\"hljs-built_in\">pop</span>();<br>            &#125;<br>            ans.<span class=\"hljs-built_in\">push_back</span>(q.<span class=\"hljs-built_in\">top</span>().first);<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> ans;<br>    &#125;<br>&#125;;<br><span class=\"hljs-comment\">//时间：O(nlogn) \t空间：O(n)</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"思路2\"><a class=\"markdownIt-Anchor\" href=\"#思路2\"></a> 思路2</h2>\n<ul>\n<li>\n<p><strong>其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了</strong></p>\n<ul>\n<li>如果当前的滑动窗口中有两个下标 i 和 j，其中 i 在 j 的左侧（i &lt; j），并且 i 对应的元素不大于 j 对应的元素（nums[i]≤nums[j]）</li>\n<li>当窗口右移时，如果 i 还在窗口，j 一定在窗口，且此时最大值不可能是nums[i]</li>\n<li>按照上述分析，所有num[i]就可以不用保存在队列中了</li>\n</ul>\n</li>\n<li></li>\n</ul>\n  <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">maxSlidingWindow</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums, <span class=\"hljs-keyword\">int</span> k)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br>        vector&lt;<span class=\"hljs-keyword\">int</span>&gt; result;<br>        deque&lt;<span class=\"hljs-keyword\">int</span>&gt; dq;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;k;i++)&#123;<br>            <span class=\"hljs-keyword\">while</span>(!dq.<span class=\"hljs-built_in\">empty</span>()&amp;&amp;nums[i]&gt;dq.<span class=\"hljs-built_in\">back</span>())&#123;\t<span class=\"hljs-comment\">//按上述分析 保存特定顺序下的窗口元素</span><br>                dq.<span class=\"hljs-built_in\">pop_back</span>();<br>            &#125;<br>            dq.<span class=\"hljs-built_in\">emplace_back</span>(nums[i]);<br>        &#125;<br>       result.<span class=\"hljs-built_in\">push_back</span>(dq.<span class=\"hljs-built_in\">front</span>());\t<span class=\"hljs-comment\">//第一个窗口的最大值</span><br>       <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=k;i&lt;n;i++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(!dq.<span class=\"hljs-built_in\">empty</span>()&amp;&amp;nums[i-k]==dq.<span class=\"hljs-built_in\">front</span>())\t<span class=\"hljs-comment\">//num[i-k]是窗口该移出的元素，判断是否等于队列最前面的值，如果相等则表示其会被移出窗口</span><br>            dq.<span class=\"hljs-built_in\">pop_front</span>();\t\t\twhy???<br>        <span class=\"hljs-keyword\">while</span>(!dq.<span class=\"hljs-built_in\">empty</span>()&amp;&amp;nums[i]&gt;dq.<span class=\"hljs-built_in\">back</span>())\t<span class=\"hljs-comment\">//只要添加数字进窗口都进行该操作</span><br>            dq.<span class=\"hljs-built_in\">pop_back</span>();<br>            dq.<span class=\"hljs-built_in\">emplace_back</span>(nums[i]);<br>        result.<span class=\"hljs-built_in\">emplace_back</span>(dq.<span class=\"hljs-built_in\">front</span>());    <span class=\"hljs-comment\">//每次移动完后，队列最前面的值，就是此时窗口的最大值  why??</span><br>       &#125;<br>       <span class=\"hljs-keyword\">return</span> result;<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure>\n<ul>\n<li><mark>有两处问题需要考虑</mark></li>\n</ul>\n","categories":["刷题记录"],"tags":["LeetCode刷题","C++"]},{"title":"LeetCode 69","url":"/2021/07/28/LeetCode%2069/","content":"<h1 id=\"leetcode-69\"><a class=\"markdownIt-Anchor\" href=\"#leetcode-69\"></a> LeetCode 69</h1>\n<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h2>\n<p>​\t模拟sqrt函数实现</p>\n<h2 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h2>\n<ul>\n<li>\n<p>对于一个整数的平方根，除了几个特殊情况，可以验证&lt;=x/2。这里强调是整数，所以2,3仍然符合，而0,1则要特殊处理。</p>\n</li>\n<li>\n<p>使用二分法，while循环中的if条件要注意，如果mid*mid&gt;x,那么结果在mid之后；反正则不一定</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">mySqrt</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">if</span>(x==<span class=\"hljs-number\">0</span>)\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">if</span>(x==<span class=\"hljs-number\">1</span>)\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">int</span> start=<span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">int</span> end=x/<span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">int</span> ans=<span class=\"hljs-number\">-1</span>;<br>    <span class=\"hljs-keyword\">while</span>(end&gt;=start)&#123;\t<br>        <span class=\"hljs-keyword\">int</span> mid=start+(end-start)/<span class=\"hljs-number\">2</span>;<br>        <span class=\"hljs-keyword\">if</span>((<span class=\"hljs-keyword\">long</span> <span class=\"hljs-keyword\">long</span>)mid*mid&gt;x)\t<span class=\"hljs-comment\">//比x大，那么一定在前面</span><br>            end=mid<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-keyword\">else</span>&#123;\t<span class=\"hljs-comment\">//&lt;=x，不一定先记录下来</span><br>            ans=mid;\t<span class=\"hljs-comment\">//可能的结果先保存下来，所以end可以等于start</span><br>            start=mid+<span class=\"hljs-number\">1</span>;\t<span class=\"hljs-comment\">//继续二分</span><br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> ans;<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>如果不用x/2,那么就不需要特殊情况单独处理</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">mySqrt</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> start=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">int</span> end=x;\t<span class=\"hljs-comment\">//v</span><br>    <span class=\"hljs-keyword\">int</span> ans=<span class=\"hljs-number\">-1</span>;<br>    <span class=\"hljs-keyword\">while</span>(end&gt;=start)&#123;<br>        <span class=\"hljs-keyword\">int</span> mid=start+(end-start)/<span class=\"hljs-number\">2</span>;<br>        <span class=\"hljs-keyword\">if</span>((<span class=\"hljs-keyword\">long</span> <span class=\"hljs-keyword\">long</span>)mid*mid&gt;x)<br>            end=mid<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-keyword\">else</span>&#123;<br>            ans=mid;<br>            start=mid+<span class=\"hljs-number\">1</span>;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> ans;<br> &#125;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n","categories":["刷题记录"],"tags":["LeetCode刷题","C++"]},{"title":"LeetCode 454","url":"/2021/07/28/LeetCode%20454/","content":"<h1 id=\"leetcode-454\"><a class=\"markdownIt-Anchor\" href=\"#leetcode-454\"></a> LeetCode 454</h1>\n<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h2>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/4sum-ii/\">https://leetcode-cn.com/problems/4sum-ii/</a></li>\n<li>给定四个数组，从四个数组中各选一个，相加等于0</li>\n<li>返回可选的组合的个数</li>\n</ul>\n<h2 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h2>\n<ul>\n<li>\n<p>四个不同的数组中选，所以是各自独立的</p>\n</li>\n<li>\n<p>返回可选的组合的个数，只需进行记录即可</p>\n</li>\n<li>\n<p>综上，可以使用哈希法。考虑到四个数组，如果暴力求解大概率是超时，所以我们将两个数组的组合情况保存起来，再循环解决</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">fourSumCount</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums1, vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums2, vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums3, vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums4)</span> </span>&#123;<br>        unordered_map&lt;<span class=\"hljs-keyword\">int</span>,<span class=\"hljs-keyword\">int</span>&gt; mp1;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> a:nums1)&#123;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> b:nums2)&#123;<br>                mp1[a+b]++;\t\t<span class=\"hljs-comment\">//先记录两个数组的所有情况，因为最终结果只要数量，所以只要记录可以组合的值的数量即可</span><br>            &#125;<br>        &#125;<br>       <span class=\"hljs-comment\">// unordered_map&lt;int,int&gt; mp2;</span><br>       <span class=\"hljs-keyword\">int</span> count=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> a:nums3)&#123;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> b:nums4)&#123;\t<span class=\"hljs-comment\">//另外两个数组排列组合</span><br>                <span class=\"hljs-keyword\">if</span>(mp1.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-number\">0</span>-(a+b))!=mp1.<span class=\"hljs-built_in\">end</span>())&#123;\t<span class=\"hljs-comment\">//找期望有的值\t</span><br>                    count+=mp1[<span class=\"hljs-number\">0</span>-(a+b)];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> count;<br> <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n","categories":["刷题记录"],"tags":["LeetCode刷题","C++"]},{"title":"LeetCode 34","url":"/2021/07/28/LeetCode%2034/","content":"<h1 id=\"leetcode-34\"><a class=\"markdownIt-Anchor\" href=\"#leetcode-34\"></a> LeetCode 34</h1>\n<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h2>\n<p>​\t题目给定一个升序数组，又要求时间复杂度O(log n)算法，考虑<mark>二分</mark>解决</p>\n<h2 id=\"思路1\"><a class=\"markdownIt-Anchor\" href=\"#思路1\"></a> 思路1</h2>\n<ul>\n<li>\n<p>一般二分查找，只能找到其中一个target，现在要找target在数组中的开始位置和终止位置，考虑每次找到后将数组分成左右两个，那么开始、终止位置也就可能在左右两边。</p>\n</li>\n<li>\n<p>对左右两边，可以继续二分查找，直到找不到停止。到这里，考虑<mark>递归</mark>思想。</p>\n</li>\n<li>\n<p>对于递归函数，<strong>返回值应该就是最终的结果</strong>，还要注意临界条件。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>     <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">find</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums,<span class=\"hljs-keyword\">int</span> target,<span class=\"hljs-keyword\">int</span> l,<span class=\"hljs-keyword\">int</span> r)</span></span>&#123;\t<span class=\"hljs-comment\">//这里l,r就是用来记录最终结果用</span><br>         <span class=\"hljs-keyword\">while</span>(r&gt;=l)&#123;  <br>         \t<span class=\"hljs-keyword\">int</span> mid=(l+r)/<span class=\"hljs-number\">2</span>;<br>            <span class=\"hljs-keyword\">if</span>(nums[mid]&gt;target)<br>                r=mid<span class=\"hljs-number\">-1</span>;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(nums[mid]&lt;target)<br>                l=mid+<span class=\"hljs-number\">1</span>;<br>            <span class=\"hljs-keyword\">else</span>&#123;\t<span class=\"hljs-comment\">//找到一个边界target</span><br>                <span class=\"hljs-keyword\">if</span>(nums[l]!=target)\t<span class=\"hljs-comment\">//如果最左边不等于target</span><br>                    l=<span class=\"hljs-built_in\">find</span>(nums,target,l+<span class=\"hljs-number\">1</span>,mid)[<span class=\"hljs-number\">0</span>];\t<span class=\"hljs-comment\">//左边往后移动，只取数组第一个结果</span><br>                <span class=\"hljs-keyword\">if</span>(nums[r]!=target)\t<span class=\"hljs-comment\">//如果最右边不等于target</span><br>                    r=<span class=\"hljs-built_in\">find</span>(nums,target,mid,r<span class=\"hljs-number\">-1</span>)[<span class=\"hljs-number\">1</span>];\t<span class=\"hljs-comment\">//右边后前移动</span><br>                <span class=\"hljs-keyword\">return</span> vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&#123;l,r&#125;;<br>            &#125;<br>        &#125;<br>         <span class=\"hljs-comment\">//如果找不到 </span><br>        <span class=\"hljs-keyword\">return</span>  vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&#123;<span class=\"hljs-number\">-1</span>,<span class=\"hljs-number\">-1</span>&#125;;<br>    &#125;<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">searchRange</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums, <span class=\"hljs-keyword\">int</span> target)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">find</span>(nums,target,<span class=\"hljs-number\">0</span>,nums.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"思路二\"><a class=\"markdownIt-Anchor\" href=\"#思路二\"></a> 思路二</h2>\n<ul>\n<li>考虑到传入的是vector<int>类型，而c++STL中存在一个<mark>二分查找</mark>的算法<code>equal_range</code>,可以使用该函数</int></li>\n<li><mark>equal_range</mark>：试图在已排序的[first,last)中寻找value，它返回一对迭代器i和j，其中i是在不破坏次序的前提下，<strong>value可插入的第一个位置（亦即lower_bound）</strong>，j则是在不破坏次序的前提下，<strong>value可插入的最后一个位置（亦即upper_bound）</strong></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">searchRange</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums, <span class=\"hljs-keyword\">int</span> target)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">auto</span> bound=<span class=\"hljs-built_in\">equal_range</span>(nums.<span class=\"hljs-built_in\">begin</span>(),nums.<span class=\"hljs-built_in\">end</span>(),target);<br>        <span class=\"hljs-keyword\">if</span>(bound.first==bound.second)   <span class=\"hljs-keyword\">return</span> &#123;<span class=\"hljs-number\">-1</span>,<span class=\"hljs-number\">-1</span>&#125;;\t<span class=\"hljs-comment\">//两个迭代器 first second</span><br>        <span class=\"hljs-keyword\">return</span> &#123;(<span class=\"hljs-keyword\">int</span>)(bound.first-nums.<span class=\"hljs-built_in\">begin</span>()),(<span class=\"hljs-keyword\">int</span>)(bound.second-nums.<span class=\"hljs-built_in\">begin</span>())<span class=\"hljs-number\">-1</span>&#125;;\t<span class=\"hljs-comment\">//通过迭代器相减 q</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n","categories":["刷题记录"],"tags":["LeetCode刷题","C++"]},{"title":"LeetCode 76","url":"/2021/07/28/LeetCode%2076/","content":"<h1 id=\"leetcode-76\"><a class=\"markdownIt-Anchor\" href=\"#leetcode-76\"></a> LeetCode 76</h1>\n<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h2>\n<p>​\t题目要求在一个字符串中找到包含另一个字符串所有字符（包括重复字符）的最短子序列</p>\n<h2 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h2>\n<ul>\n<li>\n<p>子序列问题，考虑<mark>滑动窗口</mark>思想</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">string <span class=\"hljs-title\">minWindow</span><span class=\"hljs-params\">(string s, string t)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> l1=s.<span class=\"hljs-built_in\">length</span>(),l2=t.<span class=\"hljs-built_in\">length</span>();  <span class=\"hljs-comment\">//获得字符串长度</span><br>    \t<span class=\"hljs-comment\">//做准备，能想d</span><br>        <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">mp</span><span class=\"hljs-params\">(<span class=\"hljs-number\">128</span>,<span class=\"hljs-number\">0</span>)</span></span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;t.<span class=\"hljs-built_in\">length</span>();j++)<br>        \tmp[t[j]]++;<br>\t\t<span class=\"hljs-keyword\">int</span> kind=l2;<br><br>        <span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;\t<br>    \t<span class=\"hljs-comment\">//保存每次结果和最终结果</span><br>        <span class=\"hljs-keyword\">int</span> result=INT_MAX;<br>\t\tstring str=<span class=\"hljs-string\">&quot;&quot;</span>;<br>\t\tstring str2=<span class=\"hljs-string\">&quot;&quot;</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;l1;j++)&#123;<br>            <span class=\"hljs-comment\">//窗口滑动操作</span><br>        \tstr+=s[j];\t<span class=\"hljs-comment\">//记录窗口目前数据</span><br>\t\t\t<span class=\"hljs-keyword\">if</span>(mp[s[j]]&gt;<span class=\"hljs-number\">0</span>)&#123;\t\t<span class=\"hljs-comment\">//窗口滑动对之后操作影响的记录</span><br>\t\t\t\tkind--;<br>\t\t\t&#125;<br>\t\t\tmp[s[j]]--;<br>\t\t\t <br>            <span class=\"hljs-keyword\">while</span>(kind==<span class=\"hljs-number\">0</span>)&#123;\t\t<span class=\"hljs-comment\">//临界情况</span><br>            \t<br>\t\t\t\t<span class=\"hljs-keyword\">int</span> ans=j-i+<span class=\"hljs-number\">1</span>;<br>\t\t\t\tstr2=result&gt;ans?str:str2;<br>\t\t\t\tresult=result&gt;ans?ans:result;<br>                <span class=\"hljs-comment\">//窗口起始位置向前滑动对记录的影响</span><br>\t\t\t\tmp[s[i]]++;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(mp[s[i]]&gt;<span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t\tkind++;<br>\t\t\t\t&#125;<br>\t\t\t\tstr.<span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>);<br>\t\t\t\ti++;<br>\t\t\t\t<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> str2;<br>    &#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p>对于此题，也可以不用每次记录窗口中的字符串，因为最后可以得到最终窗口的起始、终止位置。</p>\n</li>\n<li>\n<p>对于此题，还可优化，窗口起始位置可以不用每次只滑动一次，可以直接将窗口前面和目标字符串无关的位置全部移动后再做进一步判断</p>\n</li>\n</ul>\n","categories":["刷题记录"],"tags":["LeetCode刷题","C++"]},{"title":"LeetCode 59","url":"/2021/07/28/LeetCode%2059/","content":"<h1 id=\"leetcode-59\"><a class=\"markdownIt-Anchor\" href=\"#leetcode-59\"></a> LeetCode 59</h1>\n<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h2>\n<p>​\t输入n，在n*n的矩阵中，从左上角开始，逆时针填入数字1-n<sup>2</sup>,然后输出矩阵</p>\n<h2 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h2>\n<ul>\n<li>\n<p>首页，应该能知道这题是一个模拟题</p>\n</li>\n<li>\n<p>手动模拟操作，可以发现，顺序上-右-下-左都是一样的，只是规模再变小。所以一次大循环里面，应该是把四个方向的任务完成。</p>\n</li>\n<li>\n<p>还要注意的是边界的选取，因为上-右、右-下、下-左，均是存在一个重叠的数字的。这里选择左闭右开，是因为每次处理一个方向后，循环变量还会加一，</p>\n<p>所以干脆直接将加一利用起来，再之后的方向继续使用，减少操作</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\">vector&lt;vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt; <span class=\"hljs-built_in\">generateMatrix</span>(<span class=\"hljs-keyword\">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class=\"hljs-keyword\">int</span>&gt; &gt; <span class=\"hljs-built_in\">result</span>(n, vector&lt;<span class=\"hljs-keyword\">int</span>&gt;(n, <span class=\"hljs-number\">0</span>));<br>        <span class=\"hljs-keyword\">int</span> loop=n/<span class=\"hljs-number\">2</span>;\t<span class=\"hljs-comment\">//一次一圈，所以除2</span><br>        <span class=\"hljs-keyword\">int</span> startx=<span class=\"hljs-number\">0</span>,starty=<span class=\"hljs-number\">0</span>;\t<span class=\"hljs-comment\">//记录起始位置</span><br>        <span class=\"hljs-keyword\">int</span> i,j;<br>        <span class=\"hljs-keyword\">int</span> ans=<span class=\"hljs-number\">1</span>;\t<span class=\"hljs-comment\">//数字增量</span><br>        <span class=\"hljs-keyword\">int</span> offset=<span class=\"hljs-number\">1</span>;\t<span class=\"hljs-comment\">//相同循环操作的偏移量</span><br>        <span class=\"hljs-keyword\">while</span>(loop--)&#123;<br>            i=startx;\t<br>            j=starty;<br>            <span class=\"hljs-keyword\">for</span>(;j&lt;n-offset+startx;j++)\t<span class=\"hljs-comment\">//注意j的范围是要有偏移量的</span><br>                result[i][j]=ans++;<br>\t\t\t<span class=\"hljs-comment\">//因为采用左闭右开，所以j最后加出来的数，可以在下面的循环里直接用</span><br>            <span class=\"hljs-keyword\">for</span>(;i&lt;n-offset+startx;i++)<br>                result[i][j]=ans++;<br>                <br>            <span class=\"hljs-keyword\">for</span>(;j&gt;starty;j--)<br>                result[i][j]=ans++;<br>           <br>            <span class=\"hljs-keyword\">for</span>(;i&gt;startx;i--)<br>                result[i][j]=ans++;<br>            <span class=\"hljs-comment\">//下一轮作准备</span><br>            startx++;<br>            starty++;\t<span class=\"hljs-comment\">//起始位置改变</span><br>            offset+=<span class=\"hljs-number\">2</span>;\t<span class=\"hljs-comment\">//偏移量改变</span><br>        &#125;<br>         <span class=\"hljs-keyword\">if</span> (n%<span class=\"hljs-number\">2</span>) &#123;\t\t<span class=\"hljs-comment\">//n是奇数，则存在一个正中间数会少loop一次，需要额外处理</span><br>            result[n/<span class=\"hljs-number\">2</span>][n/<span class=\"hljs-number\">2</span>] = ans;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span>  result;<br>    &#125;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n","categories":["刷题记录"],"tags":["LeetCode刷题","C++"]},{"title":"c++函数使用记录","url":"/2021/07/28/c++%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","content":"<h1 id=\"c函数使用记录\"><a class=\"markdownIt-Anchor\" href=\"#c函数使用记录\"></a> c++函数使用记录</h1>\n<h2 id=\"stl-函数\"><a class=\"markdownIt-Anchor\" href=\"#stl-函数\"></a> STL 函数</h2>\n<ul>\n<li>\n<p><code>equal_range()</code>：一个<mark>二分查找</mark>的算法，试图在<mark>已排序</mark>的[first,last)中寻找value，它返回一对<mark>迭代器i和j</mark>。</p>\n<ul>\n<li>\n<p>如果该键值在<mark>容器</mark>中存在，则i是在<strong>不破坏次序的前提下</strong>，value可插入的第一个位置（亦即lower_bound），j是在<strong>不破坏次序的前提下</strong>，value可插入的最后一个位置（亦即upper_bound）；如果找不到，则i,j都指向此键值应该插入的位置。</p>\n</li>\n<li>\n<p>C++11 简便写法 <code>auto bounds = equal_range(nums.begin(), nums.end(), target);</code></p>\n</li>\n<li>\n<p>可以将其看做<code>lower_bound</code>和<code>upper_bound</code>的结合</p>\n</li>\n<li>\n<p><code>vector map</code>都可以用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\">vector: <span class=\"hljs-built_in\">equal_range</span>(nums.<span class=\"hljs-built_in\">begin</span>(), nums.<span class=\"hljs-built_in\">end</span>(), target);<br>map:<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p><code>distance()</code>：计算迭代器之间的距离</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">int</span> dis=<span class=\"hljs-built_in\">distance</span>(nums.<span class=\"hljs-built_in\">begin</span>(),nums.<span class=\"hljs-built_in\">end</span>()<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>remove()</code>：移除区间{beg,end)中每一个“与value相等”的元素。最后remove返回指向“目标数列”的end()的迭代器</p>\n<ul>\n<li>只会移动元素，并且也不是将vlaues移到最后面去</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\">vcetor:<span class=\"hljs-built_in\">remove</span>(nums.<span class=\"hljs-built_in\">begin</span>(),nums.<span class=\"hljs-built_in\">end</span>(),value);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>Remove_if()</code>：移除区间[beg,end)中每一个“令判断式获得true”的元素</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">isValue</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span> </span>&#123; <span class=\"hljs-keyword\">return</span> x==target; &#125;<br>vcetor:<span class=\"hljs-built_in\">remove</span>(nums.<span class=\"hljs-built_in\">begin</span>(),nums.<span class=\"hljs-built_in\">end</span>(),isValue);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>erase()</code>:删除<mark>容器</mark>中的某些元素，返回经过删除操作后的容器</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">erase</span>(iter);<br><span class=\"hljs-built_in\">erase</span>(iter.begin,iter.end)\t<span class=\"hljs-comment\">/** iter代表迭代器 **/</span><br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>fill()</code>：为某容器某个区间赋相同值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\">vcetor:<span class=\"hljs-built_in\">fill</span>(nums.<span class=\"hljs-built_in\">begin</span>(),nums.<span class=\"hljs-built_in\">end</span>(),<span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>find(first, end, value)</code>：返回区间[first，end）中第一个值等于value的元素位置；若未找到，返回end。函数返回的是迭代器或指针，即位置信息</p>\n<ul>\n<li>如果查找整个区间，可以直接<code>xx.find(value)</code></li>\n</ul>\n</li>\n<li>\n<p><code>reverse(begin,end)</code>：反转</p>\n<ul>\n<li>多用于string、vector</li>\n</ul>\n</li>\n<li>\n<p><code>replace(begin,end,x,xx)</code>:在容器[being,end)范围内，将所有的x替换为xxx</p>\n<ul>\n<li><code>replace_if(being,end,条件判断,xxx)</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"string-函数\"><a class=\"markdownIt-Anchor\" href=\"#string-函数\"></a> String 函数</h2>\n<ul>\n<li>\n<p><code>str.replace()</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\">str.<span class=\"hljs-built_in\">replace</span>(pos,<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&quot;#&quot;</span>)\t<span class=\"hljs-comment\">//从位置pos开始的两个字符替换成#</span><br>str.<span class=\"hljs-built_in\">replace</span>(<span class=\"hljs-built_in\">begin</span>(),<span class=\"hljs-built_in\">end</span>(),<span class=\"hljs-string\">&quot;#&quot;</span>)\t<span class=\"hljs-comment\">//[begin,end)的字符替换成&quot;#&quot;</span><br></code></pre></td></tr></table></figure>\n</li>\n<li>\n<p><code>str.substr(begin,length)</code>：从索引begin开始，截取长度为length的字符</p>\n</li>\n<li>\n<p><code>stoi(stirng s)</code>：将用字符串表示的数字转换为<code>Int</code></p>\n<ul>\n<li>非数字字符转换会报错</li>\n</ul>\n</li>\n</ul>\n","categories":["刷题笔记"],"tags":["LeetCode刷题","C++函数"]},{"title":"刷题总结——多指针法","url":"/2021/07/28/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%A4%9A%E6%8C%87%E9%92%88%E6%B3%95/","content":"<h1 id=\"刷题总结多指针法\"><a class=\"markdownIt-Anchor\" href=\"#刷题总结多指针法\"></a> 刷题总结——多指针法</h1>\n<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h2>\n<ul>\n<li><strong>双指针法基本都是应用在数组，字符串与链表的题目上</strong></li>\n<li>一般题目要求空间复杂度为O(1)，但要对数组等进行操作，可以考虑使用该方法</li>\n</ul>\n<h2 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h2>\n<ul>\n<li>一般常用的双指针法：\n<ul>\n<li>快慢双指针：同一方向移动，但是速度不同</li>\n<li>前后双指针：不同方向移动</li>\n<li>工作指针+标识指针：标识指针的移动取决于工作指针</li>\n</ul>\n</li>\n<li>特殊情况下也有多指针法，需要具体问题具体分析</li>\n</ul>\n<h2 id=\"题目练习\"><a class=\"markdownIt-Anchor\" href=\"#题目练习\"></a> 题目练习</h2>\n<h3 id=\"数组移除元素\"><a class=\"markdownIt-Anchor\" href=\"#数组移除元素\"></a> 数组——移除元素</h3>\n<p>工作指针+标识指针</p>\n<ul>\n<li>[27.Remove Element](<a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\">26. Remove Duplicates from Sorted Array</a>)</li>\n<li>[26.Remove Duplicates from Sorted Array](<a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\">26. Remove Duplicates from Sorted Array</a>)—2021.7.3</li>\n<li><a href=\"https://leetcode-cn.com/problems/move-zeroes/\">283.Move Zeroes</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/backspace-string-compare/\">844.Backspace String Compare</a>—2020.7.5</li>\n<li><a href=\"https://leetcode-cn.com/problems/squares-of-a-sorted-array/\">977.Squares of a Sorted Array</a></li>\n</ul>\n","categories":["刷题笔记"],"tags":["LeetCode刷题","C++"]},{"title":"刷题总结——多数想加（减）等于特定值","url":"/2021/07/28/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%A4%9A%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88%E5%87%8F%EF%BC%89%E7%AD%89%E4%BA%8E%E7%89%B9%E5%AE%9A%E5%80%BC/","content":"<h1 id=\"刷题总结多数相加减等于特定值\"><a class=\"markdownIt-Anchor\" href=\"#刷题总结多数相加减等于特定值\"></a> 刷题总结——多数相加（减）等于特定值</h1>\n<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h2>\n<ul>\n<li>存在一类题目，给你一些数组（可能是一个，也可能是多个），给你一个<code>target</code>，要求你从给定的数据中，选择一些数相加（减）等于<code>target</code></li>\n</ul>\n<h2 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h2>\n<ul>\n<li>这类算是排列组合题。如果暴力求解，就直接多重循环将数字排列组合验证即可(一般会超时)</li>\n<li>但是考虑到已知<code>target</code>,我们可以<strong>先排列组合部分获得值</strong>，然后根据结果去找接下来需要应该要获得的值</li>\n<li>重点就是如何确定数据中是否存在应该要获得的值\n<ul>\n<li>一种情况，可以利用<code>find()函数</code>\n<ul>\n<li><code>STL find()</code>时间复杂度是<code>O(n)</code></li>\n<li><code>map、set</code>成员函数<code>find()</code>是<code>O(logn)</code></li>\n</ul>\n</li>\n<li>另一种情况，可以利用哈希，空间换时间，缩小时间复杂度\n<ul>\n<li>先将排列组合的值保存下来，减少循环层数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>此类题目可能存在的不同要求：\n<ol>\n<li>最终结果获得的值不能重复：那么在找的过程中，<strong>要确保找到的数字是之前部分结果中没有使用过的</strong>，此时哈希法不太好用，可以考虑多指针法\n<ul>\n<li>多指针法，一般要对数据进行排序，所以也不适用需要最后返回索引的问题</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"题目分析\"><a class=\"markdownIt-Anchor\" href=\"#题目分析\"></a> 题目分析</h2>\n<h3 id=\"同一集合中找数据返回数据索引\"><a class=\"markdownIt-Anchor\" href=\"#同一集合中找数据返回数据索引\"></a> 同一集合中找数据+返回数据索引</h3>\n<ul>\n<li>[1.Two Sum](LeetCode <a href=\"http://1.md/\">1.md/</a>)</li>\n</ul>\n<h3 id=\"同一集合中找数据返回结果数值\"><a class=\"markdownIt-Anchor\" href=\"#同一集合中找数据返回结果数值\"></a> 同一集合中找数据+返回结果数值</h3>\n<ul>\n<li>[15.3Sum](LeetCode <a href=\"http://15.md\">15.md</a>)</li>\n<li><a href=\"https://leetcode-cn.com/problems/4sum/\">18.4Sum</a></li>\n</ul>\n<h3 id=\"不同集合中找数据返回结果数量\"><a class=\"markdownIt-Anchor\" href=\"#不同集合中找数据返回结果数量\"></a> 不同集合中找数据+返回结果数量</h3>\n<ul>\n<li><a href>454.4Sum II</a></li>\n</ul>\n","categories":["刷题笔记"],"tags":["LeetCode刷题","C++"]},{"title":"刷题总结——字符串KMP算法分析与应用","url":"/2021/07/28/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84KMP%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E4%BD%BF%E7%94%A8/","content":"<h1 id=\"刷题总结字符串的kmp算法分析与应用\"><a class=\"markdownIt-Anchor\" href=\"#刷题总结字符串的kmp算法分析与应用\"></a> 刷题总结——字符串的KMP算法分析与应用</h1>\n<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"#概述\"></a> 概述</h2>\n<ul>\n<li>KMP的经典思想就是：<strong>当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。</strong>\n<ul>\n<li>如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任</li>\n</ul>\n</li>\n<li><mark>next数组</mark>：前缀表（<em>prefix table</em>）\n<ul>\n<li>前缀表是用来回退的，它记录了模式串(与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配</li>\n<li>记录下标i之前（包括i）的字符串中，有多大长度的相同<strong>前缀后缀</strong></li>\n</ul>\n</li>\n<li>最长相等前后缀\n<ul>\n<li><mark>前缀</mark>：指<strong>不包含最后一个字符</strong>的所有以第一个字符开头的连续子串</li>\n<li><mark>后缀</mark>：指<strong>不包含第一个字符</strong>的所有以最后一个字符结尾的连续子串</li>\n<li><strong>前缀表要求的就是相同前后缀的长度</strong></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"如何构造前缀表和next数组\"><a class=\"markdownIt-Anchor\" href=\"#如何构造前缀表和next数组\"></a> 如何构造前缀表和next数组</h2>\n<ul>\n<li>\n<p>前缀表中记录了模式串中每个位置从 [0,位置] 的最长相等前后缀的长度</p>\n<ul>\n<li>前缀表的长度等于模式串</li>\n</ul>\n</li>\n<li>\n<p>当在 模式表i 处发生不匹配时，只需找到前缀表中i-1的位置处的值，即可知道下次匹配从<code>模式表[前缀表[i-1]]</code>处开始</p>\n</li>\n<li>\n<p>为了简便，通常会将前缀表向右移动并赋初值为-1，得到<code>next数组</code>,这样下次匹配就是<code>模式表[next[i]]</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/*构造nextu</span><br><span class=\"hljs-comment\">1. 初始化</span><br><span class=\"hljs-comment\">2. 处理前后缀不同的情况</span><br><span class=\"hljs-comment\">3. 处理前后缀相同的情况</span><br><span class=\"hljs-comment\">整个算法有点动态规划的味道，在前一段完成的基础上，获得下一段的情况</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">getNext</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>* next, <span class=\"hljs-keyword\">const</span> string&amp; s)</span> </span>&#123;<br>\tnext[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">-1</span>;\t<span class=\"hljs-comment\">//先给next[0]赋初值,必定是-1</span><br>    <span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;\t\t<br>\t<span class=\"hljs-keyword\">int</span> k=<span class=\"hljs-number\">-1</span>;\t\t<span class=\"hljs-comment\">//记录s[0]-s[j-1]最长相等前缀的后一个位置</span><br>   \t<span class=\"hljs-keyword\">while</span>(j&lt;s.<span class=\"hljs-built_in\">length</span>()<span class=\"hljs-number\">-1</span>)&#123;\t\t<span class=\"hljs-comment\">//因为我们是使用右移的next数字，所以循环的j实际上是给j+1赋值</span><br>    \t<span class=\"hljs-keyword\">if</span>(k==<span class=\"hljs-number\">-1</span>||s[j]==s[k])&#123;\t\t<span class=\"hljs-comment\">//这里加k==-1这个条件，实际上也是一个给next[1]赋初值的条件，因为s[1]不匹配的话，只能用s[0]l来匹配，</span><br>    <span class=\"hljs-comment\">//如果s[j+1]不匹配,考虑0-j的字符串,当s[k]==s[j]时,0-j字符串的k应该是k+1，所以s[j+1]=k+1（之后为了下次循环，k，j也要往前移动一位）</span><br>            j++;k++;<br>         \tnext[j]=k;\t<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;\t\t\t\t\t\t<br>        <span class=\"hljs-comment\">//如果s[j+1]不匹配时，考虑0-j的字符串，当s[j]!=s[k]，0-j的最长相等前缀位置不是k(因为k是0-j-1的)，所以要更新这次的k。因为k是0-j-1的最长相等前缀的后一个位置，所以s[j]!=s[k]最长前缀只可能在0-k-1中出现，那么next[k]就应该是下一个去匹配的位置，进入下一次循环判断直到有s[k]==s[j],那么此时的k就是0-j处的最长前缀的后一个位置</span><br>            k=next[k];<br>        &#125;    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"题目练习\"><a class=\"markdownIt-Anchor\" href=\"#题目练习\"></a> 题目练习</h2>\n<h3 id=\"在一个串中查找是否出现过另一个串\"><a class=\"markdownIt-Anchor\" href=\"#在一个串中查找是否出现过另一个串\"></a> 在一个串中查找是否出现过另一个串</h3>\n<ul>\n<li>\n<p><a href=\"https://leetcode-cn.com/problems/implement-strstr/\">28.Implement strStr()</a></p>\n<ul>\n<li>\n<p>next数组可以优化</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\">next[j]=s[j]!=s[k]?k:next[k]<span class=\"hljs-comment\">//next数组优化，避免s[j+1]发生不匹配时，下一个s[next[j+1]]==s[j+1]继续不匹配，需要继续往下匹配</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li></li>\n</ul>\n<p><strong>扩展阅读</strong></p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/yjiyjige/p/3263858.html\">详解KMP算法</a></li>\n</ul>\n","categories":["刷题笔记"],"tags":["LeetCode刷题","C++"]},{"title":"语法总结——C++11","url":"/2021/07/28/%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94C++%2011/","content":"<h1 id=\"语法总结c-11\"><a class=\"markdownIt-Anchor\" href=\"#语法总结c-11\"></a> 语法总结——C++ 11</h1>\n<h2 id=\"使用emplace操作\"><a class=\"markdownIt-Anchor\" href=\"#使用emplace操作\"></a> 使用emplace操作</h2>\n<table>\n<thead>\n<tr>\n<th>新函数</th>\n<th>对应之前函数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>emplace(i, type)</td>\n<td>insert(type, i)</td>\n</tr>\n<tr>\n<td>emplace_front</td>\n<td>push_front</td>\n</tr>\n<tr>\n<td>emplace_back</td>\n<td>push_back</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>emplace是构造而不是拷贝元素，不需要拷贝或者移动内存。</p>\n<ul>\n<li>如果元素是基本类型，新特性就没有体现，也就没有优势</li>\n</ul>\n</li>\n<li>\n<p>所有的标准库容器（array除外，因为它的长度不可改变，不能插入元素）都增加了类似的方法</p>\n</li>\n<li>\n<p>使用示例</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\">S.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-built_in\">data</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>))\t<span class=\"hljs-comment\">//让其构造函数构造好了对象之后，再使用复制构造函数</span><br>S.<span class=\"hljs-built_in\">emplace</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>)\t<span class=\"hljs-comment\">//emplace这样接受新对象的时候，自己会调用其构造函数生成对象然后放在容器内（比如这里传入了1，2，它则会自动调用一次data(1,2))</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n","categories":["刷题笔记"],"tags":["C++ 11"]},{"title":"刷题记录——LeetCode","url":"/2021/07/28/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94LeetCode/","content":"<h1 id=\"刷题记录leetcode\"><a class=\"markdownIt-Anchor\" href=\"#刷题记录leetcode\"></a> 刷题记录——LeetCode</h1>\n<h2 id=\"数组\"><a class=\"markdownIt-Anchor\" href=\"#数组\"></a> 数组</h2>\n<h3 id=\"二分法\"><a class=\"markdownIt-Anchor\" href=\"#二分法\"></a> 二分法</h3>\n<p><strong>适用情况</strong></p>\n<ul>\n<li>在一组有序数字中，进行查找操作</li>\n</ul>\n<p><strong>注意</strong></p>\n<ul>\n<li>根据不同的情况，要对while的循环条件和里面的if选择条件进行修改</li>\n</ul>\n<p><strong>基本格式</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\">```<br><br><br><br>**题目练习**<br><br>- [<span class=\"hljs-number\">704.</span> Binary Search](https:<span class=\"hljs-comment\">//leetcode-cn.com/problems/binary-search/)</span><br>- [<span class=\"hljs-number\">35.</span> Search Insert Position](https:<span class=\"hljs-comment\">//leetcode-cn.com/problems/search-insert-position/)</span><br>- [<span class=\"hljs-number\">34.</span> Find First <span class=\"hljs-keyword\">and</span> Last Position of Element in Sorted Array](https:<span class=\"hljs-comment\">//leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)(==题解==)---2021.7.1</span><br>- [<span class=\"hljs-number\">69.</span> <span class=\"hljs-built_in\">Sqrt</span>(x)](https:<span class=\"hljs-comment\">//leetcode-cn.com/problems/sqrtx/)（==题解==）----2021.7.2</span><br>- [<span class=\"hljs-number\">367.</span> Valid Perfect Square](https:<span class=\"hljs-comment\">//leetcode-cn.com/problems/valid-perfect-square/)---2021.7.3</span><br><br>### 快慢指针法----移除元素<br><br>**适用情况**<br><br>- 在有序数组中，需要移动元素位置（包括移除、移动元素）<br><br>**注意**<br><br>- 不同的移除条件，循环里有不同的写法<br><br>**题目练习**<br><br>- [<span class=\"hljs-number\">27.</span>Remove Element]([<span class=\"hljs-number\">26.</span> Remove Duplicates from Sorted Array](https:<span class=\"hljs-comment\">//leetcode-cn.com/problems/remove-duplicates-from-sorted-array/))</span><br>- [<span class=\"hljs-number\">26.</span>Remove Duplicates from Sorted Array]([<span class=\"hljs-number\">26.</span> Remove Duplicates from Sorted Array](https:<span class=\"hljs-comment\">//leetcode-cn.com/problems/remove-duplicates-from-sorted-array/))---2021.7.3</span><br>- [<span class=\"hljs-number\">283.</span>Move Zeroes](https:<span class=\"hljs-comment\">//leetcode-cn.com/problems/move-zeroes/)</span><br>- [<span class=\"hljs-number\">844.B</span>ackspace String Compare](https:<span class=\"hljs-comment\">//leetcode-cn.com/problems/backspace-string-compare/)---2020.7.5</span><br>- [<span class=\"hljs-number\">977.</span>Squares of a Sorted Array](https:<span class=\"hljs-comment\">//leetcode-cn.com/problems/squares-of-a-sorted-array/)</span><br><br>### 滑动窗口<br><br>**适用情况**<br><br>- 查找连续子数组问题，不断的调节子序列的起始位置和终止位置，从而得出我们想要的结果<br>- 特殊情况也可使用前缀和思想<br><br>**注意**<br><br>- 根据要求，设计每次窗户扩展后的处理方法非常关键<br><br>**模版**<br><br>```c++<br>根据题目，<span class=\"hljs-keyword\">for</span>循环内窗口扩展操作作准备<br><span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;\t<span class=\"hljs-comment\">//窗口起始位置</span><br><span class=\"hljs-keyword\">int</span> result=？\t\t<span class=\"hljs-comment\">//看情况初值（最大或最小），保存每次结果和最终结果</span><br><span class=\"hljs-keyword\">for</span>（<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;size;j++)&#123;\t<span class=\"hljs-comment\">//滑动窗口开始扩展</span><br>    根据题目要求，设计每次窗户扩展的处理操作并保存记录<br>    <span class=\"hljs-keyword\">while</span>(窗口操作后的记录的临界情况)&#123;\t<span class=\"hljs-comment\">//记录数据，并开始滑动窗口</span><br>        <span class=\"hljs-keyword\">int</span> ans=j-i+<span class=\"hljs-number\">1</span>;\t<span class=\"hljs-comment\">//此时窗口大小</span><br>        result=result&gt;ans?result:ans;\t<span class=\"hljs-comment\">//根据要求写判断逻辑</span><br>        窗口起始位置向前滑动后对记录的影响<br>        i++;\t<span class=\"hljs-comment\">//窗口起始位置向前滑动</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>题目练习</strong></p>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/minimum-size-subarray-sum/\">209.Minimum Size Subarray Sum</a>—2021.7.6\n<ul>\n<li>前缀和 O(nlogn)</li>\n</ul>\n</li>\n<li><a href=\"https://leetcode-cn.com/problems/fruit-into-baskets/\">904.Fruit Into Baskets</a>–2021.7.7</li>\n<li><a href=\"https://leetcode-cn.com/problems/minimum-window-substring/\">76.Minmum Window Substring</a>(<mark>题解</mark>)—2021.7.8</li>\n</ul>\n<h3 id=\"其它\"><a class=\"markdownIt-Anchor\" href=\"#其它\"></a> 其它</h3>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/spiral-matrix-ii/\">59.Spiral Matrix II</a>(<mark>题解</mark>)—2021.7.9</li>\n</ul>\n<h2 id=\"链表\"><a class=\"markdownIt-Anchor\" href=\"#链表\"></a> 链表</h2>\n<p><mark>用while循环遍历链表时，要根据自己的处理逻辑，选择是用<code>while(node-&gt;next)</code>还是<code>while(node)</code>，一般来说如果能确定进入循环前的node必有值的话，就用前一个，否则用后一个</mark></p>\n<h3 id=\"虚拟头结点\"><a class=\"markdownIt-Anchor\" href=\"#虚拟头结点\"></a> 虚拟头结点</h3>\n<p><strong>适用情况</strong></p>\n<ul>\n<li>一般来说，如果对单链表进行操作，除头结点外结点操作基本相同，那么可以添加一个虚拟头结点，使得原头结点变成子节点，统一操作</li>\n</ul>\n<p><strong>注意</strong></p>\n<ul>\n<li>工作指针指向虚拟头结点后，要从node-&gt;next开始判断</li>\n<li>返回vir_head-&gt;next才是真正头指针</li>\n</ul>\n<p><strong>模板</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\">ListNode* vir_head=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ListNode</span>();\t<span class=\"hljs-comment\">//初始化虚拟结点</span><br>vir_head-&gt;next=head;\t<span class=\"hljs-comment\">//构造虚拟头结点</span><br>ListNode* node=vir_head;\t<span class=\"hljs-comment\">//工作指针从虚拟结点开始</span><br></code></pre></td></tr></table></figure>\n<p><strong>题目练习</strong></p>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/remove-linked-list-elements/\">203.Remove Linked List Elements</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/design-linked-list/\">707.Design Linked List</a>—2021.7.10</li>\n<li><a href=\"https://leetcode-cn.com/problems/swap-nodes-in-pairs/\">24.Swap Nodes in Pairs</a>—2021.7.12</li>\n</ul>\n<h3 id=\"链表翻转\"><a class=\"markdownIt-Anchor\" href=\"#链表翻转\"></a> 链表翻转</h3>\n<p><strong>方法</strong></p>\n<ul>\n<li>头插法：新建一个虚拟头结点，利用头插法构造逆序链表</li>\n<li>双指针法：利用前后指针，将next的指向逆转过来</li>\n</ul>\n<p><strong>题目练习</strong></p>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\">206.Reverse Linked List</a>(<mark>笔记</mark>)—20217.11</li>\n</ul>\n<h3 id=\"双指针法一遍找倒数位置元素\"><a class=\"markdownIt-Anchor\" href=\"#双指针法一遍找倒数位置元素\"></a> 双指针法——一遍找倒数位置元素</h3>\n<p><strong>注意</strong></p>\n<ul>\n<li>要确定last、fast指针的距离，以及要选择最后fast是走到最后一个位置处，还是走到null处时，此时的fast的位置到底是不是符合要求的</li>\n</ul>\n<p><strong>题目</strong></p>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\">19.Remove Nth Node From End of List</a>（<mark>笔记</mark>）—2021.712</li>\n</ul>\n<h3 id=\"双指针法找链表相交结点位置\"><a class=\"markdownIt-Anchor\" href=\"#双指针法找链表相交结点位置\"></a> 双指针法——找链表相交结点位置</h3>\n<p><strong>注意</strong></p>\n<ul>\n<li>要先确定两个指针的距离，然后同步移动找到指针值相同的结点即可</li>\n</ul>\n<p><strong>题目</strong></p>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/\">面试题02.07.链表相交</a></li>\n</ul>\n<h3 id=\"环形链表确定环及环入口位置\"><a class=\"markdownIt-Anchor\" href=\"#环形链表确定环及环入口位置\"></a> 环形链表——确定环及环入口位置</h3>\n<p><strong>注意</strong></p>\n<ul>\n<li>根据快慢指针找环</li>\n<li>环的入口位置需要数学证明</li>\n</ul>\n<p><strong>题目</strong></p>\n<ul>\n<li>[142.Link List Cycle II（<mark>题解</mark>）—2021.7.13</li>\n</ul>\n<h2 id=\"哈希表\"><a class=\"markdownIt-Anchor\" href=\"#哈希表\"></a> 哈希表</h2>\n<p><strong>适用情况</strong></p>\n<ul>\n<li>需要记录元素出现的次数–map</li>\n<li>需要记录元素是否出现过–set\\map</li>\n</ul>\n<p><strong>注意</strong></p>\n<ul>\n<li>\n<p>如果数据比较少，key可以用int且最大值不大，直接用数组即可</p>\n</li>\n<li>\n<p>如果数据比较少，但特别分散、跨度大，可以用unordered_map</p>\n</li>\n<li>\n<p>如果只是需要记录是否出现过，可以用unordered_set作集合操作，用find判断</p>\n<p>也可用map只读一次数据</p>\n</li>\n</ul>\n<p><strong>题目</strong></p>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/valid-anagram/\">242.Vaild Anagram</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/intersection-of-two-arrays/\">349.intersection-of-two-arrays</a>—2021.7.14</li>\n<li><a href=\"https://leetcode-cn.com/problems/happy-number/\">202.Happy Number</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/two-sum/\">1.Two Sum</a>—2021.7.15</li>\n<li><a href>454.4Sum II</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/ransom-note/\">383.Ransom Note</a>—2021.7.16</li>\n<li><a href=\"https://leetcode-cn.com/problems/3sum/\">15.3Sum</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/4sum/\">18.4Sum</a></li>\n</ul>\n<p><strong>扩展阅读</strong></p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/ladawn/p/8203789.html\">C++ multimap查找相同键的键值对方法</a></li>\n</ul>\n<h2 id=\"字符串\"><a class=\"markdownIt-Anchor\" href=\"#字符串\"></a> 字符串</h2>\n<h3 id=\"反转\"><a class=\"markdownIt-Anchor\" href=\"#反转\"></a> 反转</h3>\n<p><strong>题目</strong></p>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/reverse-string/\">344.Reverse String</a>—2021.7.19</li>\n<li><a href=\"https://leetcode-cn.com/problems/reverse-string-ii/\">541.Reverse String II</a> —2021.7.20</li>\n<li><a href=\"https://leetcode-cn.com/problems/reverse-words-in-a-string/\">151.Reverse Wrods in a String</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/\">剑指Offer 58-II 左旋转字符串</a>—2021.7.21</li>\n<li><a href=\"https://leetcode-cn.com/problems/implement-strstr/\">28.Implement strStr</a>—2021.7.22</li>\n<li><a href=\"https://leetcode-cn.com/problems/repeated-substring-pattern/\">459.Repeated Sbustring Pattern</a>(<mark>无思路</mark>)（<mark>好好研究</mark>）—2021.7.23</li>\n</ul>\n<h2 id=\"栈和队列\"><a class=\"markdownIt-Anchor\" href=\"#栈和队列\"></a> 栈和队列</h2>\n<p><strong>预备知识</strong></p>\n<ul>\n<li>栈、队列是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的。STL中栈的队列往往不被归类为容器，而被归类为container adapter（容器适配器）</li>\n</ul>\n<p><strong>注意</strong></p>\n<ul>\n<li><code>stack.pop()</code>返回值是void,<code>stack.top()</code>返回值才是具体数值</li>\n</ul>\n<p><strong>应用类型</strong></p>\n<ul>\n<li>对称匹配类问题——栈\n<ul>\n<li>两个元素匹配，匹配后可再有操作</li>\n</ul>\n</li>\n</ul>\n<p><strong>题目练习</strong></p>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/implement-queue-using-stacks/\">232.Implement Queue using Stacks</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/implement-stack-using-queues/\">225.Implement Stack using Queues</a>—2021.7.24</li>\n<li><a href=\"https://leetcode-cn.com/problems/valid-parentheses/\">20.Vaild Parentheses</a></li>\n<li><a href=\"https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/\">1047.Remove All Adjacent Duplicates In String</a>—2021.7.26</li>\n<li><a href=\"https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/\">150.Evaluate Reverse Polish Notation</a>—2021.7.27</li>\n<li><a href=\"https://leetcode-cn.com/problems/sliding-window-maximum/\">239.Sliding Window Maximum</a>（<mark>题解问题</mark>）—2021.7.28</li>\n</ul>\n","categories":["刷题记录"],"tags":["LeetCode刷题","C++"]},{"title":"刷题总结——字符串的各种反转及应用","url":"/2021/07/28/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%90%84%E7%A7%8D%E5%8F%8D%E8%BD%AC%E5%8F%8A%E8%BF%90%E7%94%A8/","content":"<h1 id=\"刷题总结字符串的各种反转及运用\"><a class=\"markdownIt-Anchor\" href=\"#刷题总结字符串的各种反转及运用\"></a> 刷题总结——字符串的各种反转及运用</h1>\n","categories":["刷题笔记"],"tags":["LeetCode刷题","C++"]},{"title":"语法总结","url":"/2021/07/28/%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/","content":"<h1 id=\"语法总结队列\"><a class=\"markdownIt-Anchor\" href=\"#语法总结队列\"></a> 语法总结——队列</h1>\n<h2 id=\"队列\"><a class=\"markdownIt-Anchor\" href=\"#队列\"></a> 队列</h2>\n<h2 id=\"优先队列\"><a class=\"markdownIt-Anchor\" href=\"#优先队列\"></a> 优先队列</h2>\n<h3 id=\"头文件\"><a class=\"markdownIt-Anchor\" href=\"#头文件\"></a> 头文件</h3>\n<p><code>#include&lt;queue&gt;</code></p>\n<h3 id=\"特点\"><a class=\"markdownIt-Anchor\" href=\"#特点\"></a> 特点</h3>\n<ul>\n<li>在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征</li>\n<li>优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，<strong>它本质是一个堆实现的</strong></li>\n</ul>\n<h3 id=\"定义\"><a class=\"markdownIt-Anchor\" href=\"#定义\"></a> 定义</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">Type： 数据类型</span><br><span class=\"hljs-comment\">Container: 容器类型（必须是用数组实现的容器，vector,deque等，不能用List）</span><br><span class=\"hljs-comment\">Functional: 比较的方式</span><br><span class=\"hljs-comment\">*/</span><br>priority_queue&lt;Type, Container, Functional&gt;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>对于基本类型，默认使用大顶堆</p>\n</li>\n<li>\n<p>示例:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\">priority_queue&lt;<span class=\"hljs-keyword\">int</span>&gt; a;<br>priority_queue &lt;<span class=\"hljs-keyword\">int</span>,vector&lt;<span class=\"hljs-keyword\">int</span>&gt;,greater&lt;<span class=\"hljs-keyword\">int</span>&gt; &gt; q;\t<span class=\"hljs-comment\">//主动声明 小顶堆</span><br>priority_queue&lt;string&gt; b<br>priority_queue&lt;pair&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt; &gt; a\t<span class=\"hljs-comment\">//pair先比较第一个</span><br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"基本操作函数\"><a class=\"markdownIt-Anchor\" href=\"#基本操作函数\"></a> 基本操作函数</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">top</td>\n<td>访问队头元素</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">empty</td>\n<td>队列是否为空</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">size</td>\n<td>返回队列内元素个数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">push</td>\n<td>插入元素到队尾 (并排序)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">pop</td>\n<td>弹出队头元素</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">swap</td>\n<td>交换内容</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"进阶操作\"><a class=\"markdownIt-Anchor\" href=\"#进阶操作\"></a> 进阶操作</h3>\n<ul>\n<li>\n<p>自定义类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//方法1</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">tmp1</span> //运算符重载&lt;</span><br>&#123;<br>    <span class=\"hljs-keyword\">int</span> x;<br>    <span class=\"hljs-built_in\">tmp1</span>(<span class=\"hljs-keyword\">int</span> a) &#123;x = a;&#125;<br>    <span class=\"hljs-keyword\">bool</span> <span class=\"hljs-keyword\">operator</span>&lt;(<span class=\"hljs-keyword\">const</span> tmp1&amp; a) <span class=\"hljs-keyword\">const</span>\t\t<span class=\"hljs-comment\">//注意这里重载 &lt;</span><br>    &#123;<br>        <span class=\"hljs-keyword\">return</span> x &lt; a.x; <span class=\"hljs-comment\">//大顶堆</span><br>    &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">//方法2</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">tmp2</span> //重写仿函数</span><br><span class=\"hljs-class\">&#123;</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(tmp1 a, tmp1 b)</span>\t\t<span class=\"hljs-comment\">//这里重载()</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> a.x &lt; b.x; <span class=\"hljs-comment\">//大顶堆</span><br>    &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-function\">tmp1 <span class=\"hljs-title\">a</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>)</span></span>;<br>    <span class=\"hljs-function\">tmp1 <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>)</span></span>;<br>    <span class=\"hljs-function\">tmp1 <span class=\"hljs-title\">c</span><span class=\"hljs-params\">(<span class=\"hljs-number\">3</span>)</span></span>;<br>    priority_queue&lt;tmp1&gt; d;<br>    d.<span class=\"hljs-built_in\">push</span>(b);<br>    d.<span class=\"hljs-built_in\">push</span>(c);<br>    d.<span class=\"hljs-built_in\">push</span>(a);<br>    <span class=\"hljs-keyword\">while</span> (!d.<span class=\"hljs-built_in\">empty</span>())<br>    &#123;<br>        cout &lt;&lt; d.<span class=\"hljs-built_in\">top</span>().x &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;<br>        d.<span class=\"hljs-built_in\">pop</span>();<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;<br>    f.<span class=\"hljs-built_in\">push</span>(b);<br>    f.<span class=\"hljs-built_in\">push</span>(c);<br>    f.<span class=\"hljs-built_in\">push</span>(a);<br>    <span class=\"hljs-keyword\">while</span> (!f.<span class=\"hljs-built_in\">empty</span>())<br>    &#123;<br>        cout &lt;&lt; f.<span class=\"hljs-built_in\">top</span>().x &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;<br>        f.<span class=\"hljs-built_in\">pop</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>扩展阅读</strong></p>\n<ul>\n<li><a href=\"https://blog.csdn.net/weixin_36888577/article/details/79937886\">c++优先队列(priority_queue)用法详解</a></li>\n</ul>\n","categories":["刷题笔记"],"tags":["C++队列"]}]