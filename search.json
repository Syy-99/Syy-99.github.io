[{"title":"test","url":"/2021/08/05/test/","content":"\n![img](4.分支管理/0.png)\n\n"},{"title":"5.标签管理","url":"/2021/08/03/5.标签管理/","content":"\n# 标签管理\n\n## 标签简介\n\n- 发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个**快照**。\n- tag相较于commit号，更好记。\n\n## 创建标签\n\n1. 切换到需要打标签的分支上\n2. 输入命令`git tag <name>`，为该分支的最新提交打标签\n   - 如果想要为特定提交打标签，则需要找到commit号(`git log`)\n   - 用命令`git tag <name> <commit号>`\n3. `git tag`查看所有标签\n   - 标签不是按时间顺序列出的，而是按字母排列的\n\n### 相关命令\n\n- `git show <tag名字>`：查看标签信息\n- `git tag -a <标签名> -m \"xxx\"`:创建带有说明的标签\n\n**注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。**\n\n## 操作标签\n\n### 相关命令\n\n- `git tag -d <标签名>`：删除本地仓库标签\n  - 如果标签已经被推送到远程仓库，那先删除本地仓库标签\n    - 用`git push origin :refs/tags/<标签名>`\n- `git push origin <标签名>`：推送标签到远程仓库\n- `git push origin --tags`:一次性推送全部尚未推送到远程仓库的本地标签","tags":["Github"],"categories":["Git学习"]},{"title":"4.分支管理","url":"/2021/08/03/4.分支管理/","content":"\n# 分支管理\n\n## 创建与合并分支\n\n- 默认本地仓库只有一条分支`main`\n\n  - `HEAD`指向`main`,`main`指向要提交的时间线\n\n- `git switch -c <新分支名>`:创建并切换新分支，指向`main`相同的提交\n\n  - 此时`HEAD`指向新分支。之后的提交都是在新分支下\n\n    ![img](4.分支管理/0.png)\n\n- `git branch`：查看所有分支\n\n  - 当前分支名前会有一个*号\n  - `-a`：查看本地和远程仓库所有分支\n  - `-r`：查看远程仓库分支\n\n- `git merge <分支名>`：合并指定分支的工作到当前分支下\n\n- `git branch -d <分支名>`：删除分支\n\n  - `-D`：删除一个没有被合并过得分支\n\n## 分支冲突\n\n- 合并冲突：\n\n  - 当创建多分支时，如果修改不同文件，则合并不会提示冲突\n\n  - 如果修改相同文件，合并时会提示冲突，需要手动修改冲突，确定文件的最终版本\n\n    ![img](https://www.liaoxuefeng.com/files/attachments/919023000423040/0)\n\n- Git用`<<<<<<<`，`=======`，`>>>>>>>`标记出不同分支的内容\n\n- 合并策略：\n\n  - 默认使用`Fast forward`，会直接将Master分支指向Develop分支。在这种模式下，删除分支后，会丢掉分支信息\n\n    <img src=\"https://raw.githubusercontent.com/Syy-99/Cloud_images/img/20210803114237.png\" alt=\"bg2012070505(1)\" style=\"zoom:50%;\" />\n\n  - ` git merge --no-ff -m \"merge with no-ff\" dev`\n\n    - 使用`--no-ff`参数后，会执行正常合并，在Master分支上生成一个新节点\n\n      <img src=\"C:\\Users\\Administrator.USER-20201209JD\\Desktop\\bg2012070506(1).png\" alt=\"bg2012070506(1)\" style=\"zoom:50%;\" />\n\n- 合并分支时，加上`--no-ff`参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而`fast forward`合并就看不出来曾经做过合并\n\n## 分支管理策略\n\n<img src=\"https://www.liaoxuefeng.com/files/attachments/919023260793600/0\" alt=\"img\" style=\"zoom: 80%;\" />\n\n- ==主分支main(master)==:代码库应该有一个、且仅有一个主分支。仅用来发布新版本，平时不能在上面干活.\n\n- ==工作分支dev==：日常开发。如果想正式对外发布，就在分支上，对Develop分支进行\"合并\"\n\n- **临时分支**：\n\n  - ==功能分支feature-xxx==：为了开发某种特定功能，从`dev分支`上面分出来的。开发完成后，要再并入dev\n\n    <img src=\"C:\\Users\\Administrator.USER-20201209JD\\Desktop\\d4806f137df9563d148afb17a51a1134_bg2012070507.png\" alt=\"d4806f137df9563d148afb17a51a1134_bg2012070507\" style=\"zoom:50%;\" />\n\n  - ==预发布分支release-xxx==：指发布正式版本之前（即合并到`main分支`之前），我们可能需要有一个预发布的版本进行测试。预发布分支是从`dev分支`上面分出来的，预发布结束以后，必须合并进`dev和main分支`.\n\n  - ==修补bug分支fixbug-xxx==：修补bug分支是从`main分支`上面分出来的。修补结束以后，再合并进`main和dev分支`\n  \n    - bug突然出现，如何保存当前的工作?恢复工作？\n  \n      ```she\n      git stash\t//把当前工作现场“储藏”起来，等以后恢复现场后继续工作\n      git stash list\t//查看该分支保存的状态\n      git stash pop\t//在该分支下，恢复之前保存的状态，并删除该记录\n      git stash apply <名字>\t//恢复指定的状态\n      ```\n  \n    - 修补`main分支`后，如何在`dev分支`上进行同样的修改操作？\n  \n      ```she\n      git chery-pick <commit编号>\t//复制一个特定的提交到当前分支\n      ```\n  \n      \n\n## 多人协作\n\n- 当从远程仓库克隆时，实际上Git自动把本地的`main`分支和远程的`main`分支对应起来了，并且，远程仓库的默认名称是`origin`\n\n- 分支推送策略：\n  - `main`分支是主分支，因此要时刻与远程同步；\n  - `dev`分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；\n  - bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；\n  - feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。\n  \n- 工作模式：\n\n  1. 首先，可以试图用`git push origin <branch-name>`推送自己的修改；\n2. 如果推送失败，则因为远程分支比你的本地新，需要先用`git pull`试图合并；\n  \n   - 如果`git pull`提示`no tracking information`，则说明本地分支和远程分支的链接关系没有创建，用命令`git branch --set-upstream-to <branch-name> origin/<branch-name>`。\n  3. 如果合并有冲突，则解决冲突，并在本地提交；\n\n     - 用`git status`查看当前状态、寻找冲突的文件，手动修改\n4. 没有冲突或者解决掉冲突后，再用`git push origin <branch-name>`推送就能成功！\n\n## rebase ???\n\n- rebase操作可以把本地未push的分叉提交历史整理成直线；\n- rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。\n\n## 相关命令\n\n- `git remote`：查看远程库的信息\n  - `-v`：显示更详细的信息，显示可以抓取和推送的地址\n- `git push origin --delete <远程分支名>`：删除远程分支\n  - `git clone -b <指定分支名> <远程仓库地址>`：克隆远程库指定分支到本地库\n\n**扩展阅读**\n\n- [Git分支管理策略](http://www.ruanyifeng.com/blog/2012/07/git.html)\n\n","tags":["Github"],"categories":["Git学习"]},{"title":"6.自定义Git","url":"/2021/08/03/6.自定义Git/","content":"\n# \t自定义Git\n\n## 配置Git\n\n- `git config --global user.name \"xxx\"`\t配置每次提交记录名称\n  `git config --global user.email \"email@example.com\"`\t配置每次提交个人信息\n- `git config --global color.ui true`：让Git显示颜色\n\n## 忽略特殊文件\n\n- 忽略文件的原则是：\n\n\t1. 忽略操作系统自动生成的文件，比如缩略图等；\n\t2. 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的`.class`文件；\n\t3. 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。\n\n- 在Git工作区的根目录下创建一个特殊的`.gitignore`文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件\n\n  - 如果你确实想添加该文件，可以用`-f`强制添加到Git\n  - 或者你发现，可能是`.gitignore`写得有问题，需要找出来到底哪个规则写错了，可以用`git check-ignore`命令检查\n\n- `.gitignore`文件本身要放到版本库里，并且可以对`.gitignore`做版本管理！\n\n- 把指定文件排除在`.gitignore`规则外的写法就是`!`+文件名\n\n\n## 配置别名\n\n- `git config --global alias.<别名> <实际名字> `\n- 每个仓库的Git配置文件都放在`.git/config`文件中,别名就在`[alias]`后面\n\n## 搭建Git服务器\n\n搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的`apt`命令就可以完成安装。\n\n假设你已经有`sudo`权限的用户账号，下面，正式开始安装。\n\n- 第一步，安装`git`：\n\n```\n$ sudo apt-get install git\n```\n\n- 第二步，创建一个`git`用户，用来运行`git`服务：\n\n```\n$ sudo adduser git\n```\n\n- 第三步，创建证书登录：\n\n收集所有需要登录的用户的公钥，就是他们自己的`id_rsa.pub`文件，把所有公钥导入到`/home/git/.ssh/authorized_keys`文件里，一行一个。\n\n- 第四步，初始化Git仓库：\n\n先选定一个目录作为Git仓库，假定是`/srv/sample.git`，在`/srv`目录下输入命令：\n\n```\n$ sudo git init --bare sample.git\n```\n\nGit就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以`.git`结尾。然后，把owner改为`git`：\n\n```\n$ sudo chown -R git:git sample.git\n```\n\n- 第五步，禁用shell登录：\n\n出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑`/etc/passwd`文件完成。找到类似下面的一行：\n\n```\ngit:x:1001:1001:,,,:/home/git:/bin/bash\n```\n\n改为：\n\n```\ngit:x:1001:1001:,,,:/home/git:/usr/bin/git-shell\n```\n\n这样，`git`用户可以正常通过ssh使用git，但无法登录shell，因为我们为`git`用户指定的`git-shell`每次一登录就自动退出。\n\n- 第六步，克隆远程仓库：\n\n现在，可以通过`git clone`命令克隆远程仓库了，在各自的电脑上运行：\n\n```\n$ git clone git@<服务器地址>:/srv/sample.git\nCloning into 'sample'...\nwarning: You appear to have cloned an empty repository.\n```\n\n剩下的推送就简单了。\n\n### 管理公钥\n\n如果团队很小，把每个人的公钥收集起来放到服务器的`/home/git/.ssh/authorized_keys`文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用[Gitosis](https://github.com/res0nat0r/gitosis)来管理公钥。\n\n这里我们不介绍怎么玩[Gitosis](https://github.com/res0nat0r/gitosis)了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。\n\n### 管理权限\n\n有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。[Gitolite](https://github.com/sitaramc/gitolite)就是这个工具。\n\n这里我们也不介绍[Gitolite](https://github.com/sitaramc/gitolite)了，不要把有限的生命浪费到权限斗争中。\n","tags":["Github"],"categories":["Git学习"]},{"title":"LeetCode 1047","url":"/2021/07/28/LeetCode 1047/","content":"\n# LeetCode 1047\n\n## 概述\n\n- https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/\n- 从string中删除所有相邻且相同的字符，删除后继续重复操作\n\n## 思路\n\n- 想当于两个元素的匹配问题，考虑用栈\n\n  ```c++\n  class Solution {\n  public:\n      string removeDuplicates(string s) {\n          stack<char> sk;\n          for(int i=0;s[i];i++){\n              if(!sk.empty()&&sk.top()==s[i])  sk.pop();\t\t//这里要加非空判断，因为后续也可能出现栈为空的情况\n              else sk.push(s[i]);\n          }\n          string p=\"\";\n          while(!sk.empty()){\n              p+=sk.top();\n              sk.pop();\n          }\n          reverse(p.begin(),p.end());\n          return p;\n      }\n  };\n  ```\n\n  ","tags":["LeetCode刷题","C++"],"categories":["刷题记录"]},{"title":"LeetCode 454","url":"/2021/07/28/LeetCode 454/","content":"\n# LeetCode 454\n\n## 概述\n\n- https://leetcode-cn.com/problems/4sum-ii/\n- 给定四个数组，从四个数组中各选一个，相加等于0\n- 返回可选的组合的个数\n\n## 思路\n\n- 四个不同的数组中选，所以是各自独立的\n\n- 返回可选的组合的个数，只需进行记录即可\n\n- 综上，可以使用哈希法。考虑到四个数组，如果暴力求解大概率是超时，所以我们将两个数组的组合情况保存起来，再循环解决\n\n  ```c++\n  class Solution {\n  public:\n      int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n          unordered_map<int,int> mp1;\n          for(int a:nums1){\n              for(int b:nums2){\n                  mp1[a+b]++;\t\t//先记录两个数组的所有情况，因为最终结果只要数量，所以只要记录可以组合的值的数量即可\n              }\n          }\n         // unordered_map<int,int> mp2;\n         int count=0;\n          for(int a:nums3){\n              for(int b:nums4){\t//另外两个数组排列组合\n                  if(mp1.find(0-(a+b))!=mp1.end()){\t//找期望有的值\t\n                      count+=mp1[0-(a+b)];\n                  }\n              }\n          }\n          return count;\n   \n      }\n  };\n  ```\n\n  ","tags":["LeetCode刷题","C++"],"categories":["刷题记录"]},{"title":"LeetCode 239","url":"/2021/07/28/LeetCode 239/","content":"\n# LeetCode 239\n\n## 概述\n\n- https://leetcode-cn.com/problems/sliding-window-maximum/\n- 给定一个整形数组，固定滑动窗口长度，窗口从左到右每次滑动一个元素，返回每次窗口的最大值\n\n## 思路1\n\n- 滑动窗口的模拟，容易想到使用队列\n\n- 难点是如何找到每次窗口的最大值，如果在次窗口中暴力求解，O（N^2）会超时。考虑最好在每次窗口滑动时，就能确定最大值。\n\n- 找最大值需要比较排序，考虑==优先队列==可以确保每次最大值都在窗口的第一个。问题又来了，因为排序后数字的位置改变，每次移出窗口的数不一定是优先队列中最左边的数，如何来确认呢？\n\n- 因为我们只需要找到每次的最大值，**不需要关心队列里到底有哪些数字**。而最大值永远在优先队列的最左边，我们只需判断每次移动后，该最大值是否被移出队列即可。\n\n  每次移出窗口的数组下标是确定的，所以我们可以同时保存值和下标，这样就算排序后数组位置改变，我们还是可以确定是否目前的最大值是否被移出。\n\n  ```c++\n  class Solution {\n  public:\n      vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n          int n = nums.size();\n          priority_queue<pair<int, int> > q;\t\t//同时保存值和下标\n          for (int i = 0; i < k; ++i) {\n              q.emplace(nums[i], i);\t\n          }\n          vector<int> ans = {q.top().first};\n          for (int i = k; i < n; ++i) {\n              q.emplace(nums[i], i);\n              while (q.top().second <= i - k) {\t//i-k之前的数都是应该被移出的\n                  q.pop();\n              }\n              ans.push_back(q.top().first);\n          }\n          return ans;\n      }\n  };\n  //时间：O(nlogn) \t空间：O(n)\n  ```\n\n## 思路2\n\n- **其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了**\n\n  - 如果当前的滑动窗口中有两个下标 i 和 j，其中 i 在 j 的左侧（i < j），并且 i 对应的元素不大于 j 对应的元素（nums[i]≤nums[j]）\n  - 当窗口右移时，如果 i 还在窗口，j 一定在窗口，且此时最大值不可能是nums[i]\n  - 按照上述分析，所有num[i]就可以不用保存在队列中了\n\n- \n\n  ```c++\n  class Solution {\n  public:\n      vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n          int n = nums.size();\n          vector<int> result;\n          deque<int> dq;\n          for(int i=0;i<k;i++){\n              while(!dq.empty()&&nums[i]>dq.back()){\t//按上述分析 保存特定顺序下的窗口元素\n                  dq.pop_back();\n              }\n              dq.emplace_back(nums[i]);\n          }\n         result.push_back(dq.front());\t//第一个窗口的最大值\n         for(int i=k;i<n;i++){\n          if(!dq.empty()&&nums[i-k]==dq.front())\t//num[i-k]是窗口该移出的元素，判断是否等于队列最前面的值，如果相等则表示其会被移出窗口\n              dq.pop_front();\t\t\twhy???\n          while(!dq.empty()&&nums[i]>dq.back())\t//只要添加数字进窗口都进行该操作\n              dq.pop_back();\n              dq.emplace_back(nums[i]);\n          result.emplace_back(dq.front());    //每次移动完后，队列最前面的值，就是此时窗口的最大值  why??\n         }\n         return result;\n      }\n  };\n  \n  \n  ```\n\n- ==有两处问题需要考虑==","tags":["LeetCode刷题","C++"],"categories":["刷题记录"]},{"title":"LeetCode 142","url":"/2021/07/28/LeetCode 142/","content":"\n# LeetCode 142\n\n## 概述\n\n- 在一个链表中，确定是否有环。如果有，确定环的起始结点位置\n\n## 思路\n\n- 确定有环：快慢指针法\n\n- 确定环起始位置：![环](\\所有图片\\环.png)\n\n  ```\n  (x+y)*2=(x+y)+n(y+z)\t//这里n(y+z)是快指针多走的\n  x=n(y+z)-y=(n-1)(y+z)+z\t//x是我们要求的\n  注意到（n-1)(y+z)是环的长度，z、x分别拿出来看就可知道如何找到入口\n  ```\n\n  ---\n\n  ```c++\n  class Solution {\n  public:\n      ListNode *detectCycle(ListNode *head) {\n          if(head==NULL) return NULL;\n          ListNode* slow=head;\n          ListNode* fast=head;\n          int flag=0;\n          while(fast != NULL && fast->next != NULL){\t//注意判断\n              slow=slow->next;\t//慢指针\n              fast=fast->next->next;\t//快指针\n              if(slow==fast){ //有环\n                  flag=1;\n                  break;\n              }    \n          }\n          //这部分，可以直接放在前面的if里面的\n          if(flag==0) return NULL;\n          ListNode* temp=head;\n          while(temp!=fast){\n              fast=fast->next;\n              temp=temp->next;\n          }\n          return temp;\n      }\n  };\n  ```\n\n  \n","tags":["LeetCode刷题","C++"],"categories":["刷题记录"]},{"title":"LeetCode 76","url":"/2021/07/28/LeetCode 76/","content":"\n# LeetCode 76\n\n## 概述\n\n​\t题目要求在一个字符串中找到包含另一个字符串所有字符（包括重复字符）的最短子序列\n\n## 思路\n\n- 子序列问题，考虑==滑动窗口==思想\n\n  ```c++\n  string minWindow(string s, string t) {\n          int l1=s.length(),l2=t.length();  //获得字符串长度\n      \t//做准备，能想d\n          vector<int> mp(128,0);\n          for(int j=0;j<t.length();j++)\n          \tmp[t[j]]++;\n  \t\tint kind=l2;\n  \n          int i=0;\t\n      \t//保存每次结果和最终结果\n          int result=INT_MAX;\n  \t\tstring str=\"\";\n  \t\tstring str2=\"\";\n          for(int j=0;j<l1;j++){\n              //窗口滑动操作\n          \tstr+=s[j];\t//记录窗口目前数据\n  \t\t\tif(mp[s[j]]>0){\t\t//窗口滑动对之后操作影响的记录\n  \t\t\t\tkind--;\n  \t\t\t}\n  \t\t\tmp[s[j]]--;\n  \t\t\t \n              while(kind==0){\t\t//临界情况\n              \t\n  \t\t\t\tint ans=j-i+1;\n  \t\t\t\tstr2=result>ans?str:str2;\n  \t\t\t\tresult=result>ans?ans:result;\n                  //窗口起始位置向前滑动对记录的影响\n  \t\t\t\tmp[s[i]]++;\n  \t\t\t\tif(mp[s[i]]>0){\n  \t\t\t\t\tkind++;\n  \t\t\t\t}\n  \t\t\t\tstr.erase(0,1);\n  \t\t\t\ti++;\n  \t\t\t\t\n              }\n          }\n          return str2;\n      }\n  ```\n\n- 对于此题，也可以不用每次记录窗口中的字符串，因为最后可以得到最终窗口的起始、终止位置。\n\n- 对于此题，还可优化，窗口起始位置可以不用每次只滑动一次，可以直接将窗口前面和目标字符串无关的位置全部移动后再做进一步判断\n\n","tags":["LeetCode刷题","C++"],"categories":["刷题记录"]},{"title":"LeetCode 69","url":"/2021/07/28/LeetCode 69/","content":"\n# LeetCode 69\n\n## 概述\n\n​\t模拟sqrt函数实现\n\n## 思路\n\n- 对于一个整数的平方根，除了几个特殊情况，可以验证<=x/2。这里强调是整数，所以2,3仍然符合，而0,1则要特殊处理。\n\n- 使用二分法，while循环中的if条件要注意，如果mid*mid>x,那么结果在mid之后；反正则不一定\n\n  ```c++\n  int mySqrt(int x) {\n  \tif(x==0)\treturn 0;\n      if(x==1)\treturn 1;\n      int start=1;\n      int end=x/2;\n      int ans=-1;\n      while(end>=start){\t\n          int mid=start+(end-start)/2;\n          if((long long)mid*mid>x)\t//比x大，那么一定在前面\n              end=mid-1;\n          else{\t//<=x，不一定先记录下来\n              ans=mid;\t//可能的结果先保存下来，所以end可以等于start\n              start=mid+1;\t//继续二分\n          }\n      }\n      return ans;\n  ```\n\n- 如果不用x/2,那么就不需要特殊情况单独处理\n\n  ```c++\n  int mySqrt(int x) {\n      int start=0;\n      int end=x;\t//v\n      int ans=-1;\n      while(end>=start){\n          int mid=start+(end-start)/2;\n          if((long long)mid*mid>x)\n              end=mid-1;\n          else{\n              ans=mid;\n              start=mid+1;\n          }\n      }\n      return ans;\n   }\n  ```\n\n  \n\n","tags":["LeetCode刷题","C++"],"categories":["刷题记录"]},{"title":"LeetCode 59","url":"/2021/07/28/LeetCode 59/","content":"\n# LeetCode 59\n\n## 概述\n\n​\t输入n，在n*n的矩阵中，从左上角开始，逆时针填入数字1-n^2^,然后输出矩阵\n\n## 思路\n\n- 首页，应该能知道这题是一个模拟题\n\n- 手动模拟操作，可以发现，顺序上-右-下-左都是一样的，只是规模再变小。所以一次大循环里面，应该是把四个方向的任务完成。\n\n- 还要注意的是边界的选取，因为上-右、右-下、下-左，均是存在一个重叠的数字的。这里选择左闭右开，是因为每次处理一个方向后，循环变量还会加一，\n\n  所以干脆直接将加一利用起来，再之后的方向继续使用，减少操作\n\n  ```c++\n  vector<vector<int>> generateMatrix(int n) {\n          vector<vector<int> > result(n, vector<int>(n, 0));\n          int loop=n/2;\t//一次一圈，所以除2\n          int startx=0,starty=0;\t//记录起始位置\n          int i,j;\n          int ans=1;\t//数字增量\n          int offset=1;\t//相同循环操作的偏移量\n          while(loop--){\n              i=startx;\t\n              j=starty;\n              for(;j<n-offset+startx;j++)\t//注意j的范围是要有偏移量的\n                  result[i][j]=ans++;\n  \t\t\t//因为采用左闭右开，所以j最后加出来的数，可以在下面的循环里直接用\n              for(;i<n-offset+startx;i++)\n                  result[i][j]=ans++;\n                  \n              for(;j>starty;j--)\n                  result[i][j]=ans++;\n             \n              for(;i>startx;i--)\n                  result[i][j]=ans++;\n              //下一轮作准备\n              startx++;\n              starty++;\t//起始位置改变\n              offset+=2;\t//偏移量改变\n          }\n           if (n%2) {\t\t//n是奇数，则存在一个正中间数会少loop一次，需要额外处理\n              result[n/2][n/2] = ans;\n          }\n          return  result;\n      }\n  ```\n\n  ","tags":["LeetCode刷题","C++"],"categories":["刷题记录"]},{"title":"LeetCode 34","url":"/2021/07/28/LeetCode 34/","content":"\n# \tLeetCode 34\n\n## 概述\n\n​\t题目给定一个升序数组，又要求时间复杂度O(log n)算法，考虑==二分==解决\n\n## 思路1\n\n- 一般二分查找，只能找到其中一个target，现在要找target在数组中的开始位置和终止位置，考虑每次找到后将数组分成左右两个，那么开始、终止位置也就可能在左右两边。\n\n- 对左右两边，可以继续二分查找，直到找不到停止。到这里，考虑==递归==思想。\n\n- 对于递归函数，**返回值应该就是最终的结果**，还要注意临界条件。\n\n  ```c++\n  class Solution {\n  public:\n       vector<int> find(vector<int>& nums,int target,int l,int r){\t//这里l,r就是用来记录最终结果用\n           while(r>=l){  \n           \tint mid=(l+r)/2;\n              if(nums[mid]>target)\n                  r=mid-1;\n              else if(nums[mid]<target)\n                  l=mid+1;\n              else{\t//找到一个边界target\n                  if(nums[l]!=target)\t//如果最左边不等于target\n                      l=find(nums,target,l+1,mid)[0];\t//左边往后移动，只取数组第一个结果\n                  if(nums[r]!=target)\t//如果最右边不等于target\n                      r=find(nums,target,mid,r-1)[1];\t//右边后前移动\n                  return vector<int>{l,r};\n              }\n          }\n           //如果找不到 \n          return  vector<int>{-1,-1};\n      }\n      vector<int> searchRange(vector<int>& nums, int target) {\n          return find(nums,target,0,nums.size()-1);\n      }\n  };\n  ```\n\n  \n\n## 思路二\n\n- 考虑到传入的是vector<int>类型，而c++STL中存在一个==二分查找==的算法`equal_range`,可以使用该函数\n- ==equal_range==：试图在已排序的[first,last)中寻找value，它返回一对迭代器i和j，其中i是在不破坏次序的前提下，**value可插入的第一个位置（亦即lower_bound）**，j则是在不破坏次序的前提下，**value可插入的最后一个位置（亦即upper_bound）**\n\n```c++\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        auto bound=equal_range(nums.begin(),nums.end(),target);\n        if(bound.first==bound.second)   return {-1,-1};\t//两个迭代器 first second\n        return {(int)(bound.first-nums.begin()),(int)(bound.second-nums.begin())-1};\t//通过迭代器相减 q\n    }\n};\n```\n\n","tags":["LeetCode刷题","C++"],"categories":["刷题记录"]},{"title":"LeetCode 19","url":"/2021/07/28/LeetCode 19/","content":"# LeetCode 19\n\n## 概述\n\n## 思路\n\n","tags":["LeetCode刷题","C++"],"categories":["刷题记录"]},{"title":"LeetCode 18","url":"/2021/07/28/LeetCode 18/","content":"# LeetCode 18\n\n## 概述\n\n- https://leetcode-cn.com/problems/4sum/\n- 给你一个数组和一个目标值target，判断数组中是否能找到四个不同位置的值相加等于target\n- 答案中不包含重复的集合\n\n## 思路\n\n- 和之前[3Sum](LeetCode 15.md)基本相同，只是需要四个数字\n\n- 指针数：2个活动指针+2个固定移动指针\n\n  ```c++\n  class Solution {\n  public:\n      vector<vector<int>> fourSum(vector<int>& nums, int target) {\n          vector<vector<int>> result;\n          sort(nums.begin(),nums.end());\n          int L=nums.size();\n          for(int i=0;i<L;i++){\n              //if(nums[i]>target)  continue;\t这个剪枝是错误的\n              if(i>0&&nums[i]==nums[i-1]) continue;\t//相同的去重操作\n              for(int j=i+1;j<L;j++){\t\t\t//两个固定指针，两重循环\n                  if(j>i+1&&nums[j]==nums[j-1]) continue;\t\t//注意一下第二重循环的去重条件\n                  int left=j+1;\n                  int right=L-1;\n                  while(right>left){\n                      if((long long )nums[i]+nums[j]+nums[left]+nums[right]>target)\t//这里的类型v\n                          right--;\n                      else if((long long )nums[i]+nums[j]+nums[left]+nums[right]<target)\n                          left++;\n                      else{\n                          result.push_back(vector<int>{nums[i], nums[j], nums[left],nums[right]});\n                          while(nums[right]==nums[right-1]&&right>left) right--;\n                          while(nums[left]==nums[left+1]&&right>left) left++;\n                          right--;\n                          left++;\n                      }\n                  }\n              }\n          }\n          return result;\n      }\n  };\n  ```\n\n  ​\t\n\n​\t\n\n\n\n","tags":["LeetCode刷题","C++"],"categories":["刷题记录"]},{"title":"LeetCode 15","url":"/2021/07/28/LeetCode 15/","content":"\n# LeetCode 15\n\n## 概述\n\n- https://leetcode-cn.com/problems/3sum\n- 从一个数组中，找到所有的三个不同位置的数字，相加等于0\n- 返回所有的相加等于0的三个数字，且结果不重复\n\n## 思路\n\n- 理解题目要求，三个数字位置要不同,三个数字组成的结果不重复，最后按组返回所有的三个数字\n\n- 返回最终集合不能重复，所以这题不好用哈希法，因为哈希会把所有的结果都选出来，那么就可能三个数字组成的集合是重复的\n\n  所以，考虑多指针法，而正好题目只需我们返回最终的值，那么可以将数据排序\n\n- 如何确定指针数？\n\n  - 首页一个排好序的数组，指针的移动方向就两个——前、后，所以移动指针可以有两个\n  - 这题要求选三个，所以我们当然要选三个指针指向最终的结果\n  \n- 如何去重？\n\n  - 因为排好序，所以相同的数据都集中在一起，只需判断此时的数据和之前的数据是否相同\n\n    如果相同，则不处理该数据；\n\n\n  ```c++\n  class Solution {\n  public:\n      vector<vector<int>> threeSum(vector<int>& nums) {\n          vector<vector<int>> result;\n          sort(nums.begin(),nums.end());\t//排序\n          int L=nums.size();\n          for(int i=0;i<L;i++){\n              if(nums[i]>0)\t//剪枝\n                  break;\n              int j=i+1;\n              int k=L-1;\n              if(i>0&&nums[i]==nums[i-1]) continue;\t//去重\n              while(k>j){\n                  if(nums[i] + nums[j] + nums[k]>0)\t//移动指针\n  \t\t\t\t\tk--;\n  \t\t\t\telse if(nums[i] + nums[j] + nums[k]<0)\n  \t\t\t\t\tj++;\n  \t\t\t\telse{\n  \t\t\t\t\tresult.push_back(vector<int>{nums[i], nums[j], nums[k]});\t//获得结果\n  \t\t\t\t\twhile(nums[k]==nums[k-1]&&k>j)   k--;\t//去重\n                      while(nums[j]==nums[j+1]&&k>j)   j++;\n  \t\t\t\t\t//继续寻找\n                      j++;\n                      k--;\n  \t\t\t\t}\n              }\n  \n          }\n          return result;\n      }\n  };\n  ```\n\n  \n\n  ","tags":["LeetCode刷题","C++"],"categories":["刷题记录"]},{"title":"LeetCode 1","url":"/2021/07/28/LeetCode 1/","content":"\n# LeetCode 1\n\n## 概述\n\n- https://leetcode-cn.com/problems/two-sum/\n- 给定一个整数数组和一个target,从数组中选择两个相加等于target的值，返回选择的两个的数组下标\n- 同一个元素不能被重复选,且只会有一个结果\n\n## 思路\n\n- 返回下标，说明不能排序，那么不能使用多指针法；\n\n- 题目只是要求，同一个元素不能被重复选，并没有说最终结果中不能有重复的元素，所以可以使用哈希法或`find()`函数\n\n  ```c++\n  //方法一 find()函数找，时间复杂度高\n  vector<int> twoSum(vector<int>& nums, int target) {\n      for(int i=0;i<nums.size();i++){\n          int temp=target-nums[i];\n          auto index=find(nums.begin(),nums.end(),temp);\n          int t=index-nums.begin();\n          if(index!=nums.end()&&t!=i){\t//确保不是同一元素\n              return {i,t};\n          }\n      }\n      return {0,0};\n  \t}\n  ```\n\n  ```c++\n  //方法二 哈希法\n  vector<int> twoSum(vector<int>& nums, int target) {\n      unordered_map<int,int> mp;\n      for(int i=0;i<nums.size();i++){\n          mp[nums[i]]=i+1;    //记录索引，这题题目明确说 只有一个答案才可以这样做的\n      }\n      for(int i=0;i<nums.size();i++){\n          int temp=mp[target-nums[i]];\n          if(temp!=0&&temp-1!=i){     /\n              return {i,temp-1};\n          }\n      }\n      return {};\n  }\n  ```\n\n  ```c++\n   /*官方题解 哈希\n   注意和自己的方法二的不同，方法二是针对此题明确一个答案才可以那样。\n   因为法二在记录索引是，相同的nums[i]的值会被覆盖，之会存在一个索引。\n   但是，因为只有一个答案，所以如果有相同的值，那么要么是用不到的，要么一定是两个相同值就是最终的答案；否则不可能只有一个解\n   */\n  vector<int> twoSum(vector<int>& nums, int target) {\n          unordered_map<int, int> hashtable;\n          for (int i = 0; i < nums.size(); ++i) {\n              auto it = hashtable.find(target - nums[i]);\n              if (it != hashtable.end()) {\n                  return {it->second, i};\n              }\n              hashtable[nums[i]] = i;\n          }\n          return {};\n      }\n  ```","tags":["LeetCode刷题","C++"],"categories":["刷题记录"]},{"title":"c++函数使用记录","url":"/2021/07/28/c++函数使用记录/","content":"\n# c++函数使用记录\n\n## STL 函数\n\n- `equal_range()`：一个==二分查找==的算法，试图在==已排序==的[first,last)中寻找value，它返回一对==迭代器i和j==。\n\n  - 如果该键值在==容器==中存在，则i是在**不破坏次序的前提下**，value可插入的第一个位置（亦即lower_bound），j是在**不破坏次序的前提下**，value可插入的最后一个位置（亦即upper_bound）；如果找不到，则i,j都指向此键值应该插入的位置。\n\n  - C++11 简便写法 `auto bounds = equal_range(nums.begin(), nums.end(), target);`\n\n  - 可以将其看做`lower_bound`和`upper_bound`的结合\n\n  - `vector map`都可以用 \n\n    ```c++\n    vector: equal_range(nums.begin(), nums.end(), target);\n    map:\n    ```\n\n- `distance()`：计算迭代器之间的距离\n\n  ```c++\n  int dis=distance(nums.begin(),nums.end()\n  ```\n\n- `remove()`：移除区间{beg,end)中每一个“与value相等”的元素。最后remove返回指向“目标数列”的end()的迭代器\n\n  - 只会移动元素，并且也不是将vlaues移到最后面去\n\n  ```c++\n  vcetor:remove(nums.begin(),nums.end(),value);\n  ```\n\n- `Remove_if()`：移除区间[beg,end)中每一个“令判断式获得true”的元素\n\n  ```c++\n  bool isValue(int x) { return x==target; }\n  vcetor:remove(nums.begin(),nums.end(),isValue);\n  ```\n\n- `erase()`:删除==容器==中的某些元素，返回经过删除操作后的容器\n\n  ```c++\n  erase(iter);\n  erase(iter.begin,iter.end)\t/** iter代表迭代器 **/\n  ```\n\n- `fill()`：为某容器某个区间赋相同值\n\n  ```c++\n  vcetor:fill(nums.begin(),nums.end(),0);\n  ```\n\n- `find(first, end, value)`：返回区间[first，end）中第一个值等于value的元素位置；若未找到，返回end。函数返回的是迭代器或指针，即位置信息\n\n  - 如果查找整个区间，可以直接`xx.find(value)`\n\n- `reverse(begin,end)`：反转\n  - 多用于string、vector\n  \n- `replace(begin,end,x,xx)`:在容器[being,end)范围内，将所有的x替换为xxx\n\n  - `replace_if(being,end,条件判断,xxx)`\n\n## String 函数\n\n- `str.replace()`\n\n  ```c++\n  str.replace(pos,2,\"#\")\t//从位置pos开始的两个字符替换成#\n  str.replace(begin(),end(),\"#\")\t//[begin,end)的字符替换成\"#\"\n  ```\n\n- `str.substr(begin,length)`：从索引begin开始，截取长度为length的字符\n\n- `stoi(stirng s)`：将用字符串表示的数字转换为`Int`\n\n  - 非数字字符转换会报错\n","tags":["LeetCode刷题","C++函数"],"categories":["刷题笔记"]},{"title":"语法总结","url":"/2021/07/28/语法总结——队列/","content":"\n# 语法总结——队列\n\n## 队列\n\n\n\n\n\n## 优先队列\n\n### 头文件\n\n`#include<queue>`\n\n### 特点\n\n- 在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征\n- 优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，**它本质是一个堆实现的**\n\n### 定义\n\n```c++\n/*\nType： 数据类型\nContainer: 容器类型（必须是用数组实现的容器，vector,deque等，不能用List）\nFunctional: 比较的方式\n*/\npriority_queue<Type, Container, Functional>\n```\n\n- 对于基本类型，默认使用大顶堆\n\n- 示例:\n\n  ```c++\n  priority_queue<int> a;\n  priority_queue <int,vector<int>,greater<int> > q;\t//主动声明 小顶堆\n  priority_queue<string> b\n  priority_queue<pair<int, int> > a\t//pair先比较第一个\n  ```\n\n  \n\n### 基本操作函数\n\n| 函数  | 作用                    |\n| :---- | ----------------------- |\n| top   | 访问队头元素            |\n| empty | 队列是否为空            |\n| size  | 返回队列内元素个数      |\n| push  | 插入元素到队尾 (并排序) |\n| pop   | 弹出队头元素            |\n| swap  | 交换内容                |\n\n### 进阶操作\n\n- 自定义类型\n\n  ```c++\n  //方法1\n  struct tmp1 //运算符重载<\n  {\n      int x;\n      tmp1(int a) {x = a;}\n      bool operator<(const tmp1& a) const\t\t//注意这里重载 <\n      {\n          return x < a.x; //大顶堆\n      }\n  };\n  \n  //方法2\n  struct tmp2 //重写仿函数\n  {\n      bool operator() (tmp1 a, tmp1 b)\t\t//这里重载()\n      {\n          return a.x < b.x; //大顶堆\n      }\n  };\n  \n  int main()\n  {\n      tmp1 a(1);\n      tmp1 b(2);\n      tmp1 c(3);\n      priority_queue<tmp1> d;\n      d.push(b);\n      d.push(c);\n      d.push(a);\n      while (!d.empty())\n      {\n          cout << d.top().x << '\\n';\n          d.pop();\n      }\n      cout << endl;\n  \n      priority_queue<tmp1, vector<tmp1>, tmp2> f;\n      f.push(b);\n      f.push(c);\n      f.push(a);\n      while (!f.empty())\n      {\n          cout << f.top().x << '\\n';\n          f.pop();\n      }\n  }\n  ```\n\n  \n\n\n\n\n\n**扩展阅读**\n\n- [c++优先队列(priority_queue)用法详解](https://blog.csdn.net/weixin_36888577/article/details/79937886)\n","tags":["C++队列"],"categories":["刷题笔记"]},{"title":"语法总结——C++11","url":"/2021/07/28/语法总结——C++ 11/","content":"\n# 语法总结——C++ 11\n\n## 使用emplace操作\n\n| 新函数           | 对应之前函数    |\n| ---------------- | --------------- |\n| emplace(i, type) | insert(type, i) |\n| emplace_front    | push_front      |\n| emplace_back     | push_back       |\n\n- emplace是构造而不是拷贝元素，不需要拷贝或者移动内存。\n\n  - 如果元素是基本类型，新特性就没有体现，也就没有优势\n\n- 所有的标准库容器（array除外，因为它的长度不可改变，不能插入元素）都增加了类似的方法\n\n- 使用示例\n\n  ```c++\n  S.push_back(data(1,2))\t//让其构造函数构造好了对象之后，再使用复制构造函数\n  S.emplace(1,2)\t//emplace这样接受新对象的时候，自己会调用其构造函数生成对象然后放在容器内（比如这里传入了1，2，它则会自动调用一次data(1,2))\n  ```\n\n  \n\n","tags":["C++ 11"],"categories":["刷题笔记"]},{"title":"刷题总结——字符串的各种反转及应用","url":"/2021/07/28/刷题总结——字符串的各种反转及运用/","content":"\n# 刷题总结——字符串的各种反转及运用\n\n","tags":["LeetCode刷题","C++"],"categories":["刷题笔记"]},{"title":"刷题总结——字符串KMP算法分析与应用","url":"/2021/07/28/刷题总结——字符串的KMP算法分析与使用/","content":"\n# 刷题总结——字符串的KMP算法分析与应用\n\n## 概述\n\n- KMP的经典思想就是：**当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。**\n  - 如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任\n- ==next数组==：前缀表（*prefix table*）\n  - 前缀表是用来回退的，它记录了模式串(与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配\n  - 记录下标i之前（包括i）的字符串中，有多大长度的相同**前缀后缀**\n- 最长相等前后缀\n  - ==前缀==：指**不包含最后一个字符**的所有以第一个字符开头的连续子串\n  - ==后缀==：指**不包含第一个字符**的所有以最后一个字符结尾的连续子串\n  - **前缀表要求的就是相同前后缀的长度**\n\n## 如何构造前缀表和next数组\n\n- 前缀表中记录了模式串中每个位置从 [0,位置] 的最长相等前后缀的长度\n\n  - 前缀表的长度等于模式串\n\n- 当在 模式表i 处发生不匹配时，只需找到前缀表中i-1的位置处的值，即可知道下次匹配从`模式表[前缀表[i-1]]`处开始\n\n- 为了简便，通常会将前缀表向右移动并赋初值为-1，得到`next数组`,这样下次匹配就是`模式表[next[i]]`\n\n  ```c++\n  /*构造nextu\n  1. 初始化\n  2. 处理前后缀不同的情况\n  3. 处理前后缀相同的情况\n  整个算法有点动态规划的味道，在前一段完成的基础上，获得下一段的情况\n  */\n  void getNext(int* next, const string& s) {\n  \tnext[0] = -1;\t//先给next[0]赋初值,必定是-1\n      int j = 0;\t\t\n  \tint k=-1;\t\t//记录s[0]-s[j-1]最长相等前缀的后一个位置\n     \twhile(j<s.length()-1){\t\t//因为我们是使用右移的next数字，所以循环的j实际上是给j+1赋值\n      \tif(k==-1||s[j]==s[k]){\t\t//这里加k==-1这个条件，实际上也是一个给next[1]赋初值的条件，因为s[1]不匹配的话，只能用s[0]l来匹配，\n      //如果s[j+1]不匹配,考虑0-j的字符串,当s[k]==s[j]时,0-j字符串的k应该是k+1，所以s[j+1]=k+1（之后为了下次循环，k，j也要往前移动一位）\n              j++;k++;\n           \tnext[j]=k;\t\n          }else{\t\t\t\t\t\t\n          //如果s[j+1]不匹配时，考虑0-j的字符串，当s[j]!=s[k]，0-j的最长相等前缀位置不是k(因为k是0-j-1的)，所以要更新这次的k。因为k是0-j-1的最长相等前缀的后一个位置，所以s[j]!=s[k]最长前缀只可能在0-k-1中出现，那么next[k]就应该是下一个去匹配的位置，进入下一次循环判断直到有s[k]==s[j],那么此时的k就是0-j处的最长前缀的后一个位置\n              k=next[k];\n          }    \n      }\n  }\n  ```\n\n## 题目练习\n\n### 在一个串中查找是否出现过另一个串\n\n- [28.Implement strStr()](https://leetcode-cn.com/problems/implement-strstr/)\n\n  - next数组可以优化\n\n    ```c++\n    next[j]=s[j]!=s[k]?k:next[k]//next数组优化，避免s[j+1]发生不匹配时，下一个s[next[j+1]]==s[j+1]继续不匹配，需要继续往下匹配\n    ```\n\n- \n\n\n\n\n\n**扩展阅读**\n\n- [详解KMP算法](https://www.cnblogs.com/yjiyjige/p/3263858.html)\n\n","tags":["LeetCode刷题","C++"],"categories":["刷题笔记"]},{"title":"刷题总结——多指针法","url":"/2021/07/28/刷题总结——多指针法/","content":"\n# 刷题总结——多指针法\n\n## 概述\n\n- **双指针法基本都是应用在数组，字符串与链表的题目上**\n- 一般题目要求空间复杂度为O(1)，但要对数组等进行操作，可以考虑使用该方法\n\n## 思路\n\n- 一般常用的双指针法：\n  - 快慢双指针：同一方向移动，但是速度不同\n  - 前后双指针：不同方向移动\n  - 工作指针+标识指针：标识指针的移动取决于工作指针\n- 特殊情况下也有多指针法，需要具体问题具体分析\n\n## 题目练习\n\n### 数组——移除元素\n\n工作指针+标识指针\n\n- [27.Remove Element]([26. Remove Duplicates from Sorted Array](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/))\n- [26.Remove Duplicates from Sorted Array]([26. Remove Duplicates from Sorted Array](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/))---2021.7.3\n- [283.Move Zeroes](https://leetcode-cn.com/problems/move-zeroes/)\n- [844.Backspace String Compare](https://leetcode-cn.com/problems/backspace-string-compare/)---2020.7.5\n- [977.Squares of a Sorted Array](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)\n\n","tags":["LeetCode刷题","C++"],"categories":["刷题笔记"]},{"title":"刷题总结——多数想加（减）等于特定值","url":"/2021/07/28/刷题总结——多数相加（减）等于特定值/","content":"\n# 刷题总结——多数相加（减）等于特定值\n\n## 概述\n\n- 存在一类题目，给你一些数组（可能是一个，也可能是多个），给你一个`target`，要求你从给定的数据中，选择一些数相加（减）等于`target`\n\n## 思路\n\n- 这类算是排列组合题。如果暴力求解，就直接多重循环将数字排列组合验证即可(一般会超时)\n- 但是考虑到已知`target`,我们可以**先排列组合部分获得值**，然后根据结果去找接下来需要应该要获得的值\n- 重点就是如何确定数据中是否存在应该要获得的值\n  - 一种情况，可以利用`find()函数`\n    - `STL find()`时间复杂度是`O(n)`\n    - `map、set`成员函数`find()`是`O(logn)`\n  - 另一种情况，可以利用哈希，空间换时间，缩小时间复杂度\n    - 先将排列组合的值保存下来，减少循环层数\n- 此类题目可能存在的不同要求：\n  1. 最终结果获得的值不能重复：那么在找的过程中，**要确保找到的数字是之前部分结果中没有使用过的**，此时哈希法不太好用，可以考虑多指针法\n     - 多指针法，一般要对数据进行排序，所以也不适用需要最后返回索引的问题\n\n## 题目分析\n\n### 同一集合中找数据+返回数据索引\n\n- [1.Two Sum](LeetCode 1.md/)\n\n### 同一集合中找数据+返回结果数值\n\n- [15.3Sum](LeetCode 15.md)\n- [18.4Sum](https://leetcode-cn.com/problems/4sum/)\n\n### 不同集合中找数据+返回结果数量\n\n- [454.4Sum II]()\n\n","tags":["LeetCode刷题","C++"],"categories":["刷题笔记"]},{"title":"刷题记录——LeetCode","url":"/2021/07/28/刷题记录——LeetCode/","content":"\n# 刷题记录——LeetCode\n\n## 数组\n\n### 二分法\n\n**适用情况**\n\n- 在一组有序数字中，进行查找操作\n\n**注意**\n\n- 根据不同的情况，要对while的循环条件和里面的if选择条件进行修改\n\n**基本格式**\n\n```c++\n```\n\n\n\n**题目练习**\n\n- [704. Binary Search](https://leetcode-cn.com/problems/binary-search/)\n- [35. Search Insert Position](https://leetcode-cn.com/problems/search-insert-position/)\n- [34. Find First and Last Position of Element in Sorted Array](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)(==题解==)---2021.7.1\n- [69. Sqrt(x)](https://leetcode-cn.com/problems/sqrtx/)（==题解==）----2021.7.2\n- [367. Valid Perfect Square](https://leetcode-cn.com/problems/valid-perfect-square/)---2021.7.3\n\n### 快慢指针法----移除元素\n\n**适用情况**\n\n- 在有序数组中，需要移动元素位置（包括移除、移动元素）\n\n**注意**\n\n- 不同的移除条件，循环里有不同的写法\n\n**题目练习**\n\n- [27.Remove Element]([26. Remove Duplicates from Sorted Array](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/))\n- [26.Remove Duplicates from Sorted Array]([26. Remove Duplicates from Sorted Array](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/))---2021.7.3\n- [283.Move Zeroes](https://leetcode-cn.com/problems/move-zeroes/)\n- [844.Backspace String Compare](https://leetcode-cn.com/problems/backspace-string-compare/)---2020.7.5\n- [977.Squares of a Sorted Array](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)\n\n### 滑动窗口\n\n**适用情况**\n\n- 查找连续子数组问题，不断的调节子序列的起始位置和终止位置，从而得出我们想要的结果\n- 特殊情况也可使用前缀和思想\n\n**注意**\n\n- 根据要求，设计每次窗户扩展后的处理方法非常关键\n\n**模版**\n\n```c++\n根据题目，for循环内窗口扩展操作作准备\nint i=0;\t//窗口起始位置\nint result=？\t\t//看情况初值（最大或最小），保存每次结果和最终结果\nfor（int j=0;j<size;j++){\t//滑动窗口开始扩展\n    根据题目要求，设计每次窗户扩展的处理操作并保存记录\n    while(窗口操作后的记录的临界情况){\t//记录数据，并开始滑动窗口\n        int ans=j-i+1;\t//此时窗口大小\n        result=result>ans?result:ans;\t//根据要求写判断逻辑\n        窗口起始位置向前滑动后对记录的影响\n        i++;\t//窗口起始位置向前滑动\n    }\n}\n```\n\n**题目练习**\n\n- [209.Minimum Size Subarray Sum](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)---2021.7.6\n  - 前缀和 O(nlogn)\n- [904.Fruit Into Baskets](https://leetcode-cn.com/problems/fruit-into-baskets/)--2021.7.7\n- [76.Minmum Window Substring](https://leetcode-cn.com/problems/minimum-window-substring/)(==题解==)---2021.7.8\n\n### 其它\n\n- [59.Spiral Matrix II](https://leetcode-cn.com/problems/spiral-matrix-ii/)(==题解==)---2021.7.9\n\n## 链表\n\n==用while循环遍历链表时，要根据自己的处理逻辑，选择是用`while(node->next)`还是`while(node)`，一般来说如果能确定进入循环前的node必有值的话，就用前一个，否则用后一个==\n\n### 虚拟头结点\n\n**适用情况**\n\n- 一般来说，如果对单链表进行操作，除头结点外结点操作基本相同，那么可以添加一个虚拟头结点，使得原头结点变成子节点，统一操作\n\n**注意**\n\n- 工作指针指向虚拟头结点后，要从node->next开始判断\n- 返回vir_head->next才是真正头指针\n\n**模板**\n\n```c++\nListNode* vir_head=new ListNode();\t//初始化虚拟结点\nvir_head->next=head;\t//构造虚拟头结点\nListNode* node=vir_head;\t//工作指针从虚拟结点开始\n```\n\n**题目练习**\n\n- [203.Remove Linked List Elements](https://leetcode-cn.com/problems/remove-linked-list-elements/)\n- [707.Design Linked List](https://leetcode-cn.com/problems/design-linked-list/)---2021.7.10\n- [24.Swap Nodes in Pairs](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)---2021.7.12\n\n### 链表翻转\n\n**方法**\n\n- 头插法：新建一个虚拟头结点，利用头插法构造逆序链表\n- 双指针法：利用前后指针，将next的指向逆转过来\n\n**题目练习**\n\n- [206.Reverse Linked List](https://leetcode-cn.com/problems/reverse-linked-list/)(==笔记==)---20217.11\n\n### 双指针法——一遍找倒数位置元素\n\n**注意**\n\n- 要确定last、fast指针的距离，以及要选择最后fast是走到最后一个位置处，还是走到null处时，此时的fast的位置到底是不是符合要求的\n\n**题目**\n\n- [19.Remove Nth Node From End of List](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)（==笔记==）---2021.712\n\n### 双指针法——找链表相交结点位置\n\n**注意**\n\n- 要先确定两个指针的距离，然后同步移动找到指针值相同的结点即可\n\n**题目**\n\n- [面试题02.07.链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)\n\n### 环形链表——确定环及环入口位置\n\n**注意**\n\n- 根据快慢指针找环\n- 环的入口位置需要数学证明\n\n**题目**\n\n- [142.Link List Cycle II（==题解==）---2021.7.13\n\n## 哈希表\n\n**适用情况**\n\n- 需要记录元素出现的次数--map\n- 需要记录元素是否出现过--set\\map\n\n**注意**\n\n- 如果数据比较少，key可以用int且最大值不大，直接用数组即可\n\n- 如果数据比较少，但特别分散、跨度大，可以用unordered_map\n\n- 如果只是需要记录是否出现过，可以用unordered_set作集合操作，用find判断\n\n  也可用map只读一次数据\n\n**题目**\n\n- [242.Vaild Anagram](https://leetcode-cn.com/problems/valid-anagram/)\n- [349.intersection-of-two-arrays](https://leetcode-cn.com/problems/intersection-of-two-arrays/)---2021.7.14\n- [202.Happy Number](https://leetcode-cn.com/problems/happy-number/)\n- [1.Two Sum](https://leetcode-cn.com/problems/two-sum/)---2021.7.15\n- [454.4Sum II]()\n- [383.Ransom Note](https://leetcode-cn.com/problems/ransom-note/)---2021.7.16\n- [15.3Sum](https://leetcode-cn.com/problems/3sum/)\n- [18.4Sum](https://leetcode-cn.com/problems/4sum/)\n\n\n\n**扩展阅读**\n\n- [C++ multimap查找相同键的键值对方法](https://www.cnblogs.com/ladawn/p/8203789.html)\n\n\n\n## 字符串\n\n### 反转\n\n**题目**\n\n- [344.Reverse String](https://leetcode-cn.com/problems/reverse-string/)---2021.7.19\n- [541.Reverse String II](https://leetcode-cn.com/problems/reverse-string-ii/) ---2021.7.20\n- [151.Reverse Wrods in a String](https://leetcode-cn.com/problems/reverse-words-in-a-string/)\n- [剑指Offer 58-II 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)---2021.7.21\n- [28.Implement strStr](https://leetcode-cn.com/problems/implement-strstr/)---2021.7.22\n- [459.Repeated Sbustring Pattern](https://leetcode-cn.com/problems/repeated-substring-pattern/)(==无思路==)（==好好研究==）---2021.7.23\n\n## 栈和队列\n\n**预备知识**\n\n- 栈、队列是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的。STL中栈的队列往往不被归类为容器，而被归类为container adapter（容器适配器）\n\n**注意**\n\n- `stack.pop()`返回值是void,`stack.top()`返回值才是具体数值\n\n**应用类型**\n\n- 对称匹配类问题——栈\n  - 两个元素匹配，匹配后可再有操作\n\n**题目练习**\n\n- [232.Implement Queue using Stacks](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n- [225.Implement Stack using Queues](https://leetcode-cn.com/problems/implement-stack-using-queues/)---2021.7.24\n- [20.Vaild Parentheses](https://leetcode-cn.com/problems/valid-parentheses/)\n- [1047.Remove All Adjacent Duplicates In String](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)---2021.7.26\n- [150.Evaluate Reverse Polish Notation](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)---2021.7.27\n- [239.Sliding Window Maximum](https://leetcode-cn.com/problems/sliding-window-maximum/)（==题解问题==）---2021.7.28\n\n","tags":["LeetCode刷题","C++"],"categories":["刷题记录"]},{"title":"3.远程仓库","url":"/2021/07/27/3.远程仓库/","content":"\n\n\n# 远程仓库\n\n## 配置SSH\n\n- 本地Git仓库和GitHub仓库之间的传输是通过SSH加密的、\n\n- 第1步：创建SSH Key。打开Shell（Windows下打开Git Bash），创建SSH Key：\n\n  ```\n  cd  ~/.ssh\t//检查本机是否有ssh,如果提示没有则需要创建\n  ssh-keygen -t rsa -C \"youremail@example.com\"\t//创建ssh,一路回车，使用默认值即可\n  cd ~/.ssh \t//进入文件\n  ll\t//查看是否存在有id_rsa（私匙）和id_rsa.pub（公匙）两个文件\n  cat id_rsa.pub\t//查看公匙\n  ```\n\n- 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面\n\n  - 点“Add SSH Key”，填上任意Title，在Key文本框里粘贴`id_rsa.pub`文件的内容\n\n- GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。\n\n## 本地仓库关联远程仓库\n\n### 命令\n\n- `git remote add origin <仓库地址>`：连接远程仓库\n  - 仓库地址选择git开头的那个\n  - 添加后，远程库的名字就是`origin`，这是Git默认的叫法，也可以改成别的\n- `git push -u <远程仓库名> <本地分支名>`：将当前本地仓库分支推送到远程仓库\n  - `-u`：第一次推送`master`分支时，加上`-u`参数，Git不但会把本地的`main`分支内容推送的远程新的`main`分支，还会把本地的`main`分支和远程的`main`分支关联起来，在以后的推送或者拉取时就可以简化命令,直接使用`git push`\n  - `<本地分支名>:<远程分支名>`：推送到远程仓库的分支重新命名\n- `git remote rm <远程仓库名>`：解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动\n- `git remote -v`：查看远程库信息\n\n## 克隆远程库\n\n### 命令\n\n- `git clone <仓库地址>`\n","tags":["Github"],"categories":["Git学习"]},{"title":"2.本地仓库","url":"/2021/07/27/2.本地仓库/","content":"\n# 本地仓库\n\n## 仓库版本控制\n\n- `git status`：查看本地仓库状态\n- `git diff`：查看仓库和之前版本的区别\n- `git log`：显示从最近的最远的提交日志\n  - `--grapt`：显示分支合并图\n  - `--pretty=oneline`：简化日志信息，将每个提交放在一行显示，**查看的提交数很大时非常有用**\n- `git reset --hard xxx`：回退仓库版本xxx\n  - `xxx`\n    - Git中用`head`表示当前版本，上个版本是`head^`，上上个版本是`head^^`,也可用`head~10`来表示上10个版本\n    - 直接用`git log`中提交`commit id（版本号）`前几位\n- `git reflog`：记录使用的每一次命令\n\n## 工作区和暂存区\n\n- ==工作区==：就是你在电脑里能看到的目录\n- ==版本库==：工作区有一个隐藏目录`.git`，这个不算工作区，而是Git的版本库\n  - 版本库中存在一个称为stage(或index)的==暂存区==，还有Git为为我们自动创建的第一个分支`main`，以及指向`master`的一个指针叫`HEAD`\n\n![img](../images/0.jpg)\n\n- 我们把文件往Git版本库里添加的时候，是分两步执行的：\n\n  第一步是用`git add`把文件添加进去，实际上就是把文件修改添加到暂存区；\n\n  第二步是用`git commit`提交更改，实际上就是把暂存区的所有内容提交到当前分支。\n\n  因为我们创建Git版本库时，Git自动为我们创建了唯一一个`master`分支，所以，现在，`git commit`就是往`master`分支上提交更改\n\n## 管理修改\n\n**为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件**\n\n- git每次都会对仓库内发生的修改情况进行记录，只要存在修改就会存在记录\n- 考虑这样一种情况：第一次修改 -> `git add` -> 第二次修改 -> `git commit`\n  - add会将第一次修改提交到暂存区，commit只会将暂存区的文件提交\n  - 但是这并不意味着第二次修改不存在了，我们可以再进行add后再提交，仍然可以提交第二次修改\n\n## 撤销修改\n\n- `git checkout` 可以用来新建或者切换分支， 也可以用来回退文件版本\n- 从 `Git 2.23` 版本开始引入了两个新的命令： \n  - `git switch` 切换分支\n  - `git restore`：还原工作区的文件\n    - `--staged`:将暂存区的文件从暂存区撤出，但不会更改文件的内容\n    - 如果文件还未add,那么不需要加上面参数；如果一级add,那么回退顺序应该是先回退暂存区，再回退文件（直接回退文件是没用的）\n- 如果修改被commit了，那么只能回退版本\n\n## 删除文件\n\n- 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用`rm`命令删了\n- 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，`git status`命令会立刻告诉你哪些文件被删除了\n- 现在你有两个选择，\n  - 一是确实要从版本库中删除该文件，那就用命令`git rm`删掉，并且`git commit`\n    - 或者用`git add <file>`删掉\n  - 另一种情况是删错了，因为版本库里还有，所以当然可以撤销修改\n- **注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！**\n\n","tags":["Github"],"categories":["Git学习"]},{"title":"1.Git简介","url":"/2021/07/27/1.Git简介/","content":"\n\n\n# Git简介\n\n## Git起源\n\n- 在2002年以前，世界各地的志愿者把源代码文件通过==diff[^3]==的方式发给Linus，然后由Linus本人通过手工方式合并代码\n- 到了2002年,Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统\n- 2005,Linux社区牛人试图破解BitKeeper的协议，BitMover公司要收回Linux社区的免费使用权\n- Linus花了两周时间自己用C写了一个分布式版本控制系统——Git！一个月之内，Linux系统的源码已经由Git管理了\n\n\n\n## 版本控制系统 [^1]\n\n- 集中式：\n  - 集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。\n  - 集中式版本控制系统最大的毛病就是必须联网才能工作，受限于网速\n- 分布式：\n  - 分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，工作的时候，就不需要联网\n  - 个人的对库文件的修改只需通过局域网推送给对方即可看到\n  - 分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已\n- Git是目前世界上最先进的==分布式版本控制系统[^2]==\n\n## 安装Git\n\n- Linux：直接用命令行安装\n\n- Win：在官网下载安装程序，并配置机器名字和地址\n\n- 具体操作互联网搜索即可\n\n- 第一次安装需要配置\n\n  ```shell\n  git config --global user.name \"xxx\"\n  ```\n  \n\n\n## 版本库\n\n- 版本库（*repository*)：可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”\n\n### 操作过程\n\n- `git init`：在指定目录中使用，可以将该目录变成Git可以管理的仓库\n  - 会在该目录下生成一个`.git`目录，是Git用来跟踪管理版本库的，一般不需改动\n  - 该仓库是一个本地仓库\n- `git add xxx`：把位于指定目录的文件添加到仓库\n- `git commit -m \"xxx\"`：将文件提交到仓库\n  - 一次commit会将之前所有的add都会提交 \n\n\n\n\n\n[^1]:一种软体工程技巧，籍以在开发的过程中，确保由不同人所编辑的同一档案都得到更新。版本控制透过文档控制(documentation control)记录程序各个模组的改动，并为每次改动编上序号\n[^2]:每个人都可以创建一个独立的代码仓库用于管理，各种版本控制的操作都可以在本地完成。每个人修改的代码都可以推送合并到另外一个代码仓库中\n[^3]:diff 命令比较文本文件,它能比较单个文件或者目录内容。\n\n\n\n**扩展阅读**\n\n- [百科-版本控制](https://baike.so.com/doc/5903265-6116166.html)\n- [集中式（SVN）和分布式（Git）版本控制系统的简单比较](https://www.cnblogs.com/wx1993/p/7680877.html)\n\n","tags":["Github"],"categories":["Git学习"]}]