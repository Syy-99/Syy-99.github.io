{"meta":{"title":"Blog For Everything","subtitle":"记录学习轨迹","description":"各类学习笔记","author":"shen yayu","url":"https://syy-99.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2021-07-22T16:00:00.000Z","updated":"2021-07-26T12:38:25.863Z","comments":false,"path":"404.html","permalink":"https://syy-99.github.io/404.html","excerpt":"","text":"网站出逃啦！！ 点击此处返回首页 shen yanyu"},{"title":"about","date":"2021-07-27T01:12:47.000Z","updated":"2021-07-27T01:13:42.330Z","comments":false,"path":"about/index.html","permalink":"https://syy-99.github.io/about/index.html","excerpt":"","text":"这里写关于页正文"},{"title":"categories","date":"2021-07-26T12:10:22.000Z","updated":"2021-07-26T12:11:56.809Z","comments":false,"path":"categories/index.html","permalink":"https://syy-99.github.io/categories/index.html","excerpt":"","text":""},{"title":"tag","date":"2021-07-26T12:01:00.000Z","updated":"2021-07-26T12:05:40.878Z","comments":false,"path":"tags/index.html","permalink":"https://syy-99.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"4.分支管理","date":"2021-07-27T00:48:46.841Z","updated":"2021-07-26T06:20:30.000Z","comments":true,"path":"2021/07/27/4.分支管理/","link":"","permalink":"https://syy-99.github.io/2021/07/27/4.%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/","excerpt":"","text":"分支管理创建与合并分支 默认本地仓库只有一条分支main HEAD指向main,main指向要提交的时间线 git switch -c &lt;新分支名&gt;:创建并切换新分支，指向main相同的提交 此时HEAD指向新分支。之后的提交都是在新分支下 不加-c表示切换分支 git branch：查看所有分支 当前分支名前会有一个*号 git merge &lt;分支名&gt;：合并指定分支的工作到当前分支下 git branch -d &lt;分支名&gt;：删除分支 分支冲突 合并冲突： 当创建多分支时，如果修改不同文件，则合并不会提示冲突 如果修改相同文件，合并时会提示冲突，需要手动修改冲突，确定文件的最终版本 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容 合并策略： 默认使用Fast forward，会直接将Master分支指向Develop分支。在这种模式下，删除分支后，会丢掉分支信息 .png) git merge --no-ff -m &quot;merge with no-ff&quot; dev 使用--no-ff参数后，会执行正常合并，在Master分支上生成一个新节点 .png) 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并 分支管理策略 ==主分支main(master)==:代码库应该有一个、且仅有一个主分支。仅用来发布新版本，平时不能在上面干活. ==工作分支dev==：日常开发。如果想正式对外发布，就在分支上，对Develop分支进行”合并” 临时分支： ==功能分支feature-xxx==：为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop ==预发布分支release-xxx==：指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支. ==修补bug分支fixbug-xxx==：修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支 扩展阅读 Git分支管理策略","categories":[],"tags":[]},{"title":"","slug":"3.远程仓库","date":"2021-07-27T00:48:46.576Z","updated":"2021-07-24T03:58:20.000Z","comments":true,"path":"2021/07/27/3.远程仓库/","link":"","permalink":"https://syy-99.github.io/2021/07/27/3.%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/","excerpt":"","text":"远程仓库配置SSH 本地Git仓库和GitHub仓库之间的传输是通过SSH加密的、 第1步：创建SSH Key。打开Shell（Windows下打开Git Bash），创建SSH Key： 12345cd ~/.ssh //检查本机是否有ssh,如果提示没有则需要创建ssh-keygen -t rsa -C &quot;youremail@example.com&quot; //创建ssh,一路回车，使用默认值即可cd ~/.ssh //进入文件ll //查看是否存在有id_rsa（私匙）和id_rsa.pub（公匙）两个文件cat id_rsa.pub //查看公匙 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面 点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容 GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 本地仓库关联远程仓库命令 git remote add origin &lt;仓库地址&gt;：连接远程仓库 仓库地址选择git开头的那个 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的 git push -u &lt;远程仓库名&gt; &lt;本地分支名&gt;：将当前本地仓库分支推送到远程仓库 -u：第一次推送master分支时，加上-u参数，Git不但会把本地的main分支内容推送的远程新的main分支，还会把本地的main分支和远程的main分支关联起来，在以后的推送或者拉取时就可以简化命令,直接使用git push &lt;本地分支名&gt;:&lt;远程分支名&gt;：推送到远程仓库的分支重新命名 git remote rm &lt;远程仓库名&gt;：解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动 git remote -v：查看远程库信息 克隆远程库命令 git clone &lt;仓库地址&gt;","categories":[],"tags":[]},{"title":"","slug":"2.本地仓库","date":"2021-07-27T00:48:46.069Z","updated":"2021-07-26T03:39:43.000Z","comments":true,"path":"2021/07/27/2.本地仓库/","link":"","permalink":"https://syy-99.github.io/2021/07/27/2.%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/","excerpt":"","text":"本地仓库仓库版本控制 git status：查看本地仓库状态 git diff：查看仓库和之前版本的区别 git log：显示从最近的最远的提交日志 --grapt：显示分支合并图 --pretty=oneline：简化日志信息，将每个提交放在一行显示，查看的提交数很大时非常有用 git reset --hard xxx：回退仓库版本xxx xxx Git中用head表示当前版本，上个版本是head^，上上个版本是head^^,也可用head~10来表示上10个版本 直接用git log中提交commit id（版本号）前几位 git reflog：记录使用的每一次命令 工作区和暂存区 ==工作区==：就是你在电脑里能看到的目录 ==版本库==：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库 版本库中存在一个称为stage(或index)的==暂存区==，还有Git为为我们自动创建的第一个分支main，以及指向master的一个指针叫HEAD 我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改 管理修改为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件 git每次都会对仓库内发生的修改情况进行记录，只要存在修改就会存在记录 考虑这样一种情况：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit add会将第一次修改提交到暂存区，commit只会将暂存区的文件提交 但是这并不意味着第二次修改不存在了，我们可以再进行add后再提交，仍然可以提交第二次修改 撤销修改 git checkout 可以用来新建或者切换分支， 也可以用来回退文件版本 从 Git 2.23 版本开始引入了两个新的命令： git switch 切换分支 git restore：还原工作区的文件 --staged:将暂存区的文件从暂存区撤出，但不会更改文件的内容 如果文件还未add,那么不需要加上面参数；如果一级add,那么回退顺序应该是先回退暂存区，再回退文件（直接回退文件是没用的） 如果修改被commit了，那么只能回退版本 删除文件 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了 现在你有两个选择， 一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit 或者用git add &lt;file&gt;删掉 另一种情况是删错了，因为版本库里还有，所以当然可以撤销修改 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！","categories":[],"tags":[]},{"title":"Git简介","slug":"1.Git简介","date":"2021-07-27T00:48:45.792Z","updated":"2021-07-27T02:14:02.702Z","comments":true,"path":"2021/07/27/1.Git简介/","link":"","permalink":"https://syy-99.github.io/2021/07/27/1.Git%E7%AE%80%E4%BB%8B/","excerpt":"","text":"Git简介Git起源 在2002年以前，世界各地的志愿者把源代码文件通过==diff[3]==的方式发给Linus，然后由Linus本人通过手工方式合并==代码== 到了2002年,Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统 2005,Linux社区牛人试图破解BitKeeper的协议，BitMover公司要收回Linux社区的免费使用权 Linus花了两周时间自己用C写了一个分布式版本控制系统——Git！一个月之内，Linux系统的源码已经由Git管理了 版本控制系统&lt;span class=”hint—top hint—rounded” aria-label=”一种软体工程技巧，籍以在开发的过程中，确保由不同人所编辑的同一档案都得到更新。版本控制透过文档控制(documentation control)记录程序各个模组的改动，并为每次改动编上序号“&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt; 集中式： 集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。 集中式版本控制系统最大的毛病就是必须联网才能工作，受限于网速 分布式： 分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，工作的时候，就不需要联网 个人的对库文件的修改只需通过局域网推送给对方即可看到 分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已 Git是目前世界上最先进的==分布式版本控制系统[2]== 安装Git Linux：直接用命令行安装 Win：在官网下载安装程序，并配置机器名字和地址 具体操作互联网搜索即可 第一次安装需要配置 1git config --global user.name &quot;xxx&quot; 版本库 版本库（repository)：可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原” 操作过程 git init：在指定目录中使用，可以将该目录变成Git可以管理的仓库 会在该目录下生成一个.git目录，是Git用来跟踪管理版本库的，一般不需改动 该仓库是一个本地仓库 git add xxx：把位于指定目录的文件添加到仓库 git commit -m &quot;xxx&quot;：将文件提交到仓库 一次commit会将之前所有的add都会提交 扩展阅读 百科-版本控制 集中式（SVN）和分布式（Git）版本控制系统的简单比较 一种软体工程技巧，籍以在开发的过程中，确保由不同人所编辑的同一档案都得到更新。版本控制透过文档控制(documentation control)记录程序各个模组的改动，并为每次改动编上序号 ↩每个人都可以创建一个独立的代码仓库用于管理，各种版本控制的操作都可以在本地完成。每个人修改的代码都可以推送合并到另外一个代码仓库中 ↩diff 命令比较文本文件,它能比较单个文件或者目录内容。 ↩","categories":[{"name":"Git学习","slug":"Git学习","permalink":"https://syy-99.github.io/categories/Git%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Git学习","slug":"Git学习","permalink":"https://syy-99.github.io/tags/Git%E5%AD%A6%E4%B9%A0/"}]},{"title":"Github+Hexo搭建个人博客","slug":"Github+Hexo搭建个人博客","date":"2021-07-26T11:56:59.947Z","updated":"2021-07-26T12:14:36.608Z","comments":true,"path":"2021/07/26/Github+Hexo搭建个人博客/","link":"","permalink":"https://syy-99.github.io/2021/07/26/Github+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"Github+Hexo搭建个人博客工具准备 git安装：直接官网下载即可 Node.js安装 官网下载后，可以配置一下依赖的安装环境，即配置环境变量 Hexo安装 博客初始化主题相关配置 根目录下_config.yam配置博客基本信息 1 配置网站头像","categories":[{"name":"测试","slug":"测试","permalink":"https://syy-99.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[]}],"categories":[{"name":"Git学习","slug":"Git学习","permalink":"https://syy-99.github.io/categories/Git%E5%AD%A6%E4%B9%A0/"},{"name":"测试","slug":"测试","permalink":"https://syy-99.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"Git学习","slug":"Git学习","permalink":"https://syy-99.github.io/tags/Git%E5%AD%A6%E4%B9%A0/"}]}