{"meta":{"title":"Blog For Everything","subtitle":"记录学习轨迹","description":"各类学习笔记","author":"shen yayu","url":"https://syy-99.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2021-07-22T16:00:00.000Z","updated":"2021-07-26T12:38:25.863Z","comments":false,"path":"404.html","permalink":"https://syy-99.github.io/404.html","excerpt":"","text":"网站出逃啦！！ 点击此处返回首页 shen yanyu"},{"title":"tag","date":"2021-07-26T12:01:00.000Z","updated":"2021-07-26T12:05:40.878Z","comments":false,"path":"tags/index.html","permalink":"https://syy-99.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-07-26T12:10:22.000Z","updated":"2021-07-26T12:11:56.809Z","comments":false,"path":"categories/index.html","permalink":"https://syy-99.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2021-07-27T01:12:47.000Z","updated":"2021-07-27T01:13:42.330Z","comments":false,"path":"about/index.html","permalink":"https://syy-99.github.io/about/index.html","excerpt":"","text":"这里写关于页正文"}],"posts":[{"title":"10.规范化数据库设计","slug":"10.规范化数据库设计","date":"2021-10-01T14:39:59.705Z","updated":"2021-10-01T14:39:10.798Z","comments":true,"path":"2021/10/01/10.规范化数据库设计/","link":"","permalink":"https://syy-99.github.io/2021/10/01/10.%E8%A7%84%E8%8C%83%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"规范化数据库设计 为什们需要设计？ 当数据库比较复杂的时候，我们对数据库进行设计 糟糕的数据库设计 数据冗余，浪费空间 （自带外键）数据库插入和删除麻烦 程序的性能差 良好的数据库设计 节省内存空间 保证数据库的完整性 方便我们开发系统 数据库设计步骤 分析需求：分析业务和需要处理的数据库的需求 分析要用的表，以及表中需要保存的信息 提取和表相关的实体类，讲需求落实到表的每一个字段 概要设计：设计关系图E-R图 标识实体之间的关系 三大范式 第一范式(1NF) 原子性：要求数据库表的每一列都是不可分割的原子数据项 第二范式(2NF) 前提：满足第一范式 要求表中的每一列都和主键相关库，而不能只与主键的某一部分相关（主要针对联合主键而言）、 示例：联合主键（A,B)，但表中C、D和A、B相关，E和B相关，那么对于表（A,B,C,D,E）来说，就不满足第二范式。 ​ 因为表的非主键列和主键不是完全相关，即不是：所有非主键列都是和（A,B)相关。 ​ 那么就需要拆分表为（A,C,D)，(B，E)两个表 第三范式(3NF) 前提：满足第二范式 确保表中的每一列数据都和主键直接相关，而不能间接相关（在2NF的基础上消除传递依赖） 示例：假设表中所有非主键列都完全依赖于主键（满足2NF），但是，有一列C实际上直接相关的是B（也就是说 主键-&gt;B-&gt;C,传递依赖也满足2NF) ​ 所以我们要把(B,C)单独成表，删除原表中的C(因为原表通过B就可以找到C的信息) 规范型 和 性能的问题 阿里：关联查询的表不超过3个 考虑商业化的需求和目标，数据库的性能更重要 故意给表增加一些冗余的字段（从多表查询变为单表查询） 故意增加一些计算列（从大数据量降低为小数据量）","categories":[{"name":"MySql基础学习","slug":"MySql基础学习","permalink":"https://syy-99.github.io/categories/MySql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://syy-99.github.io/tags/MySql/"}]},{"title":"9.权限管理和备份","slug":"9.权限管理和备份","date":"2021-10-01T14:39:59.702Z","updated":"2021-10-01T14:39:16.211Z","comments":true,"path":"2021/10/01/9.权限管理和备份/","link":"","permalink":"https://syy-99.github.io/2021/10/01/9.%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%92%8C%E5%A4%87%E4%BB%BD/","excerpt":"","text":"权限管理和备份 用户管理 SQLyog可视化管理 略 SQL命令操作 用户表：mysql.user 本质：对表进行操作 12345678910111213141516171819202122-- 创建用户create user syy identified by &#x27;12345&#x27;-- 修改用户密码set password = password(&#x27;111111&#x27;) -- 低版本可用alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;111111&#x27; -- mysql8版本-- 重命名rename user syy to syy2-- 用户授权 *.* 所有库的所有表grant [all privileges] on 库.表 to syy2 -- all privileges 不包括 grant权限-- 查看权限show grants for syy2show grants for root@localhost -- 查看用户权限要加主机-- 撤销权限(哪些权限、在哪个库撤销、给谁撤销)revoke all privileges on *.* from syy2-- 删除用户drop user syy2 @后面是用户表host的内容，要和修改的用户名对应才行 host中%，是设置远程连接，运行任何ip访问该账户 MySQL 备份 为什们要备份？ 保证重要的数据不丢失 进行数据转移 备份方式 直接拷贝物理文件，data文件 在SQLyog这种可视化工具中手动转出 sql转储，导出一个.sql文件，执行该文件后会生成导出的库和表 使用命令行导出 mysqldump命令 备份原理是通过协议连接到 MySQL 数据库，将需要备份的数据查询出来，将查询出的数据转换成对应的insert 语句，当我们需要还原这些数据时，只要执行这些 insert 语句，即可将对应的数据还原 12345678-- 基本格式mysqldump -h[ip] -u[用户名] -p[密码] -P[端口号] 数据库名 表名 &gt;导出的文件名.sql-- 导出所有的数据库mysqldump -uroot -p123456 --all-databases &gt;D:/all.sql-- 导出多个指定表 或 数据库内所有表mysqldump -uroot -p123456 school student class &gt;D:/a.sqlmysqldump -uroot -p123456 school &gt;D:/b.sql 导入 先在命令行中登录MySQL 如果是导入一张表，需要切换到对应需要导入的数据库； 如果是导入一个数据库，则不用 1source d:/all.sql","categories":[{"name":"MySql基础学习","slug":"MySql基础学习","permalink":"https://syy-99.github.io/categories/MySql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://syy-99.github.io/tags/MySql/"}]},{"title":"18.索引","slug":"8.索引","date":"2021-10-01T14:39:59.699Z","updated":"2021-10-01T14:39:20.484Z","comments":true,"path":"2021/10/01/8.索引/","link":"","permalink":"https://syy-99.github.io/2021/10/01/8.%E7%B4%A2%E5%BC%95/","excerpt":"","text":"索引 简介 MySQL官方对索引的定义：索引是帮助MySQL获取数据的数据结构 分类 主键索引(primary key) 主键的列值唯一、不可为空 唯一的标识，只能有一个列作为主键 唯一索引(unique key) 索引的列值必须唯一，可以为空 多个列都可以设置为唯一索引 如果是组合索引，则列值的组合必须唯一 常规索引(key/index) 最基本的索引，不具备唯一性，仅加快查询速度。 全文索引(FullText) 在特定的数据库引擎才有 快速定位数据 是目前搜索引擎使用的一种关键技术。它能够利用多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能筛选出想要的结果。3.2开始支持全文索引，但无法正确支持中文；5.7.6开始内置ngram全文检索插件，用来支持中文。 旧版的全文索引只能用在MyISAM数据库引擎的表上，但5.6.24上InnoDB也加入了全文索引。不够只支持char、varchar和text的字段类型。 使用 创建表时给字段增加索引 123primary key xx()unique key xx()key xx() 创建完毕后增加索引 1234alter table 表名 add fulltext index 索引名(列名) -- 添加全文索引---------------create 索引类型 on 表名(列名) -- 显示表所有的索引信息 1show index from 表名 -- 显示表中所有索引信息 索引原则 索引不是越多越好 不要对经常变动的数据加索引 小数据量的表不需要加索引 索引一般加在常用来查询的字段上 explain简介（拓展） explain模拟优化器执行SQL语句，在5.6以及以后的版本中，select update delete insert均可用，从而知道mysql是如何处理sql语句，分析查询语句或者表结构的性能瓶颈。 作用 表的读取顺序 数据读取操作的操作类型 哪些索引可以使用 哪些索引被实际使用 表之间的引用 每张表有多少行被优化器查询 用法 explain+SQL语句 执行计划包含的信息： 信息 描述 id 查询的序号，包含一组数字，表示查询中执行select子句或操作表的顺序 select_type 查询类型，主要用于区别普通查询，联合查询，子查询等的复杂查询 table 输出的行所引用的表 type 显示联结类型，显示查询使用了何种类型，按照从最佳到最坏类型排序 possible_keys 指出MySQL能使用哪个索引在该表中找到行 key 显示MySQL实际决定使用的键(索引) key_len 表示索引中使用的字节数 ref 显示索引的哪一列被使用了，如果有可能是一个常数，哪些列或常量被用于查询索引列上的值 rows 根据表统计信息以及索引选用情况，大致估算出找到所需的记录所需要读取的行数 Extra 包含不适合在其他列中显示，但是十分重要的额外信息 **id：**id相同，执行顺序从上往下；id不同，id值越大，优先级越高，越先执行 select_type： simple ——简单的select查询，查询中不包含子查询或者UNION primary ——查询中若包含任何复杂的子部分，最外层查询被标记 subquery——在select或where列表中包含了子查询 derived——在from列表中包含的子查询被标记为derived（衍生），MySQL会递归执行这些子查询，把结果放到临时表中 union——如果第二个select出现在UNION之后，则被标记为UNION，如果union包含在from子句的子查询中，外层select被标记为derived union result: UNION 的结果 type: system：表中仅有一行（=系统表）这是const联结类型的一个特例。 const：表示通过索引一次就找到，const用于比较primary key或者unique索引。因为只匹配一行数据，所以如果将主键置于where列表中，mysql能将该查询转换为一个常量 eq_ref:唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于唯一索引或者主键扫描 ref:非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，可能会找多个符合条件的行，属于查找和扫描的混合体 range:只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是where语句中出现了between,in等范围的查询。这种范围扫描索引扫描比全表扫描要好，因为它开始于索引的某一个点，而结束另一个点，不用全表扫描 index:index 与all区别为index类型只遍历索引树。通常比all快，因为索引文件比数据文件小很多。 all：遍历全表以找到匹配的行 注意:一般保证查询至少达到range级别，最好能达到ref。\\ key: 如果没有选择索引,键是NULL。查询中如果使用覆盖索引，则该索引和查询的select字段重叠。 key_length: 该列计算查询中使用的索引的长度在不损失精度的情况下，长度越短越好。 ​ 如果键是NULL,则长度为NULL。该字段显示为索引字段的最大可能长度，并非实际使用长度。 Extra: Using filesort：说明mysql会对数据适用一个外部的索引排序。而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成排序操作称为“文件排序” Using temporary: 使用了临时表保存中间结果。mysql在查询结果排序时使用临时表，常见于排序order by和分组查询group by Using index: 表示相应的select操作用使用覆盖索引，避免访问了表的数据行。 ​ 如果同时出现using where，表名索引被用来执行索引键值的查找；如果没有同时出现using where，表名索引用来读取数据而非执行查询动作。 Using where : 表明使用where过滤 using join buffer: 使用了连接缓存 impossible where: where子句的值总是false，不能用来获取任何元组 select tables optimized away：在没有group by子句的情况下，基于索引优化Min、max操作或者对于MyISAM存储引擎优化count（*），不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化 distinct：优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。 索引的数据结构（扩展） 阅读：https://blog.codinglabs.org/articles/theory-of-mysql-index.html","categories":[{"name":"MySql基础学习","slug":"MySql基础学习","permalink":"https://syy-99.github.io/categories/MySql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://syy-99.github.io/tags/MySql/"}]},{"title":"7.事务","slug":"7.事务","date":"2021-10-01T14:39:59.696Z","updated":"2021-10-01T14:39:22.874Z","comments":true,"path":"2021/10/01/7.事务/","link":"","permalink":"https://syy-99.github.io/2021/10/01/7.%E4%BA%8B%E5%8A%A1/","excerpt":"","text":"事务 概述 事务：事务里面的操作，要么都成功，要么都失败 事务原则：ACID 原子性：同一个事务中的操作同时成功或失败，不能只发生一个 一致性：事务操作前后的数据完整性一致 隔离性：多个用户同时操作，相互不会影响 持久性：事务一旦提交就不可逆 如果事务没有提交，那么数据状态保持不变； 如果事务已经提交，那么无论发生什么事情，数据的状态都会保持提交后的状态 事务的隔离级别 脏读 一个事务读取了另一个事务未提交的数据 不可重复读 在一个事务内读取表中的某一行数据，多次读取结果不同 这个不一定是错误，只是场合不对 幻读（虚读） 一个事务内读取到了别的事务插入的数据，导致前后读取不一致 Q: 不可重复读和幻读的区别？ A: 表面上看，似乎两者都表现为两次读取的结果不一致。但不可重复读的重点在于update和delete,而幻读的重点在于insert ​ 所以说，幻读和不可重复读的最大区别在于 如何通过锁机制来解决它们产生的问题 ​ （幻读需要锁表，不可重复读应该只用锁对应的行？） MySQL事务操作 MySQL是默认开启事务自动提交的 12set autocommit = 0 -- 关闭事务自动提交set autocimmit =1 -- 开启 手动处理事务的sql编写逻辑 123456start transaction -- 标记一个事务的开始，从这个之后的sql都在同一个事务内insert xxxinsert xxxcommit -- 事务结束，提交，数据持久化。只有提交后，上面的操作才能持久化保存rollback -- 如果失败实施回滚：回到原来的样子。如果已经commit，那么回滚后还是改变后的结果；但如果还没有commit，回滚后是最初w savepoint 保存点名 ：定义事务处理过程中的保存点 rollback to savepoint 保存点名：回滚的保存点 release savepoint 保存点名：撤销保存点","categories":[{"name":"MySql基础学习","slug":"MySql基础学习","permalink":"https://syy-99.github.io/categories/MySql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://syy-99.github.io/tags/MySql/"}]},{"title":"6.MySQL函数","slug":"6.MySQL函数","date":"2021-10-01T14:39:59.693Z","updated":"2021-10-01T14:39:25.300Z","comments":true,"path":"2021/10/01/6.MySQL函数/","link":"","permalink":"https://syy-99.github.io/2021/10/01/6.MySQL%E5%87%BD%E6%95%B0/","excerpt":"","text":"MySQL函数 常用函数 以下示例中具体数字都可以用字段表示 数学运算 12345select abs(-8) -- 绝对值select ceiling(8.3) -- 向上取整select floor(8.3) -- 向下取整select rand() -- 返回一个0-1之间的随机数select sing(-10) -- 判断一个数的符号，负数返回-1、正数返回1 字符串操作 123456789select char_length(&#x27;xxxx&#x27;) -- 显示字符串的长度select concat(&#x27;姓名&#x27;，name) -- 拼接字符串select insert(&#x27;my name&#x27;,1,1,&#x27;your&#x27;) -- 在某个位置开始替换掉一定长度内原来的字符 示例结果：youry nameselect lower(&#x27;Name&#x27;) -- 大写转小写select upper(&#x27;Name&#x27;) -- 小写转大写select instr(&#x27;MySQL&#x27;，&#x27;SQL&#x27;) -- 返回第一次出现字串的索引(注意不是下标),不存在就返回0select replace(&#x27;MySQL learn&#x27;,&#x27;learn&#x27;,&#x27;study&#x27;) -- 替换指定的字符串select substr(&#x27;MySQL learn&#x27;,4,6) -- 截取指定的字符串（源字符串，截取的位置，截取的长度)select reverse(&#x27;MySQL learn&#x27;) -- 翻转字符串 instr不区分大小写 mysql 进行模糊查询时，可使用内部函数 instr，替代传统的 like 方式，并且速度更快。 select * from book where instr(bookName,'经')&gt;0 时间和日期函数 123456select current_date() -- 查询当前的日期select now() -- 查询当前的时间（月份+时间）select localtime() -- 获取本地时间select sysdate() -- 获取系统时间select year/month/day/hour/minute/second(now()) 系统函数 12select user() -- 显示当前用户select version() -- 显示mysql版本信息 聚合函数 函数名称 作用 count() sum() avg() max() min() Q: count(*)、count(字段名)、count(1)区别？ A: count(字段名)会忽略对应字段的空值，其余两个不会忽略 count(字段名)效率更快 数据库级别的MD5（扩展） MD5: 信息摘要算法,主要增强算法复杂度和不可逆 具体值的md5是一样的 函数md5(未加密数据) 123-- 示例update testmd5 set pwd=md5(pwd) where id = 1;insert into testmd5 values(5,md5(&#x27;12345&#x27;)) Q: 如何校验用户输入的密码是否正确？ A: 将用户的密码先用md5加密后，再去对比加密后的密文是否相同即可","categories":[{"name":"MySql基础学习","slug":"MySql基础学习","permalink":"https://syy-99.github.io/categories/MySql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://syy-99.github.io/tags/MySql/"}]},{"title":"5.MySQL数据库DQL操作","slug":"5.MySQL数据库DQL操作","date":"2021-10-01T14:39:59.690Z","updated":"2021-10-01T14:39:26.916Z","comments":true,"path":"2021/10/01/5.MySQL数据库DQL操作/","link":"","permalink":"https://syy-99.github.io/2021/10/01/5.MySQL%E6%95%B0%E6%8D%AE%E5%BA%93DQL%E6%93%8D%E4%BD%9C/","excerpt":"","text":"MySQL数据库DQL操作 基本知识 DQL(数据库查询语言)：用于查询数据库数据 select 语法 123456789101112SELECT &lt;ALL | DISTINCT&gt; -- 是否去重&#123;* | [table.field1[as alias1][,table.field2[as alias2]][,...]]&#125; -- 设置最终结果显示dFROM table_name [as table_alias] [left | right | inner join table_name2] -- 联合查询 [WHERE ...] -- 指定结果需满足的条件 [GROUP BY ...] -- 指定结果按照哪几个字段来分组 [HAVING] -- 过滤分组的记录必须满足的次要条件 [ORDER BY ...] -- 指定查询记录按一个或多个条件排序 [LIMIT &#123;[offset,]row_count | row_countOFFSET offset&#125;]; -- 指定查询的记录从哪条至哪条 -- 在这里[]代表可选的 SQL执行顺序 数据库的列（表达式） 123select version() -- 查询系统版本（函数）select 10*3-1 as 计算机结果 -- 用来计算（表达式）select @@auto_increament_increament -- 查询自增的步长（变量） 数据库中的表达式：文本值、列、NULL、函数，计算表达式、系统变量 Where条件字句 作用：检索数据中符合条件的值 逻辑运算符 运算符 含义 A and B &amp;&amp; 逻辑与 A or B || 逻辑或 not A=1 ! 逻辑非 模糊查询：比运算符 运算符 含义 A is null 如果A为NULL，结果为真 A is not null A between xx and xx A在xx 和 xx 之间 A like ‘xxx’ A和 xxx匹配 A in (xx,xxx) A被包含在(xx,xxx)里面 匹配原则：正则匹配 %：匹配任意个字符 _：只匹配一个字符 联表查询Join 123-- 示例slelect A.num,B.namefrom A &lt;left | inner | right&gt; join B A.num = B.num Left join：显示左边所有的数据，即使B种没有匹配的对应值也会显示；而B种数据在A种没有匹配的就不会显示 Right join：和上面说法相反 Inner join：只会显示A、B均有匹配的值，所以不会出现未匹配的数据 自连接 自己的表和自己的表连接，核心：一张表拆成两张一样的表 将表多次命别名，相当于两个表进行操作 分页和排序 排序 根据指定字段排列行数据 升序ASC： 1order by [列名] -- 默认升序 降序DESC 1order by [列名] desc -- 降序排列 分页 12345-- 示例：每页只显示五条数据select ...order by xxlimit 1,5 -- （n - 1）*pageSize-- 【pageSize:页面大小；n:当前页；（n-1）*pageSize:数据起始位置；数据总数/pageSize=当前页数】 格式 1234limit [查询起始下标]，[往下显示的行数]--------limit 2,5 -- 从第2行数据开始（不包括第2行)，往下显示5个数据 所以，如果我们要实现分页的效果，实际上是处理起始数据的行数选择，根据公式（ n - 1)*pageSize 来确定起始数据。 即，如果想显示第2页数据，（2-1）*5=5，所以起始数据填 5，数据显示从第6行 - 第10行 瀑布流：一般图片才会采用 根据进度条的位置，不断加载数据 子查询和嵌套查询 where (这个值是计算出来的) 本质：在where语句中嵌套一个查询 12345678-- 示例 查询选修了数据库-1的学生select * from studentwhere studentNo = ( select studentNo from subject where subject = &#x27;数据库-1&#x27;)-- 也可以联表查询 使用子查询，要注意where 里面的子查询返回的列要等于结果。 所以一般来说，子查询只返回一列结果 Group by 根据某个字段分组统计 可以结合聚合函数统计各组数据 分组筛选的条件不能用where,要用having来筛选各组","categories":[{"name":"MySql基础学习","slug":"MySql基础学习","permalink":"https://syy-99.github.io/categories/MySql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://syy-99.github.io/tags/MySql/"}]},{"title":"4.MySQL数据库DML操作","slug":"4.MySQL数据库DML操作","date":"2021-10-01T14:39:59.687Z","updated":"2021-10-01T14:39:28.646Z","comments":true,"path":"2021/10/01/4.MySQL数据库DML操作/","link":"","permalink":"https://syy-99.github.io/2021/10/01/4.MySQL%E6%95%B0%E6%8D%AE%E5%BA%93DML%E6%93%8D%E4%BD%9C/","excerpt":"","text":"MySQL数据库DML操作 基本知识 DML（数据库管理语言）：用于操作数据库对象中包含的数据 insert、update、delete 添加insert 12-- 语法INSERT INTO 表名&lt;(字段1,字段2,字段3,...)&gt; VALUES(&#x27;值1&#x27;,&#x27;值2&#x27;,&#x27;值3&#x27;) ’ 字段1,字段2…’ 该部分可省略 , 但添加的值务必与表结构,数据列,顺序相对应,且数量一致 . 可同时插入多条数据 , values 后用英文逗号隔开 1insert into `stu`(`name`) values(&#x27;张三&#x27;),(&#x27;李四&#x27;) 修改update 12-- 语法UPDATE 表名 SET column_name=value &lt;,column_name2=value2,...&gt; &lt;WHERE condition&gt;; value 为修改后的数据 , 可以为变量 , 具体值, 表达式或者嵌套的SELECT结果 condition 为筛选条件 , 如不指定则修改该表的所有列数据 删除delete 12-- 语法DELETE FROM 表名 &lt;WHERE condition&gt;; 只会删除数据，不会删除表的结构 Delete删除的问题 删除完毕后，重启数据库后， 如果引擎是InnoDB，自增列从1开始 （因为是存在内存中的，断电即失）； 如果引擎是MyISAM，继续自增（存在文件中） truncate命令 作用：用于完全清空表数据 , 但表结构 , 索引 , 约束等不变 ; 语法： 1234TRUNCATE &lt;table&gt; 表名;-- 清空年级表TRUNCATE grade 注意：区别于delete命令 相同 : 都能删除数据 , 不删除表结构 , 但TRUNCATE速度更快 不同 : 使用TRUNCATE TABLE 重新设置AUTO_INCREMENT计数器(自增归0) 使用TRUNCATE TABLE不会对事务有影响 （事务后面会说）","categories":[{"name":"MySql基础学习","slug":"MySql基础学习","permalink":"https://syy-99.github.io/categories/MySql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://syy-99.github.io/tags/MySql/"}]},{"title":"3.MySQL数据库DDL操作","slug":"3.MySQL数据库DDL操作","date":"2021-10-01T14:39:59.684Z","updated":"2021-10-01T14:39:30.529Z","comments":true,"path":"2021/10/01/3.MySQL数据库DDL操作/","link":"","permalink":"https://syy-99.github.io/2021/10/01/3.MySQL%E6%95%B0%E6%8D%AE%E5%BA%93DDL%E6%93%8D%E4%BD%9C/","excerpt":"","text":"MySQL数据库DDL操作 基本知识 命令行操作数据库，所有SQL语句都要有;结尾 如果数据库中的表名或字段名是一个关键字，那么可以加上**``**来标记 1select `user` from student -- user是关键字 DDL语言（数据定义语言）：定义和管理数据对象，如数据库、数据表等 create、drop、alter 操作数据库（了解） 创建数据库 1create database &lt;if not exists&gt; 数据库名 character set utf8 colate utf_8_general_ci 删除数据库 1drop database &lt;if exists&gt; 数据库名 使用数据库 1use 数据库名 查看数据库 1show databases 操作表 创建表 123456789101112-- 格式create table &lt;if not exists&gt; `表名`（ `字段名` 列类型 &lt;属性&gt; &lt;索引&gt; &lt;注释&gt;, ......）&lt;表类型&gt; &lt;字符集设置&gt; &lt;注释&gt;-- 示例create table if not exists `student`( `id` int(4) not null auto_increment commit `学号`, `name` varchar(30) not null default `匿名`, primary key(`id`) -- 建议单独列出来)engine=innodb charset=utf8 表和字段 尽量使用 `` 括起来，防止使用关键字 字符串使用单引号括起来 所有语句后面加 ,，最后一个不用加 修改表 123456修改表名 : ALTER TABLE 旧表名 RENAME AS 新表名添加字段 : ALTER TABLE 表名 ADD 字段名 列属性[属性]修改字段 : ALTER TABLE 表名 MODIFY 字段名 列类型[属性] -- 只能修改约束ALTER TABLE 表名 CHANGE 旧字段名 新字段名 列属性[属性] -- 重命名 + 修改约束删除字段 : ALTER TABLE 表名 DROP 字段名 删除表 1drop table if exists b","categories":[{"name":"MySql基础学习","slug":"MySql基础学习","permalink":"https://syy-99.github.io/categories/MySql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://syy-99.github.io/tags/MySql/"}]},{"title":"2.MySQL数据库简介","slug":"2.数据库简介","date":"2021-10-01T14:39:59.682Z","updated":"2021-10-01T14:39:32.316Z","comments":true,"path":"2021/10/01/2.数据库简介/","link":"","permalink":"https://syy-99.github.io/2021/10/01/2.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/","excerpt":"","text":"MySQL数据库简介 数据库控制 命令行操作数据库 12345678910111213mysql -u root -p123456 -- 连接数据库update mysql.user set authentication_string=password(&#x27;123456&#x27;) where user=&#x27;root&#x27; and Host = &#x27;localhost&#x27;; -- 更新密码flush privileges; -- 刷新权限-----------------------------------------show tables; -- 查看数据库所有的表describe 表名； -- 显示数据库中表的信息exit; -- 退出连接-- 单行注释/* */ -- 多行注释 show 命令 12345678910111213141516171819202122232425show databases; -- 显示mysql中所有数据库的名称。-- 如果当前没有使用 use 选择数据库，那么对所有表操作都要带上其对应dshow tables或show tables from database_name; -- 显示当前数据库中所有表的名称。show table status; -- 显示当前使用或者指定的database中的每个表的信息。信息包括表类型和表的最新更新时间。show columns from database_name.table_name; -- 显示表中列名称。 desc 表名 -- 显示表的结构show index from table_name; -- 显示表的索引。show grants for user_name; -- 显示一个用户的权限，显示结果类似于grant 命令。show status; -- 显示一些系统特定资源的信息，例如，正在运行的线程数量。show variables; -- 显示系统变量的名称和值。show processlist; -- 显示系统中正在运行的所有进程，也就是当前正在执行的查询。大多数用户可以查看他们自己的进程，但是如果他们拥有process权限，就可以查看所有人的进程，包括密码。show privileges; -- 显示服务器所支持的不同权限。show create database database_name; -- 显示create database 语句是否能够创建指定的数据库。show create table table_name; -- 显示create database 语句是否能够创建指定的数据库。show logs; -- 显示BDB存储引擎的日志。show warnings; -- 显示最后一个执行的语句所产生的错误、警告和通知。show errors; -- 只显示最后一个执行语句所产生的错误。show [storage] engines; -- 显示安装后的可用存储引擎和默认引擎。show character set; -- 显示服务器支持的数据集show innodb status; -- 显示innoDB存储引擎的状态。 数据库表的列类型 数值类型 int(M)：M指示最大显示宽度。显示宽度与存储大小或类似所包含值的范围无关 字符串类型 日期和时间型类型 NULL值 理解为 “没有值” 或 “未知值” 不要用NULL进行算术运算 , 结果仍为NULL 数据库表的字段属性 UnSigned 无符号的 声明该数据列不允许负数 . ZEROFILL 0填充的 不足位数的用0来填充 , 如int(3),5则为005 Auto_InCrement 自动增长的 , 每添加一条数据 , 自动在上一个记录数上加 1(默认) 通常用于设置主键 , 且为整数类型 可定义起始值和步长 当前表设置步长(AUTO_INCREMENT=100) : 只影响当前表 SET @@auto_increment_increment=5 ; 影响所有使用自增的表(全局) NULL 和 NOT NULL 默认为NULL , 即该列允许为空 如果设置为NOT NULL , 则该列必须有值 DEFAULT 用于设置默认值 例如,性别字段,默认为&quot;男&quot; , 否则为 “女” ; 若无指定该列的值 , 则默认值为&quot;男&quot;的值 拓展：阿里云项目数据库规范 每一个表都要有这几个字段 12345id 主键version 乐观锁is_delete 伪删除gmt_create 创建时间gmt_update 修改时间 数据库表的引擎 默认使用 INNODB 功能 InnoDB MYISAM Memory Archive 存储限制 64TB 256TB RAM None 支持事务[1] Y N N N 支持全文索引[2] N Y N 支持哈希索引 N N Y N 支持数据缓存 Y N N/A N 支持外键 Y N N N 选择策略： 如果要提供提交、回滚、崩溃恢复能力的事物安全（ACID兼容）能力，并要求实现并发控制，InnoDB是一个好的选择 如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较高的处理效率 如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎 MySQL中使用该引擎作为临时表，存放查询的中间结果 如果只有INSERT和SELECT操作，可以选择Archive，Archive支持高并发的插入操作，但是本身不是事务安全的。 Archive非常适合存储归档数据，如记录日志信息可以使用Archive 数据库表的在物理空间的位置 MySQL数据表以文件方式存放在磁盘中 包括表文件 , 数据文件 , 以及数据库的选项文件 位置 : Mysql安装目录\\data\\下存放数据表 . 目录名对应数据库名 , 该目录下文件名对应数据表 文件类型： *.frm ：存储表的列信息（表的结构） *.MYD ：数据文件 *.MYI：索引文件 *.ibd：数据+索引 具体文件介绍 文件结构名称 作用 ibdata1 系统数据字典信息（元数据信息），undo表空间数据 ib_logfiel0~ib_logfile1 REDO日志文件，事务日志文件 ibtmp1 临时表空间磁盘位置，存储临时表 ibdata1存储所有InnoDB引擎的表的元信息和undo信息 各个表.idb文件存储自己的数据行和索引信息 一张InnoDB表由一个 *.frm文件 、一个*.idb文件, 以及上一级目录的ibdata1文件； 一张MyISAM表由.frm、MYD、MYI组成 数据库表的字符集 我们可为数据库,数据表,数据列设定不同的字符集，设定方法 : 创建时通过命令来设置 , 如 : CREATE TABLE 表名()CHARSET = utf8; 如无设定 , 则根据MySQL数据库配置文件my.ini 中的参数设定 1character-set-server=utf8 不建修改配置文件，这样会导致sql语句的移植性降低 数据库表的外键（了解） 概念 如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键。 由此可见，外键表示了两个关系之间的相关联系。以另一个关系的外键作主关键字的表被称为主表，具有此外键的表被称为主表的从表。 引用别人的表——主表； 被别人引用的表——从表； 作用 保持数据一致性，完整性，主要目的是控制存储在外键表中的数据约束，使两张表形成关联。 主表中的外键只能引用外表中的对应列的值或使用空值。 MySQL命令操作 创建外键 123456789101112131415161718192021222324-- 创建外键的方式一 : 创建子表同时创建外键-- 年级表 (id\\年级名称)CREATE TABLE `grade` (`gradeid` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#x27;年级ID&#x27;,`gradename` VARCHAR(50) NOT NULL COMMENT &#x27;年级名称&#x27;,PRIMARY KEY (`gradeid`)) ENGINE=INNODB DEFAULT CHARSET=utf8-- 学生信息表 (学号,姓名,性别,年级,手机,地址,出生日期,邮箱,身份证号)CREATE TABLE `student` (`studentno` INT(4) NOT NULL COMMENT &#x27;学号&#x27;,`studentname` VARCHAR(20) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;,`sex` TINYINT(1) DEFAULT &#x27;1&#x27; COMMENT &#x27;性别&#x27;,`gradeid` INT(10) DEFAULT NULL COMMENT &#x27;年级&#x27;,PRIMARY KEY (`studentno`),KEY `FK_gradeid` (`gradeid`), -- 定义外键keyCONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`) -- 给外键添加约束（执行引用）) ENGINE=INNODB DEFAULT CHARSET=utf8---------------------------------------------- 创建外键方式二 : 创建子表完毕后,修改子表字段 添加外键约束ALTER TABLE `student`ADD CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`); 删除外键 12345-- 删除外键ALTER TABLE student DROP FOREIGN KEY FK_gradeid;-- 发现执行完上面的,索引还在,所以还要删除索引-- 注:这个索引是建立外键的时候默认生成的ALTER TABLE student DROP INDEX FK_gradeid; 删除具有主外键关系的表时 , 要先删子表 , 后删主表 以上操作都是物理外键、数据库级别的外键，不建议使用 原因：对于数据库的所有外键的每次插入、更新和删除后，数据库服务器进行完整性检查是一个耗费时间和资源的过程，它可能影响性能 最佳实践 数据库就是单纯的表，只用来存数据，只有行、列 我们想使用多张表，想使用外键，可以使用程序实现（联合查询） 事务是在数据库上按照一定的逻辑顺序执行的任务序列,是并发控制的单位。这些操作要么都做，要么都不做，不可分割 ↩︎ 原理是先定义一个词库，然后在文章中查找每个词条(term)出现的频率和位置，把这样的频率和位置信息按照词库的顺序归纳 ↩︎","categories":[{"name":"MySql基础学习","slug":"MySql基础学习","permalink":"https://syy-99.github.io/categories/MySql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://syy-99.github.io/tags/MySql/"}]},{"title":"1.初始MySQL","slug":"1.初始MySQL","date":"2021-10-01T14:39:59.580Z","updated":"2021-10-01T14:39:42.455Z","comments":true,"path":"2021/10/01/1.初始MySQL/","link":"","permalink":"https://syy-99.github.io/2021/10/01/1.%E5%88%9D%E5%A7%8BMySQL/","excerpt":"","text":"初始MySQL 什么是数据库 数据库 ( DataBase , 简称DB ) 概念 : 长期存放在计算机内,有组织,可共享的大量数据的集合,是一个数据 “仓库” 作用 : 存储和管理数据 数据库总览 : 关系型数据库 ( SQL )：关系型数据库通过外键关联来建立表与表之间的关系 MySQL , Oracle , SQL Server , SQLite , DB2 … 非关系型数据库 ( NOSQL,Not Only SQL )：非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定 Redis , MongoDB , … 什么是DBMS 数据库管理系统 ( DataBase Management System ) 数据库管理软件 , 科学组织和存储数据 , 高效地获取和维护数据 MySQL本质上是一个数据库管理系统. MySQL简介 概念 : 是现在流行的开源的,免费的 关系型数据库 历史 : 由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。 特点 : 免费 , 开源数据库 小巧 , 功能齐全 使用便捷 可运行于Windows或Linux操作系统 可适用于中小型甚至大型网站应用（可以做集群） 官网 : https://www.mysql.com/ 安装MySQL 建议使用压缩版，安装快，卸载容易 安装步骤 1、下载后得到zip压缩包. 2、解压到自己想要安装到的目录，本人解压到的是D:\\Environment\\mysql-5.7.19 3、添加环境变量：我的电脑-&gt;属性-&gt;高级-&gt;（系统）环境变量 1选择PATH,在其后面添加: 你的mysql 安装文件下面的bin文件夹 4、编辑 my.ini 文件 ,注意替换路径位置 12345[mysqld]basedir=D:\\Program Files\\mysql-5.7\\datadir=D:\\Program Files\\mysql-5.7\\data\\port=3306skip-grant-tables 5、启动管理员模式下的CMD，并将路径切换至mysql下的bin目录，然后输入mysqld –install(安装mysql) 6、再输入 mysqld --initialize-insecure --user=mysql 初始化数据文件 7、然后再次启动mysql net start mysql 然后用命令 mysql –u root –p 进入mysql管理界面（密码可为空） 8、进入界面后更改root密码 12update mysql.user set authentication_string=password(&#x27;123456&#x27;) where user=&#x27;root&#x27; and Host = &#x27;localhost&#x27;;ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;; // mysql 8.0 9、刷新权限 1flush privileges; 10、修改 my.ini文件删除最后一句skip-grant-tables 11、重启mysql即可正常使用 12net stop mysqlnet start mysql 12、连接上测试出现以下结果就安装好了 如果出现问题，可以按如下操作： 在mysql的安装目录下(即xxx/bin目录）运行mysqld --console查看报错信息 根据错误信息去搜索解决方法 如果以前装过,现在需要重装,一定要将环境清理干净 . 可视化工具SQLyog 使用SQLyog管理工具自己完成以下操作 : 连接本地MySQL数据库 新建MySchool数据库 字段 GradeID : int(11) , Primary Key (pk) GradeName : varchar(50) 数据库名称MySchool 新建数据库表(grade) 在历史记录中可以看到相对应的数据库操作的语句 . MySQL默认端口号 3306 SQLyog中每一次操作都对应了sql语句，可以在历史记录中查看","categories":[{"name":"MySql基础学习","slug":"MySql基础学习","permalink":"https://syy-99.github.io/categories/MySql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://syy-99.github.io/tags/MySql/"}]},{"title":"11.嵌入式SQL——ODBC（未完成）","slug":"11.嵌入式SQL——ODBC","date":"2021-10-01T14:39:59.577Z","updated":"2021-10-01T14:39:07.848Z","comments":true,"path":"2021/10/01/11.嵌入式SQL——ODBC/","link":"","permalink":"https://syy-99.github.io/2021/10/01/11.%E5%B5%8C%E5%85%A5%E5%BC%8FSQL%E2%80%94%E2%80%94ODBC/","excerpt":"","text":"嵌入式SQL——ODBC（未完成） 简介 程序基本流程(jdbc版）： 加载驱动 提供连接数据库用户信息 和 url 连接成功，返回数据库对象 执行SQL的对象 执行SQL的对象 去 执行SQL,可能存在结果，查看返回结果 释放连接 在C++中连接数据库","categories":[{"name":"MySql基础学习","slug":"MySql基础学习","permalink":"https://syy-99.github.io/categories/MySql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://syy-99.github.io/tags/MySql/"}]},{"title":"Github+Hexo搭建个人博客","slug":"Github+Hexo搭建个人博客","date":"2021-08-05T09:03:30.031Z","updated":"2021-08-05T09:11:18.037Z","comments":true,"path":"2021/08/05/Github+Hexo搭建个人博客/","link":"","permalink":"https://syy-99.github.io/2021/08/05/Github+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"Github+Hexo搭建个人博客 工具准备 git安装：直接官网下载即可 Node.js安装 Node的安装与环境变量的配置 Hexo安装 先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。 输入命令 1npm install -g hexo-cli 用hexo -v查看版本 博客初始化 进入之前创建的文件夹blog，这个文件夹下直接右键git bash打开 按顺序输入命令 123hexo inithexo generatehexo serve 浏览器输入地址 localhost:4000，网页如果成功显示，则说明成功 部署博客 配置博客部署地址 先在Github上创建一个仓库名为&lt;你的用户名&gt;.github.io的仓库 打开根目录下的_config.yml文件，找到 Deployment 这个地方，把刚才新建的 Repository 的地址贴过来，然后指定分支为 main 分支 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &#123;git repo ssh address&#125; branch: main 安装一个支持 Git 的部署插件 1npm install hexo-deployer-git --save 安装成功之后，执行部署命令。运行成功后，在仓库中就能看到有新文件上传 1hexo deploy 配置站点信息 修改根目录下的 _config.yml 文件，找到 Site 区域，这里面可以配置站点标题 title、副标题 subtitle 等内容、关键字 keywords 等内容 123456# Sitetitle: &lt;网站标签页名字&gt;subtitle: xxxxdescription:keywords: &quot;c++ 刷题，xxx&quot;author: 设置一下语言，如果要设置为汉语的话可以将 language 的字段设置为 zh-CN，修改如下 1language: zh-CN 主题相关配置 不同主题配置可以在GitHub上找帮助文档进行设置 这里提供一个链接，设置next主题教程 https://mp.weixin.qq.com/s/3li0n8REcU1DviwWiEYw_A 使用出现的问题 如何上传带图片的博客？ 修改根目录下_config.yam的配置项post_asset_folder为true 下载插件npm install https://github.com/CodeFalling/hexo-asset-image --save 添加md文件时，同时添加一个同名的文件夹，里面放图片，md里面使用![img](&lt;文件夹名&gt;/图片名)即可 如果是通过npm镜像下，可能不是最新的，需要修改Blog\\node_modules\\hexo-asset-image\\index.js里面var endPos=link.length-1","categories":[{"name":"杂项","slug":"杂项","permalink":"https://syy-99.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"杂","slug":"杂","permalink":"https://syy-99.github.io/tags/%E6%9D%82/"}]},{"title":"5.标签管理","slug":"5.标签管理","date":"2021-08-03T03:26:55.919Z","updated":"2021-09-08T15:16:50.990Z","comments":true,"path":"2021/08/03/5.标签管理/","link":"","permalink":"https://syy-99.github.io/2021/08/03/5.%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/","excerpt":"","text":"标签管理 标签简介 发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 tag相较于commit号，更好记。 创建标签 切换到需要打标签的分支上 输入命令git tag &lt;name&gt;，为该分支的最新提交打标签 如果想要为特定提交打标签，则需要找到commit号(git log) 用命令git tag &lt;name&gt; &lt;commit号&gt; git tag查看所有标签 标签不是按时间顺序列出的，而是按字母排列的 相关命令 git show &lt;tag名字&gt;：查看标签信息 git tag -a &lt;标签名&gt; -m &quot;xxx&quot;:创建带有说明的标签 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 操作标签 相关命令 git tag -d &lt;标签名&gt;：删除本地仓库标签 如果标签已经被推送到远程仓库，那先删除本地仓库标签 用git push origin :refs/tags/&lt;标签名&gt; git tag -l '正则表达式'：根据特定的搜索模式列出符合条件的标签 git push origin &lt;标签名&gt;：推送标签到远程仓库 git push origin --tags:一次性推送全部尚未推送到远程仓库的本地标签","categories":[{"name":"Git学习","slug":"Git学习","permalink":"https://syy-99.github.io/categories/Git%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://syy-99.github.io/tags/Github/"}]},{"title":"4.分支管理","slug":"4.分支管理","date":"2021-08-03T03:26:55.289Z","updated":"2021-09-08T15:16:49.080Z","comments":true,"path":"2021/08/03/4.分支管理/","link":"","permalink":"https://syy-99.github.io/2021/08/03/4.%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/","excerpt":"","text":"分支管理 创建与合并分支 HEAD指针：指向你正在工作中的本地分支的指针 默认本地仓库只有一条分支main HEAD指向main,main指向要提交的时间线 git switch &lt;分支名&gt;:切换分支 -c 创建并切换分支，分支指向main相同的提交 此时HEAD指向新分支。之后的提交都是在新分支下 HEAD指向正在工作的本地分支，随该分支一起移动 git branch：查看本地所有分支 当前分支名前会有一个*号 -a：查看本地和远程仓库所有分支 -r：查看远程仓库分支 -v：查看各分支最后一个提交对象的信息 --merged：查看哪些分支是当前分支的直接上游 一般来说，列表中没有 * 的分支通常都可以用 git branch -d 来删掉。原因很简单，既然已经把它们所包含的工作整合到了其他分支，删掉也不会损失什么 --no-merged：查看尚未合并的工作 由于这些分支中还包含着尚未合并进来的工作成果，所以简单地用 git branch -d 删除该分支会提示错误，因为那样做会丢失数据 -D：强制删除 git merge &lt;分支名&gt;：合并指定分支的工作到当前分支下 git branch -d &lt;分支名&gt;：删除分支 -D：删除一个没有被合并过得分支 实际操作总结 如果分支切换时，该分支的暂存区或者工作目录里，存在还没有提交的修改，会和你即将检出的分支产生冲突从而阻止 Git 为你切换分支 要么提交修改，要么使用git stash暂存 分支切换后，Git 会把工作目录的内容恢复为检出某分支时它所指向的那个提交对象的快照 分支冲突 单线的历史分支不存在任何需要解决的分歧 合并冲突： 当创建多分支时，如果修改不同文件，则合并不会提示冲突 任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出 如果在不同分支中修改相同文件，合并时会提示冲突，需要手动修改冲突，确定文件的最终版本 删除标记 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容 ======= 隔开的上半部分，是 HEAD中的内容，下半部分是在合并分支中的内容 合并策略： 默认使用Fast forward，会直接将Master分支指向Develop分支。在这种模式下，删除分支后，会丢掉分支信息 git merge --no-ff -m &quot;merge with no-ff&quot; dev 使用--no-ff参数后，会执行正常合并，在Master分支上生成一个新节点 当合并的分支，没有祖先关系（即两个不同线分支），Git会用两个分支以及它们的共同祖先进行一次简单的三方合并计算，然后创建一个分支存放合并结果 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并 分支管理策略 主分支main(master):代码库应该有一个、且仅有一个主分支。仅用来发布新版本，平时不能在上面干活. 工作分支dev：日常开发。如果想正式对外发布，就在分支上，对Develop分支进行&quot;合并&quot; 临时分支： 功能分支feature-xxx：为了开发某种特定功能，从dev分支上面分出来的。开发完成后，要再并入dev 预发布分支release-xxx：指发布正式版本之前（即合并到main分支之前），我们可能需要有一个预发布的版本进行测试。预发布分支是从dev分支上面分出来的，预发布结束以后，必须合并进dev和main分支. 修补bug分支fixbug-xxx：修补bug分支是从main分支上面分出来的。修补结束以后，再合并进main和dev分支 bug突然出现，如何保存当前的工作?恢复工作？ 1234git stash //把当前工作现场“储藏”起来，等以后恢复现场后继续工作git stash list //查看该分支保存的状态git stash pop //在该分支下，恢复之前保存的状态，并删除该记录（如果状态属于该分支会删除，如果不属于相当于一个合并操作）git stash apply &lt;名字&gt; //恢复指定的状态 修补main分支后，如何在dev分支上进行同样的修改操作？ 1git chery-pick &lt;commit编号&gt; //复制一个特定的提交到当前分支 多人协作 当从远程仓库克隆时，实际上Git自动把本地的main分支和远程的main分支对应起来了，并且，远程仓库的默认名称是origin 用 (远程仓库名)/(分支名) 这样的形式表示远程分支 它们是一些无法移动的本地分支，只有在 Git 进行网络交互时才会更新 分支推送策略： main分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 工作模式： 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改； 如果推送失败，则因为远程分支比你的本地新，需要先用git pull试图合并来保证本地和远程同步； 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。 如果合并有冲突，则解决冲突，并在本地提交； 用git status查看当前状态、寻找冲突的文件，手动修改 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ rebase 作用：rebase操作可以把本地未push的分叉提交历史整理成直线； 目的：使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。 示例： 通过merge合并这两个分支，会产生一个新的提交对象（C5） $ git checkout experiment $ git rebase master First, rewinding head to replay your work on top of it... Applying: added staged command 会在在 C3 里产生的变化补丁在 C4 的基础上重新打一遍 原理：回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支 experiment）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支 master）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写 experiment 的提交历史，使它成为 master 分支的直接下游 命令：git rebase [主分支] [特性分支] 命令会先取出特性分支 ，然后在主分支上重演 特性分支必须是从主分支直接分出来的，一步一步走 git rebase --onto &lt;主分支&gt; &lt;特性分支1&gt; &lt;特性分支2&gt; 特性分支1从主分支分出，特性分支2从特性分支1分出 取出 主分支 分支，找出 特性分支2 分支和 特性分支1 分支的共同祖先之后的变化，然后把它们在 主分支 上重演一遍 注意：一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。 相关命令 git remote：查看远程库的信息 -v：显示更详细的信息，显示可以抓取和推送的地址 git push origin --delete &lt;远程分支名&gt;：删除远程分支 git clone -b &lt;指定分支名&gt; &lt;远程仓库地址&gt;：克隆远程库指定分支到本地库 扩展阅读 Git分支管理策略","categories":[{"name":"Git学习","slug":"Git学习","permalink":"https://syy-99.github.io/categories/Git%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://syy-99.github.io/tags/Github/"}]},{"title":"6.自定义Git","slug":"6.自定义Git","date":"2021-08-03T03:26:55.286Z","updated":"2021-09-08T15:21:39.892Z","comments":true,"path":"2021/08/03/6.自定义Git/","link":"","permalink":"https://syy-99.github.io/2021/08/03/6.%E8%87%AA%E5%AE%9A%E4%B9%89Git/","excerpt":"","text":"自定义Git 配置Git 三种配置文件 /etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 --system 选项，读写的就是这个文件。 ~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 --global 选项，读写的就是这个文件。 当前项目的 git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。 git config --global user.name &quot;xxx&quot; 配置每次提交记录名称 git config --global user.email &quot;email@example.com&quot; 配置每次提交个人信息 git config --global color.ui true：让Git显示颜色 git config --list：检查已有的配置信息 git config &lt;环境变量名&gt;：检查特定环境变量的设定 git config --global alias.&lt;别名&gt; &lt;实际名字&gt;：配置别名 每个仓库的Git配置文件都放在.git/config文件中,别名就在[alias]后面 git config --edig：打开当前用户的git配置并编辑 --global:打开当前用户git的全局配置并编辑 忽略特殊文件 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件 如果你确实想添加该文件，可以用-f强制添加到Git 或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查 .gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！ 把指定文件排除在.gitignore规则外的写法就是!+文件名 搭建Git服务器 搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。 假设你已经有sudo权限的用户账号，下面，正式开始安装。 第一步，安装git： 1$ sudo apt-get install git 第二步，创建一个git用户，用来运行git服务： 1$ sudo adduser git 第三步，创建证书登录： 收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。 第四步，初始化Git仓库： 先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令： 1$ sudo git init --bare sample.git Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git： 1$ sudo chown -R git:git sample.git 第五步，禁用shell登录： 出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行： 1git:x:1001:1001:,,,:/home/git:/bin/bash 改为： 1git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。 第六步，克隆远程仓库： 现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行： 123$ git clone git@&lt;服务器地址&gt;:/srv/sample.gitCloning into &#x27;sample&#x27;...warning: You appear to have cloned an empty repository. 剩下的推送就简单了。 管理公钥 如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。 这里我们不介绍怎么玩Gitosis了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。 管理权限 有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具。 这里我们也不介绍Gitolite了，不要把有限的生命浪费到权限斗争中。","categories":[{"name":"Git学习","slug":"Git学习","permalink":"https://syy-99.github.io/categories/Git%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://syy-99.github.io/tags/Github/"}]},{"title":"LeetCode 1047","slug":"LeetCode 1047","date":"2021-07-28T08:21:12.590Z","updated":"2021-09-08T15:22:28.400Z","comments":true,"path":"2021/07/28/LeetCode 1047/","link":"","permalink":"https://syy-99.github.io/2021/07/28/LeetCode%201047/","excerpt":"","text":"LeetCode 1047 概述 https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/ 从string中删除所有相邻且相同的字符，删除后继续重复操作 思路 想当于两个元素的匹配问题，考虑用栈 1234567891011121314151617class Solution &#123;public: string removeDuplicates(string s) &#123; stack&lt;char&gt; sk; for(int i=0;s[i];i++)&#123; if(!sk.empty()&amp;&amp;sk.top()==s[i]) sk.pop(); //这里要加非空判断，因为后续也可能出现栈为空的情况 else sk.push(s[i]); &#125; string p=&quot;&quot;; while(!sk.empty())&#123; p+=sk.top(); sk.pop(); &#125; reverse(p.begin(),p.end()); return p; &#125;&#125;;","categories":[{"name":"刷题记录","slug":"刷题记录","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://syy-99.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"https://syy-99.github.io/tags/C/"}]},{"title":"LeetCode 454","slug":"LeetCode 454","date":"2021-07-28T08:21:12.586Z","updated":"2021-09-08T15:22:23.113Z","comments":true,"path":"2021/07/28/LeetCode 454/","link":"","permalink":"https://syy-99.github.io/2021/07/28/LeetCode%20454/","excerpt":"","text":"LeetCode 454 概述 https://leetcode-cn.com/problems/4sum-ii/ 给定四个数组，从四个数组中各选一个，相加等于0 返回可选的组合的个数 思路 四个不同的数组中选，所以是各自独立的 返回可选的组合的个数，只需进行记录即可 综上，可以使用哈希法。考虑到四个数组，如果暴力求解大概率是超时，所以我们将两个数组的组合情况保存起来，再循环解决 12345678910111213141516171819202122class Solution &#123;public: int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123; unordered_map&lt;int,int&gt; mp1; for(int a:nums1)&#123; for(int b:nums2)&#123; mp1[a+b]++; //先记录两个数组的所有情况，因为最终结果只要数量，所以只要记录可以组合的值的数量即可 &#125; &#125; // unordered_map&lt;int,int&gt; mp2; int count=0; for(int a:nums3)&#123; for(int b:nums4)&#123; //另外两个数组排列组合 if(mp1.find(0-(a+b))!=mp1.end())&#123; //找期望有的值 count+=mp1[0-(a+b)]; &#125; &#125; &#125; return count; &#125;&#125;;","categories":[{"name":"刷题记录","slug":"刷题记录","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://syy-99.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"https://syy-99.github.io/tags/C/"}]},{"title":"LeetCode 239","slug":"LeetCode 239","date":"2021-07-28T08:21:12.583Z","updated":"2021-09-08T15:22:21.146Z","comments":true,"path":"2021/07/28/LeetCode 239/","link":"","permalink":"https://syy-99.github.io/2021/07/28/LeetCode%20239/","excerpt":"","text":"LeetCode 239 概述 https://leetcode-cn.com/problems/sliding-window-maximum/ 给定一个整形数组，固定滑动窗口长度，窗口从左到右每次滑动一个元素，返回每次窗口的最大值 思路1 滑动窗口的模拟，容易想到使用队列 难点是如何找到每次窗口的最大值，如果在次窗口中暴力求解，O（N^2）会超时。考虑最好在每次窗口滑动时，就能确定最大值。 找最大值需要比较排序，考虑优先队列可以确保每次最大值都在窗口的第一个。问题又来了，因为排序后数字的位置改变，每次移出窗口的数不一定是优先队列中最左边的数，如何来确认呢？ 因为我们只需要找到每次的最大值，不需要关心队列里到底有哪些数字。而最大值永远在优先队列的最左边，我们只需判断每次移动后，该最大值是否被移出队列即可。 每次移出窗口的数组下标是确定的，所以我们可以同时保存值和下标，这样就算排序后数组位置改变，我们还是可以确定是否目前的最大值是否被移出。 1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); priority_queue&lt;pair&lt;int, int&gt; &gt; q; //同时保存值和下标 for (int i = 0; i &lt; k; ++i) &#123; q.emplace(nums[i], i); &#125; vector&lt;int&gt; ans = &#123;q.top().first&#125;; for (int i = k; i &lt; n; ++i) &#123; q.emplace(nums[i], i); while (q.top().second &lt;= i - k) &#123; //i-k之前的数都是应该被移出的 q.pop(); &#125; ans.push_back(q.top().first); &#125; return ans; &#125;&#125;;//时间：O(nlogn) 空间：O(n) 思路2 其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了 如果当前的滑动窗口中有两个下标 i 和 j，其中 i 在 j 的左侧（i &lt; j），并且 i 对应的元素不大于 j 对应的元素（nums[i]≤nums[j]） 当窗口右移时，如果 i 还在窗口，j 一定在窗口，且此时最大值不可能是nums[i] 按照上述分析，所有num[i]就可以不用保存在队列中了 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); vector&lt;int&gt; result; deque&lt;int&gt; dq; for(int i=0;i&lt;k;i++)&#123; while(!dq.empty()&amp;&amp;nums[i]&gt;dq.back())&#123; //按上述分析 保存特定顺序下的窗口元素 dq.pop_back(); &#125; dq.emplace_back(nums[i]); &#125; result.push_back(dq.front()); //第一个窗口的最大值 for(int i=k;i&lt;n;i++)&#123; if(!dq.empty()&amp;&amp;nums[i-k]==dq.front()) //num[i-k]是窗口该移出的元素，判断是否等于队列最前面的值，如果相等则表示其会被移出窗口 dq.pop_front(); why??? while(!dq.empty()&amp;&amp;nums[i]&gt;dq.back()) //只要添加数字进窗口都进行该操作 dq.pop_back(); dq.emplace_back(nums[i]); result.emplace_back(dq.front()); //每次移动完后，队列最前面的值，就是此时窗口的最大值 why?? &#125; return result; &#125;&#125;; 有两处问题需要考虑","categories":[{"name":"刷题记录","slug":"刷题记录","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://syy-99.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"https://syy-99.github.io/tags/C/"}]},{"title":"LeetCode 142","slug":"LeetCode 142","date":"2021-07-28T08:21:12.576Z","updated":"2021-09-08T15:22:19.906Z","comments":true,"path":"2021/07/28/LeetCode 142/","link":"","permalink":"https://syy-99.github.io/2021/07/28/LeetCode%20142/","excerpt":"","text":"LeetCode 142 概述 在一个链表中，确定是否有环。如果有，确定环的起始结点位置 思路 确定有环：快慢指针法 确定环起始位置： 123(x+y)*2=(x+y)+n(y+z) //这里n(y+z)是快指针多走的x=n(y+z)-y=(n-1)(y+z)+z //x是我们要求的注意到（n-1)(y+z)是环的长度，z、x分别拿出来看就可知道如何找到入口 12345678910111213141516171819202122232425class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(head==NULL) return NULL; ListNode* slow=head; ListNode* fast=head; int flag=0; while(fast != NULL &amp;&amp; fast-&gt;next != NULL)&#123; //注意判断 slow=slow-&gt;next; //慢指针 fast=fast-&gt;next-&gt;next; //快指针 if(slow==fast)&#123; //有环 flag=1; break; &#125; &#125; //这部分，可以直接放在前面的if里面的 if(flag==0) return NULL; ListNode* temp=head; while(temp!=fast)&#123; fast=fast-&gt;next; temp=temp-&gt;next; &#125; return temp; &#125;&#125;;","categories":[{"name":"刷题记录","slug":"刷题记录","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://syy-99.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"https://syy-99.github.io/tags/C/"}]},{"title":"LeetCode 76","slug":"LeetCode 76","date":"2021-07-28T08:21:12.465Z","updated":"2021-09-08T15:22:17.288Z","comments":true,"path":"2021/07/28/LeetCode 76/","link":"","permalink":"https://syy-99.github.io/2021/07/28/LeetCode%2076/","excerpt":"","text":"LeetCode 76 概述 ​ 题目要求在一个字符串中找到包含另一个字符串所有字符（包括重复字符）的最短子序列 思路 子序列问题，考虑滑动窗口思想 1234567891011121314151617181920212223242526272829303132333435363738string minWindow(string s, string t) &#123; int l1=s.length(),l2=t.length(); //获得字符串长度 //做准备，能想d vector&lt;int&gt; mp(128,0); for(int j=0;j&lt;t.length();j++) mp[t[j]]++; int kind=l2; int i=0; //保存每次结果和最终结果 int result=INT_MAX; string str=&quot;&quot;; string str2=&quot;&quot;; for(int j=0;j&lt;l1;j++)&#123; //窗口滑动操作 str+=s[j]; //记录窗口目前数据 if(mp[s[j]]&gt;0)&#123; //窗口滑动对之后操作影响的记录 kind--; &#125; mp[s[j]]--; while(kind==0)&#123; //临界情况 int ans=j-i+1; str2=result&gt;ans?str:str2; result=result&gt;ans?ans:result; //窗口起始位置向前滑动对记录的影响 mp[s[i]]++; if(mp[s[i]]&gt;0)&#123; kind++; &#125; str.erase(0,1); i++; &#125; &#125; return str2; &#125; 对于此题，也可以不用每次记录窗口中的字符串，因为最后可以得到最终窗口的起始、终止位置。 对于此题，还可优化，窗口起始位置可以不用每次只滑动一次，可以直接将窗口前面和目标字符串无关的位置全部移动后再做进一步判断","categories":[{"name":"刷题记录","slug":"刷题记录","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://syy-99.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"https://syy-99.github.io/tags/C/"}]},{"title":"LeetCode 69","slug":"LeetCode 69","date":"2021-07-28T08:21:12.462Z","updated":"2021-09-08T15:22:14.210Z","comments":true,"path":"2021/07/28/LeetCode 69/","link":"","permalink":"https://syy-99.github.io/2021/07/28/LeetCode%2069/","excerpt":"","text":"LeetCode 69 概述 ​ 模拟sqrt函数实现 思路 对于一个整数的平方根，除了几个特殊情况，可以验证&lt;=x/2。这里强调是整数，所以2,3仍然符合，而0,1则要特殊处理。 使用二分法，while循环中的if条件要注意，如果mid*mid&gt;x,那么结果在mid之后；反正则不一定 12345678910111213141516int mySqrt(int x) &#123; if(x==0) return 0; if(x==1) return 1; int start=1; int end=x/2; int ans=-1; while(end&gt;=start)&#123; int mid=start+(end-start)/2; if((long long)mid*mid&gt;x) //比x大，那么一定在前面 end=mid-1; else&#123; //&lt;=x，不一定先记录下来 ans=mid; //可能的结果先保存下来，所以end可以等于start start=mid+1; //继续二分 &#125; &#125; return ans; 如果不用x/2,那么就不需要特殊情况单独处理 123456789101112131415int mySqrt(int x) &#123; int start=0; int end=x; //v int ans=-1; while(end&gt;=start)&#123; int mid=start+(end-start)/2; if((long long)mid*mid&gt;x) end=mid-1; else&#123; ans=mid; start=mid+1; &#125; &#125; return ans; &#125;","categories":[{"name":"刷题记录","slug":"刷题记录","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://syy-99.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"https://syy-99.github.io/tags/C/"}]},{"title":"LeetCode 59","slug":"LeetCode 59","date":"2021-07-28T08:21:12.458Z","updated":"2021-09-08T15:22:11.592Z","comments":true,"path":"2021/07/28/LeetCode 59/","link":"","permalink":"https://syy-99.github.io/2021/07/28/LeetCode%2059/","excerpt":"","text":"LeetCode 59 概述 ​ 输入n，在n*n的矩阵中，从左上角开始，逆时针填入数字1-n2,然后输出矩阵 思路 首页，应该能知道这题是一个模拟题 手动模拟操作，可以发现，顺序上-右-下-左都是一样的，只是规模再变小。所以一次大循环里面，应该是把四个方向的任务完成。 还要注意的是边界的选取，因为上-右、右-下、下-左，均是存在一个重叠的数字的。这里选择左闭右开，是因为每次处理一个方向后，循环变量还会加一， 所以干脆直接将加一利用起来，再之后的方向继续使用，减少操作 12345678910111213141516171819202122232425262728293031vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt; &gt; result(n, vector&lt;int&gt;(n, 0)); int loop=n/2; //一次一圈，所以除2 int startx=0,starty=0; //记录起始位置 int i,j; int ans=1; //数字增量 int offset=1; //相同循环操作的偏移量 while(loop--)&#123; i=startx; j=starty; for(;j&lt;n-offset+startx;j++) //注意j的范围是要有偏移量的 result[i][j]=ans++; //因为采用左闭右开，所以j最后加出来的数，可以在下面的循环里直接用 for(;i&lt;n-offset+startx;i++) result[i][j]=ans++; for(;j&gt;starty;j--) result[i][j]=ans++; for(;i&gt;startx;i--) result[i][j]=ans++; //下一轮作准备 startx++; starty++; //起始位置改变 offset+=2; //偏移量改变 &#125; if (n%2) &#123; //n是奇数，则存在一个正中间数会少loop一次，需要额外处理 result[n/2][n/2] = ans; &#125; return result; &#125;","categories":[{"name":"刷题记录","slug":"刷题记录","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://syy-99.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"https://syy-99.github.io/tags/C/"}]},{"title":"LeetCode 34","slug":"LeetCode 34","date":"2021-07-28T08:21:12.455Z","updated":"2021-09-08T15:22:09.609Z","comments":true,"path":"2021/07/28/LeetCode 34/","link":"","permalink":"https://syy-99.github.io/2021/07/28/LeetCode%2034/","excerpt":"","text":"LeetCode 34 概述 ​ 题目给定一个升序数组，又要求时间复杂度O(log n)算法，考虑二分解决 思路1 一般二分查找，只能找到其中一个target，现在要找target在数组中的开始位置和终止位置，考虑每次找到后将数组分成左右两个，那么开始、终止位置也就可能在左右两边。 对左右两边，可以继续二分查找，直到找不到停止。到这里，考虑递归思想。 对于递归函数，返回值应该就是最终的结果，还要注意临界条件。 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; find(vector&lt;int&gt;&amp; nums,int target,int l,int r)&#123; //这里l,r就是用来记录最终结果用 while(r&gt;=l)&#123; int mid=(l+r)/2; if(nums[mid]&gt;target) r=mid-1; else if(nums[mid]&lt;target) l=mid+1; else&#123; //找到一个边界target if(nums[l]!=target) //如果最左边不等于target l=find(nums,target,l+1,mid)[0]; //左边往后移动，只取数组第一个结果 if(nums[r]!=target) //如果最右边不等于target r=find(nums,target,mid,r-1)[1]; //右边后前移动 return vector&lt;int&gt;&#123;l,r&#125;; &#125; &#125; //如果找不到 return vector&lt;int&gt;&#123;-1,-1&#125;; &#125; vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; return find(nums,target,0,nums.size()-1); &#125;&#125;; 思路二 考虑到传入的是vector类型，而c++STL中存在一个二分查找的算法equal_range,可以使用该函数 equal_range：试图在已排序的[first,last)中寻找value，它返回一对迭代器i和j，其中i是在不破坏次序的前提下，value可插入的第一个位置（亦即lower_bound），j则是在不破坏次序的前提下，value可插入的最后一个位置（亦即upper_bound） 12345678class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; auto bound=equal_range(nums.begin(),nums.end(),target); if(bound.first==bound.second) return &#123;-1,-1&#125;; //两个迭代器 first second return &#123;(int)(bound.first-nums.begin()),(int)(bound.second-nums.begin())-1&#125;; //通过迭代器相减 q &#125;&#125;;","categories":[{"name":"刷题记录","slug":"刷题记录","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://syy-99.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"https://syy-99.github.io/tags/C/"}]},{"title":"LeetCode 19","slug":"LeetCode 19","date":"2021-07-28T08:21:12.451Z","updated":"2021-09-08T15:22:07.879Z","comments":true,"path":"2021/07/28/LeetCode 19/","link":"","permalink":"https://syy-99.github.io/2021/07/28/LeetCode%2019/","excerpt":"","text":"LeetCode 19 概述 思路","categories":[{"name":"刷题记录","slug":"刷题记录","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://syy-99.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"https://syy-99.github.io/tags/C/"}]},{"title":"LeetCode 18","slug":"LeetCode 18","date":"2021-07-28T08:21:12.448Z","updated":"2021-09-08T15:22:05.040Z","comments":true,"path":"2021/07/28/LeetCode 18/","link":"","permalink":"https://syy-99.github.io/2021/07/28/LeetCode%2018/","excerpt":"","text":"LeetCode 18 概述 https://leetcode-cn.com/problems/4sum/ 给你一个数组和一个目标值target，判断数组中是否能找到四个不同位置的值相加等于target 答案中不包含重复的集合 思路 和之前[3Sum](LeetCode 15.md)基本相同，只是需要四个数字 指针数：2个活动指针+2个固定移动指针 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; result; sort(nums.begin(),nums.end()); int L=nums.size(); for(int i=0;i&lt;L;i++)&#123; //if(nums[i]&gt;target) continue; 这个剪枝是错误的 if(i&gt;0&amp;&amp;nums[i]==nums[i-1]) continue; //相同的去重操作 for(int j=i+1;j&lt;L;j++)&#123; //两个固定指针，两重循环 if(j&gt;i+1&amp;&amp;nums[j]==nums[j-1]) continue; //注意一下第二重循环的去重条件 int left=j+1; int right=L-1; while(right&gt;left)&#123; if((long long )nums[i]+nums[j]+nums[left]+nums[right]&gt;target) //这里的类型v right--; else if((long long )nums[i]+nums[j]+nums[left]+nums[right]&lt;target) left++; else&#123; result.push_back(vector&lt;int&gt;&#123;nums[i], nums[j], nums[left],nums[right]&#125;); while(nums[right]==nums[right-1]&amp;&amp;right&gt;left) right--; while(nums[left]==nums[left+1]&amp;&amp;right&gt;left) left++; right--; left++; &#125; &#125; &#125; &#125; return result; &#125;&#125;; ​ ​","categories":[{"name":"刷题记录","slug":"刷题记录","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://syy-99.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"https://syy-99.github.io/tags/C/"}]},{"title":"LeetCode 15","slug":"LeetCode 15","date":"2021-07-28T08:21:12.445Z","updated":"2021-09-08T15:22:02.904Z","comments":true,"path":"2021/07/28/LeetCode 15/","link":"","permalink":"https://syy-99.github.io/2021/07/28/LeetCode%2015/","excerpt":"","text":"LeetCode 15 概述 https://leetcode-cn.com/problems/3sum 从一个数组中，找到所有的三个不同位置的数字，相加等于0 返回所有的相加等于0的三个数字，且结果不重复 思路 理解题目要求，三个数字位置要不同,三个数字组成的结果不重复，最后按组返回所有的三个数字 返回最终集合不能重复，所以这题不好用哈希法，因为哈希会把所有的结果都选出来，那么就可能三个数字组成的集合是重复的 所以，考虑多指针法，而正好题目只需我们返回最终的值，那么可以将数据排序 如何确定指针数？ 首页一个排好序的数组，指针的移动方向就两个——前、后，所以移动指针可以有两个 这题要求选三个，所以我们当然要选三个指针指向最终的结果 如何去重？ 因为排好序，所以相同的数据都集中在一起，只需判断此时的数据和之前的数据是否相同 如果相同，则不处理该数据； 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result; sort(nums.begin(),nums.end()); //排序 int L=nums.size(); for(int i=0;i&lt;L;i++)&#123; if(nums[i]&gt;0) //剪枝 break; int j=i+1; int k=L-1; if(i&gt;0&amp;&amp;nums[i]==nums[i-1]) continue; //去重 while(k&gt;j)&#123; if(nums[i] + nums[j] + nums[k]&gt;0) //移动指针 k--; else if(nums[i] + nums[j] + nums[k]&lt;0) j++; else&#123; result.push_back(vector&lt;int&gt;&#123;nums[i], nums[j], nums[k]&#125;); //获得结果 while(nums[k]==nums[k-1]&amp;&amp;k&gt;j) k--; //去重 while(nums[j]==nums[j+1]&amp;&amp;k&gt;j) j++; //继续寻找 j++; k--; &#125; &#125; &#125; return result; &#125;&#125;;","categories":[{"name":"刷题记录","slug":"刷题记录","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://syy-99.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"https://syy-99.github.io/tags/C/"}]},{"title":"LeetCode 1","slug":"LeetCode 1","date":"2021-07-28T08:21:12.441Z","updated":"2021-09-08T15:21:59.122Z","comments":true,"path":"2021/07/28/LeetCode 1/","link":"","permalink":"https://syy-99.github.io/2021/07/28/LeetCode%201/","excerpt":"","text":"LeetCode 1 概述 https://leetcode-cn.com/problems/two-sum/ 给定一个整数数组和一个target,从数组中选择两个相加等于target的值，返回选择的两个的数组下标 同一个元素不能被重复选,且只会有一个结果 思路 返回下标，说明不能排序，那么不能使用多指针法； 题目只是要求，同一个元素不能被重复选，并没有说最终结果中不能有重复的元素，所以可以使用哈希法或find()函数 123456789101112//方法一 find()函数找，时间复杂度高vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; for(int i=0;i&lt;nums.size();i++)&#123; int temp=target-nums[i]; auto index=find(nums.begin(),nums.end(),temp); int t=index-nums.begin(); if(index!=nums.end()&amp;&amp;t!=i)&#123; //确保不是同一元素 return &#123;i,t&#125;; &#125; &#125; return &#123;0,0&#125;; &#125; 1234567891011121314//方法二 哈希法vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt; mp; for(int i=0;i&lt;nums.size();i++)&#123; mp[nums[i]]=i+1; //记录索引，这题题目明确说 只有一个答案才可以这样做的 &#125; for(int i=0;i&lt;nums.size();i++)&#123; int temp=mp[target-nums[i]]; if(temp!=0&amp;&amp;temp-1!=i)&#123; / return &#123;i,temp-1&#125;; &#125; &#125; return &#123;&#125;;&#125; 12345678910111213141516 /*官方题解 哈希 注意和自己的方法二的不同，方法二是针对此题明确一个答案才可以那样。 因为法二在记录索引是，相同的nums[i]的值会被覆盖，之会存在一个索引。 但是，因为只有一个答案，所以如果有相同的值，那么要么是用不到的，要么一定是两个相同值就是最终的答案；否则不可能只有一个解 */vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; hashtable; for (int i = 0; i &lt; nums.size(); ++i) &#123; auto it = hashtable.find(target - nums[i]); if (it != hashtable.end()) &#123; return &#123;it-&gt;second, i&#125;; &#125; hashtable[nums[i]] = i; &#125; return &#123;&#125;; &#125;","categories":[{"name":"刷题记录","slug":"刷题记录","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://syy-99.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"https://syy-99.github.io/tags/C/"}]},{"title":"c++函数使用记录","slug":"c++函数使用记录","date":"2021-07-28T08:21:12.438Z","updated":"2021-07-28T08:32:10.954Z","comments":true,"path":"2021/07/28/c++函数使用记录/","link":"","permalink":"https://syy-99.github.io/2021/07/28/c++%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","excerpt":"","text":"c++函数使用记录 STL 函数 equal_range()：一个二分查找的算法，试图在已排序的[first,last)中寻找value，它返回一对迭代器i和j。 如果该键值在容器中存在，则i是在不破坏次序的前提下，value可插入的第一个位置（亦即lower_bound），j是在不破坏次序的前提下，value可插入的最后一个位置（亦即upper_bound）；如果找不到，则i,j都指向此键值应该插入的位置。 C++11 简便写法 auto bounds = equal_range(nums.begin(), nums.end(), target); 可以将其看做lower_bound和upper_bound的结合 vector map都可以用 12vector: equal_range(nums.begin(), nums.end(), target);map: distance()：计算迭代器之间的距离 1int dis=distance(nums.begin(),nums.end() remove()：移除区间{beg,end)中每一个“与value相等”的元素。最后remove返回指向“目标数列”的end()的迭代器 只会移动元素，并且也不是将vlaues移到最后面去 1vcetor:remove(nums.begin(),nums.end(),value); Remove_if()：移除区间[beg,end)中每一个“令判断式获得true”的元素 12bool isValue(int x) &#123; return x==target; &#125;vcetor:remove(nums.begin(),nums.end(),isValue); erase():删除容器中的某些元素，返回经过删除操作后的容器 12erase(iter);erase(iter.begin,iter.end) /** iter代表迭代器 **/ fill()：为某容器某个区间赋相同值 1vcetor:fill(nums.begin(),nums.end(),0); find(first, end, value)：返回区间[first，end）中第一个值等于value的元素位置；若未找到，返回end。函数返回的是迭代器或指针，即位置信息 如果查找整个区间，可以直接xx.find(value) reverse(begin,end)：反转 多用于string、vector replace(begin,end,x,xx):在容器[being,end)范围内，将所有的x替换为xxx replace_if(being,end,条件判断,xxx) String 函数 str.replace() 12str.replace(pos,2,&quot;#&quot;) //从位置pos开始的两个字符替换成#str.replace(begin(),end(),&quot;#&quot;) //[begin,end)的字符替换成&quot;#&quot; str.substr(begin,length)：从索引begin开始，截取长度为length的字符 stoi(stirng s)：将用字符串表示的数字转换为Int 非数字字符转换会报错","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://syy-99.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"C++函数","slug":"C-函数","permalink":"https://syy-99.github.io/tags/C-%E5%87%BD%E6%95%B0/"}]},{"title":"语法总结","slug":"语法总结——队列","date":"2021-07-28T08:21:00.582Z","updated":"2021-07-28T08:32:02.059Z","comments":true,"path":"2021/07/28/语法总结——队列/","link":"","permalink":"https://syy-99.github.io/2021/07/28/%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/","excerpt":"","text":"语法总结——队列 队列 优先队列 头文件 #include&lt;queue&gt; 特点 在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征 优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的 定义 123456/*Type： 数据类型Container: 容器类型（必须是用数组实现的容器，vector,deque等，不能用List）Functional: 比较的方式*/priority_queue&lt;Type, Container, Functional&gt; 对于基本类型，默认使用大顶堆 示例: 1234priority_queue&lt;int&gt; a;priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; //主动声明 小顶堆priority_queue&lt;string&gt; bpriority_queue&lt;pair&lt;int, int&gt; &gt; a //pair先比较第一个 基本操作函数 函数 作用 top 访问队头元素 empty 队列是否为空 size 返回队列内元素个数 push 插入元素到队尾 (并排序) pop 弹出队头元素 swap 交换内容 进阶操作 自定义类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//方法1struct tmp1 //运算符重载&lt;&#123; int x; tmp1(int a) &#123;x = a;&#125; bool operator&lt;(const tmp1&amp; a) const //注意这里重载 &lt; &#123; return x &lt; a.x; //大顶堆 &#125;&#125;;//方法2struct tmp2 //重写仿函数&#123; bool operator() (tmp1 a, tmp1 b) //这里重载() &#123; return a.x &lt; b.x; //大顶堆 &#125;&#125;;int main()&#123; tmp1 a(1); tmp1 b(2); tmp1 c(3); priority_queue&lt;tmp1&gt; d; d.push(b); d.push(c); d.push(a); while (!d.empty()) &#123; cout &lt;&lt; d.top().x &lt;&lt; &#x27;\\n&#x27;; d.pop(); &#125; cout &lt;&lt; endl; priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f; f.push(b); f.push(c); f.push(a); while (!f.empty()) &#123; cout &lt;&lt; f.top().x &lt;&lt; &#x27;\\n&#x27;; f.pop(); &#125;&#125; 扩展阅读 c++优先队列(priority_queue)用法详解","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C++队列","slug":"C-队列","permalink":"https://syy-99.github.io/tags/C-%E9%98%9F%E5%88%97/"}]},{"title":"语法总结——C++11","slug":"语法总结——C++ 11","date":"2021-07-28T08:21:00.568Z","updated":"2021-07-28T08:31:43.924Z","comments":true,"path":"2021/07/28/语法总结——C++ 11/","link":"","permalink":"https://syy-99.github.io/2021/07/28/%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94C++%2011/","excerpt":"","text":"语法总结——C++ 11 使用emplace操作 新函数 对应之前函数 emplace(i, type) insert(type, i) emplace_front push_front emplace_back push_back emplace是构造而不是拷贝元素，不需要拷贝或者移动内存。 如果元素是基本类型，新特性就没有体现，也就没有优势 所有的标准库容器（array除外，因为它的长度不可改变，不能插入元素）都增加了类似的方法 使用示例 12S.push_back(data(1,2)) //让其构造函数构造好了对象之后，再使用复制构造函数S.emplace(1,2) //emplace这样接受新对象的时候，自己会调用其构造函数生成对象然后放在容器内（比如这里传入了1，2，它则会自动调用一次data(1,2))","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C++ 11","slug":"C-11","permalink":"https://syy-99.github.io/tags/C-11/"}]},{"title":"刷题总结——字符串的各种反转及应用","slug":"刷题总结——字符串的各种反转及运用","date":"2021-07-28T08:21:00.566Z","updated":"2021-07-28T08:29:58.620Z","comments":true,"path":"2021/07/28/刷题总结——字符串的各种反转及运用/","link":"","permalink":"https://syy-99.github.io/2021/07/28/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%90%84%E7%A7%8D%E5%8F%8D%E8%BD%AC%E5%8F%8A%E8%BF%90%E7%94%A8/","excerpt":"","text":"刷题总结——字符串的各种反转及运用","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://syy-99.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"https://syy-99.github.io/tags/C/"}]},{"title":"刷题总结——字符串KMP算法分析与应用","slug":"刷题总结——字符串的KMP算法分析与使用","date":"2021-07-28T08:21:00.550Z","updated":"2021-07-28T08:29:29.085Z","comments":true,"path":"2021/07/28/刷题总结——字符串的KMP算法分析与使用/","link":"","permalink":"https://syy-99.github.io/2021/07/28/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84KMP%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E4%BD%BF%E7%94%A8/","excerpt":"","text":"刷题总结——字符串的KMP算法分析与应用 概述 KMP的经典思想就是：当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。 如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任 next数组：前缀表（prefix table） 前缀表是用来回退的，它记录了模式串(与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配 记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀 最长相等前后缀 前缀：指不包含最后一个字符的所有以第一个字符开头的连续子串 后缀：指不包含第一个字符的所有以最后一个字符结尾的连续子串 前缀表要求的就是相同前后缀的长度 如何构造前缀表和next数组 前缀表中记录了模式串中每个位置从 [0,位置] 的最长相等前后缀的长度 前缀表的长度等于模式串 当在 模式表i 处发生不匹配时，只需找到前缀表中i-1的位置处的值，即可知道下次匹配从模式表[前缀表[i-1]]处开始 为了简便，通常会将前缀表向右移动并赋初值为-1，得到next数组,这样下次匹配就是模式表[next[i]] 123456789101112131415161718192021/*构造nextu1. 初始化2. 处理前后缀不同的情况3. 处理前后缀相同的情况整个算法有点动态规划的味道，在前一段完成的基础上，获得下一段的情况*/void getNext(int* next, const string&amp; s) &#123; next[0] = -1; //先给next[0]赋初值,必定是-1 int j = 0; int k=-1; //记录s[0]-s[j-1]最长相等前缀的后一个位置 while(j&lt;s.length()-1)&#123; //因为我们是使用右移的next数字，所以循环的j实际上是给j+1赋值 if(k==-1||s[j]==s[k])&#123; //这里加k==-1这个条件，实际上也是一个给next[1]赋初值的条件，因为s[1]不匹配的话，只能用s[0]l来匹配， //如果s[j+1]不匹配,考虑0-j的字符串,当s[k]==s[j]时,0-j字符串的k应该是k+1，所以s[j+1]=k+1（之后为了下次循环，k，j也要往前移动一位） j++;k++; next[j]=k; &#125;else&#123; //如果s[j+1]不匹配时，考虑0-j的字符串，当s[j]!=s[k]，0-j的最长相等前缀位置不是k(因为k是0-j-1的)，所以要更新这次的k。因为k是0-j-1的最长相等前缀的后一个位置，所以s[j]!=s[k]最长前缀只可能在0-k-1中出现，那么next[k]就应该是下一个去匹配的位置，进入下一次循环判断直到有s[k]==s[j],那么此时的k就是0-j处的最长前缀的后一个位置 k=next[k]; &#125; &#125;&#125; 题目练习 在一个串中查找是否出现过另一个串 28.Implement strStr() next数组可以优化 1next[j]=s[j]!=s[k]?k:next[k]//next数组优化，避免s[j+1]发生不匹配时，下一个s[next[j+1]]==s[j+1]继续不匹配，需要继续往下匹配 扩展阅读 详解KMP算法","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://syy-99.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"https://syy-99.github.io/tags/C/"}]},{"title":"刷题总结——多指针法","slug":"刷题总结——多指针法","date":"2021-07-28T08:21:00.538Z","updated":"2021-07-28T08:27:57.789Z","comments":true,"path":"2021/07/28/刷题总结——多指针法/","link":"","permalink":"https://syy-99.github.io/2021/07/28/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%A4%9A%E6%8C%87%E9%92%88%E6%B3%95/","excerpt":"","text":"刷题总结——多指针法 概述 双指针法基本都是应用在数组，字符串与链表的题目上 一般题目要求空间复杂度为O(1)，但要对数组等进行操作，可以考虑使用该方法 思路 一般常用的双指针法： 快慢双指针：同一方向移动，但是速度不同 前后双指针：不同方向移动 工作指针+标识指针：标识指针的移动取决于工作指针 特殊情况下也有多指针法，需要具体问题具体分析 题目练习 数组——移除元素 工作指针+标识指针 [27.Remove Element](26. Remove Duplicates from Sorted Array) [26.Remove Duplicates from Sorted Array](26. Remove Duplicates from Sorted Array)—2021.7.3 283.Move Zeroes 844.Backspace String Compare—2020.7.5 977.Squares of a Sorted Array","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://syy-99.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"https://syy-99.github.io/tags/C/"}]},{"title":"刷题总结——多数想加（减）等于特定值","slug":"刷题总结——多数相加（减）等于特定值","date":"2021-07-28T08:21:00.434Z","updated":"2021-07-28T08:29:05.064Z","comments":true,"path":"2021/07/28/刷题总结——多数相加（减）等于特定值/","link":"","permalink":"https://syy-99.github.io/2021/07/28/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%A4%9A%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88%E5%87%8F%EF%BC%89%E7%AD%89%E4%BA%8E%E7%89%B9%E5%AE%9A%E5%80%BC/","excerpt":"","text":"刷题总结——多数相加（减）等于特定值 概述 存在一类题目，给你一些数组（可能是一个，也可能是多个），给你一个target，要求你从给定的数据中，选择一些数相加（减）等于target 思路 这类算是排列组合题。如果暴力求解，就直接多重循环将数字排列组合验证即可(一般会超时) 但是考虑到已知target,我们可以先排列组合部分获得值，然后根据结果去找接下来需要应该要获得的值 重点就是如何确定数据中是否存在应该要获得的值 一种情况，可以利用find()函数 STL find()时间复杂度是O(n) map、set成员函数find()是O(logn) 另一种情况，可以利用哈希，空间换时间，缩小时间复杂度 先将排列组合的值保存下来，减少循环层数 此类题目可能存在的不同要求： 最终结果获得的值不能重复：那么在找的过程中，要确保找到的数字是之前部分结果中没有使用过的，此时哈希法不太好用，可以考虑多指针法 多指针法，一般要对数据进行排序，所以也不适用需要最后返回索引的问题 题目分析 同一集合中找数据+返回数据索引 [1.Two Sum](LeetCode 1.md/) 同一集合中找数据+返回结果数值 [15.3Sum](LeetCode 15.md) 18.4Sum 不同集合中找数据+返回结果数量 454.4Sum II","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://syy-99.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"https://syy-99.github.io/tags/C/"}]},{"title":"刷题记录——LeetCode","slug":"刷题记录——LeetCode","date":"2021-07-28T08:17:24.726Z","updated":"2021-07-28T08:31:33.408Z","comments":true,"path":"2021/07/28/刷题记录——LeetCode/","link":"","permalink":"https://syy-99.github.io/2021/07/28/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94LeetCode/","excerpt":"","text":"刷题记录——LeetCode 数组 二分法 适用情况 在一组有序数字中，进行查找操作 注意 根据不同的情况，要对while的循环条件和里面的if选择条件进行修改 基本格式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556```**题目练习**- [704. Binary Search](https://leetcode-cn.com/problems/binary-search/)- [35. Search Insert Position](https://leetcode-cn.com/problems/search-insert-position/)- [34. Find First and Last Position of Element in Sorted Array](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)(==题解==)---2021.7.1- [69. Sqrt(x)](https://leetcode-cn.com/problems/sqrtx/)（==题解==）----2021.7.2- [367. Valid Perfect Square](https://leetcode-cn.com/problems/valid-perfect-square/)---2021.7.3### 快慢指针法----移除元素**适用情况**- 在有序数组中，需要移动元素位置（包括移除、移动元素）**注意**- 不同的移除条件，循环里有不同的写法**题目练习**- [27.Remove Element]([26. Remove Duplicates from Sorted Array](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/))- [26.Remove Duplicates from Sorted Array]([26. Remove Duplicates from Sorted Array](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/))---2021.7.3- [283.Move Zeroes](https://leetcode-cn.com/problems/move-zeroes/)- [844.Backspace String Compare](https://leetcode-cn.com/problems/backspace-string-compare/)---2020.7.5- [977.Squares of a Sorted Array](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)### 滑动窗口**适用情况**- 查找连续子数组问题，不断的调节子序列的起始位置和终止位置，从而得出我们想要的结果- 特殊情况也可使用前缀和思想**注意**- 根据要求，设计每次窗户扩展后的处理方法非常关键**模版**```c++根据题目，for循环内窗口扩展操作作准备int i=0; //窗口起始位置int result=？ //看情况初值（最大或最小），保存每次结果和最终结果for（int j=0;j&lt;size;j++)&#123; //滑动窗口开始扩展 根据题目要求，设计每次窗户扩展的处理操作并保存记录 while(窗口操作后的记录的临界情况)&#123; //记录数据，并开始滑动窗口 int ans=j-i+1; //此时窗口大小 result=result&gt;ans?result:ans; //根据要求写判断逻辑 窗口起始位置向前滑动后对记录的影响 i++; //窗口起始位置向前滑动 &#125;&#125; 题目练习 209.Minimum Size Subarray Sum—2021.7.6 前缀和 O(nlogn) 904.Fruit Into Baskets–2021.7.7 76.Minmum Window Substring(题解)—2021.7.8 其它 59.Spiral Matrix II(题解)—2021.7.9 链表 用while循环遍历链表时，要根据自己的处理逻辑，选择是用while(node-&gt;next)还是while(node)，一般来说如果能确定进入循环前的node必有值的话，就用前一个，否则用后一个 虚拟头结点 适用情况 一般来说，如果对单链表进行操作，除头结点外结点操作基本相同，那么可以添加一个虚拟头结点，使得原头结点变成子节点，统一操作 注意 工作指针指向虚拟头结点后，要从node-&gt;next开始判断 返回vir_head-&gt;next才是真正头指针 模板 123ListNode* vir_head=new ListNode(); //初始化虚拟结点vir_head-&gt;next=head; //构造虚拟头结点ListNode* node=vir_head; //工作指针从虚拟结点开始 题目练习 203.Remove Linked List Elements 707.Design Linked List—2021.7.10 24.Swap Nodes in Pairs—2021.7.12 链表翻转 方法 头插法：新建一个虚拟头结点，利用头插法构造逆序链表 双指针法：利用前后指针，将next的指向逆转过来 题目练习 206.Reverse Linked List(笔记)—20217.11 双指针法——一遍找倒数位置元素 注意 要确定last、fast指针的距离，以及要选择最后fast是走到最后一个位置处，还是走到null处时，此时的fast的位置到底是不是符合要求的 题目 19.Remove Nth Node From End of List（笔记）—2021.712 双指针法——找链表相交结点位置 注意 要先确定两个指针的距离，然后同步移动找到指针值相同的结点即可 题目 面试题02.07.链表相交 环形链表——确定环及环入口位置 注意 根据快慢指针找环 环的入口位置需要数学证明 题目 [142.Link List Cycle II（题解）—2021.7.13 哈希表 适用情况 需要记录元素出现的次数–map 需要记录元素是否出现过–set\\map 注意 如果数据比较少，key可以用int且最大值不大，直接用数组即可 如果数据比较少，但特别分散、跨度大，可以用unordered_map 如果只是需要记录是否出现过，可以用unordered_set作集合操作，用find判断 也可用map只读一次数据 题目 242.Vaild Anagram 349.intersection-of-two-arrays—2021.7.14 202.Happy Number 1.Two Sum—2021.7.15 454.4Sum II 383.Ransom Note—2021.7.16 15.3Sum 18.4Sum 扩展阅读 C++ multimap查找相同键的键值对方法 字符串 反转 题目 344.Reverse String—2021.7.19 541.Reverse String II —2021.7.20 151.Reverse Wrods in a String 剑指Offer 58-II 左旋转字符串—2021.7.21 28.Implement strStr—2021.7.22 459.Repeated Sbustring Pattern(无思路)（好好研究）—2021.7.23 栈和队列 预备知识 栈、队列是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的。STL中栈的队列往往不被归类为容器，而被归类为container adapter（容器适配器） 注意 stack.pop()返回值是void,stack.top()返回值才是具体数值 应用类型 对称匹配类问题——栈 两个元素匹配，匹配后可再有操作 题目练习 232.Implement Queue using Stacks 225.Implement Stack using Queues—2021.7.24 20.Vaild Parentheses 1047.Remove All Adjacent Duplicates In String—2021.7.26 150.Evaluate Reverse Polish Notation—2021.7.27 239.Sliding Window Maximum（题解问题）—2021.7.28","categories":[{"name":"刷题记录","slug":"刷题记录","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://syy-99.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"https://syy-99.github.io/tags/C/"}]},{"title":"3.远程仓库","slug":"3.远程仓库","date":"2021-07-27T00:48:46.576Z","updated":"2021-09-08T15:16:46.898Z","comments":true,"path":"2021/07/27/3.远程仓库/","link":"","permalink":"https://syy-99.github.io/2021/07/27/3.%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/","excerpt":"","text":"远程仓库 配置SSH 本地Git仓库和GitHub仓库之间的传输是通过SSH加密的、 第1步：创建SSH Key。打开Shell（Windows下打开Git Bash），创建SSH Key： 12345cd ~/.ssh //检查本机是否有ssh,如果提示没有则需要创建ssh-keygen -t rsa -C &quot;youremail@example.com&quot; //创建ssh,一路回车，使用默认值即可cd ~/.ssh //进入文件ll //查看是否存在有id_rsa（私匙）和id_rsa.pub（公匙）两个文件cat id_rsa.pub //查看公匙 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面 点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容 GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 本地仓库关联远程仓库 命令 git remote add origin &lt;仓库地址&gt;：连接远程仓库(并未拉取文件) 仓库地址选择git开头的那个 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的 git fetch &lt;远程主机名&gt; &lt;分支名&gt;:从远程库抓取指定分支的所有commit到本地远程库 去掉&lt;分支名&gt;将会抓取远程所有分支的修改 该命令首先会把抓取的数据保存在一个FETCH_HEAD的临时记录中，通过git log -p FETCH_HEAD可以查看刚获取的更新信息。如果确认无误，可以通过git merge FETCH_HEAD合并到当前分支 &lt;分支名&gt;:&lt;本地分支名&gt;会自动合并，但是要保证该命令不是在要合并的分支下进行 git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;：将远程主机的某个分支的更新取回，并与本地指定的分支合并 如果合并的分支时当前分支，冒号后可省略 当前分支要用于跟踪该远端仓库分支才可拉取 git push -u origin &lt;本地分支名&gt;：将当前本地仓库分支推送到远程仓库上相同名字的分支 -u：第一次推送master分支时，加上-u参数，Git不但会把本地的main分支内容推送的远程新的main分支，还会把本地的main分支和远程的main分支关联起来，在以后的推送或者拉取时就可以简化命令,直接使用git push 实际上实现了一个跟踪分支的效果，本地分支会自动跟踪对应远程分支 可在创建分支时用--track &lt;本地分支名&gt; &lt;远程分支名&gt;来跟踪 &lt;本地分支名&gt;:&lt;远程分支名&gt;：推送到远程仓库的分支重新命名 如果没有会为远程库创建对应分支 如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送 远程库操作 命令 git clone &lt;仓库地址&gt;：克隆远程参考所有文件 git remote rm &lt;远程仓库名&gt;：解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动 git remote -v：显示所有远程库对应的克隆地址 git remote show &lt;远程仓库名字&gt;：查看远程仓库的详细信息 git remote rename &lt;远程仓库名&gt; &lt;远程仓库新名&gt;：修改某个远程参考在本地的简称 对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 pb/master 分支现在成了 paul/master 扩展阅读 git fetch &amp; pull详解","categories":[{"name":"Git学习","slug":"Git学习","permalink":"https://syy-99.github.io/categories/Git%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://syy-99.github.io/tags/Github/"}]},{"title":"2.本地仓库","slug":"2.本地仓库","date":"2021-07-27T00:48:46.069Z","updated":"2021-09-08T15:16:40.346Z","comments":true,"path":"2021/07/27/2.本地仓库/","link":"","permalink":"https://syy-99.github.io/2021/07/27/2.%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/","excerpt":"","text":"本地仓库 仓库版本控制 git status：查看本地仓库状态 git diff：比较工作区和暂存区修改 git diff head：比较工作区和暂存区快照的差异 git diff --cached head：比较暂存区和最近一次commit后的修改 git log：显示从最近开始的提交过的版本信息（包含多种选项，具体情况使用） - n：限制数量 -p：展开显示每次提交内容的差异 --author=&quot;xxx&quot;:按提交者名字搜索并显示（非整个单词匹配） --grep=&quot;xxx&quot;：按指定内容搜索并显示 -- &lt;file&gt;：仅显示包含指定文件修改的commit --graph：显示分支操作图 --pretty=oneline：显示日志简化信息，每条信息只占一行 gitk可以启动图形化工具来查阅提交历史 git reset xxx：回退到仓库版本xxx（之后的版本不保留） --hard：回退的同时，同时会修改工作区到回退版本 xxx Git中用head表示当前版本，上个版本是head^，上上个版本是head^^,也可用head~10来表示上10个版本 直接用git log中显示commit id（版本号）前几位 git revert xxx 撤销某次commit操作（之后的操作仍然保留） git reflog：查看本地所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作） git mv &lt;文件名&gt; &lt;文件新名&gt;：重新命名文件 同样需要提交修改 git理解为一次移动操作 工作区和暂存区 工作区：就是你在电脑里能看到的目录 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库 版本库中存在一个称为stage(或index)的暂存区，还有Git为为我们自动创建的第一个分支main，以及指向master的一个指针叫HEAD 我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改 管理修改 为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件 git每次都会对仓库内发生的修改情况进行记录，只要存在修改就会存在记录 考虑这样一种情况：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit add会将第一次修改提交到暂存区，commit只会将暂存区的文件提交 但是这并不意味着第二次修改不存在了，我们可以再进行add后再提交，仍然可以提交第二次修改 撤销操作 git checkout 可以用来新建或者切换分支， 也可以用来回退文件版本 从 Git 2.23 版本开始引入了两个新的命令： git switch 切换分支 git restore &lt;文件名&gt;：撤销对文件的修改，还原工作区的文件 --staged:将暂存区的文件从暂存区撤出，但不会更改文件的内容 所有如果想完全撤销提交到暂存区的文件，顺序是：暂存区撤销-&gt;工作区撤销 git commit --amend：修改最后一次的提交 紧跟着上次提交使用，可以修改上次提交的说明 如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 --amend 提交 两次commit但产生一次提交 如果修改被commit了，那么只能回退版本 删除文件 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了 现在你有两个选择， 一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit 或者用git add &lt;file&gt;删掉 另一种情况是删错了，因为版本库里还有，所以当然可以撤销修改 注意这里说的是版本库，所以包括add的文件 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！ git rm --cached &lt;文件名&gt;：将文件从版本库中删除，但是工作区中不删除","categories":[{"name":"Git学习","slug":"Git学习","permalink":"https://syy-99.github.io/categories/Git%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://syy-99.github.io/tags/Github/"}]},{"title":"1.Git简介","slug":"1.Git简介","date":"2021-07-27T00:48:45.792Z","updated":"2021-10-01T14:35:23.545Z","comments":true,"path":"2021/07/27/1.Git简介/","link":"","permalink":"https://syy-99.github.io/2021/07/27/1.Git%E7%AE%80%E4%BB%8B/","excerpt":"","text":"Git简介 Git起源 在2002年以前，世界各地的志愿者把源代码文件通过==diff[1]==的方式发给Linus，然后由Linus本人通过手工方式合并代码 到了2002年,Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统 2005,Linux社区牛人试图破解BitKeeper的协议，BitMover公司要收回Linux社区的免费使用权 Linus花了两周时间自己用C写了一个分布式版本控制系统——Git！一个月之内，Linux系统的源码已经由Git管理了 版本控制系统[2] 集中式： 集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。 集中式版本控制系统最大的毛病就是必须联网才能工作，受限于网速 分布式： 分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，工作的时候，就不需要联网 个人的对库文件的修改只需通过局域网推送给对方即可看到 分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已 Git是目前世界上最先进的分布式版本控制系统[3] Git 特性 直接记录快照、而非差异比较 Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异 实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接 近乎所有的操作都是本地执行 时刻保持数据的完整性 在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引 Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串。该字串由 40 个十六进制字符（0-9 及 a-f）组成。所有保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名 多数操作仅添加数据 安装Git Linux：直接用命令行安装 Win：在官网下载安装程序，并配置机器名字和地址 具体操作互联网搜索即可 第一次安装需要配置 12git config --global user.name &quot;xxx&quot;git config --global user.email &quot;email@example.com&quot; 版本库 版本库（repository)：可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原” 工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。 已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。 而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域 操作过程 git init：在指定目录中使用，可以将该目录变成Git可以管理的仓库 会在该目录下生成一个.git目录，是Git用来跟踪管理版本库的，一般不需改动 该仓库是一个本地仓库 git add xxx：把位于指定目录的文件添加到仓库 git commit -m &quot;xxx&quot;：将文件提交到仓库 一次commit会将之前所有的add都会提交 -a，自动将所有已跟踪的文件暂存起来一并提交 扩展阅读 百科-版本控制 集中式（SVN）和分布式（Git）版本控制系统的简单比较 diff 命令比较文本文件,它能比较单个文件或者目录内容。 ↩︎ 一种软体工程技巧，籍以在开发的过程中，确保由不同人所编辑的同一档案都得到更新。版本控制透过文档控制(documentation control)记录程序各个模组的改动，并为每次改动编上序号 ↩︎ 每个人都可以创建一个独立的代码仓库用于管理，各种版本控制的操作都可以在本地完成。每个人修改的代码都可以推送合并到另外一个代码仓库中 ↩︎","categories":[{"name":"Git学习","slug":"Git学习","permalink":"https://syy-99.github.io/categories/Git%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://syy-99.github.io/tags/Github/"}]}],"categories":[{"name":"MySql基础学习","slug":"MySql基础学习","permalink":"https://syy-99.github.io/categories/MySql%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"},{"name":"杂项","slug":"杂项","permalink":"https://syy-99.github.io/categories/%E6%9D%82%E9%A1%B9/"},{"name":"Git学习","slug":"Git学习","permalink":"https://syy-99.github.io/categories/Git%E5%AD%A6%E4%B9%A0/"},{"name":"刷题记录","slug":"刷题记录","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://syy-99.github.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://syy-99.github.io/tags/MySql/"},{"name":"杂","slug":"杂","permalink":"https://syy-99.github.io/tags/%E6%9D%82/"},{"name":"Github","slug":"Github","permalink":"https://syy-99.github.io/tags/Github/"},{"name":"LeetCode刷题","slug":"LeetCode刷题","permalink":"https://syy-99.github.io/tags/LeetCode%E5%88%B7%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"https://syy-99.github.io/tags/C/"},{"name":"C++函数","slug":"C-函数","permalink":"https://syy-99.github.io/tags/C-%E5%87%BD%E6%95%B0/"},{"name":"C++队列","slug":"C-队列","permalink":"https://syy-99.github.io/tags/C-%E9%98%9F%E5%88%97/"},{"name":"C++ 11","slug":"C-11","permalink":"https://syy-99.github.io/tags/C-11/"}]}