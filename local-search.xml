<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/27/4.%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
    <url>/2021/07/27/4.%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="分支管理"><a class="markdownIt-Anchor" href="#分支管理"></a> 分支管理</h1><h2 id="创建与合并分支"><a class="markdownIt-Anchor" href="#创建与合并分支"></a> 创建与合并分支</h2><ul><li><p>默认本地仓库只有一条分支<code>main</code></p><ul><li><code>HEAD</code>指向<code>main</code>,<code>main</code>指向要提交的时间线</li></ul></li><li><p><code>git switch -c &lt;新分支名&gt;</code>:创建并切换新分支，指向<code>main</code>相同的提交</p><ul><li><p>此时<code>HEAD</code>指向新分支。之后的提交都是在新分支下</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919022533080576/0" alt="img" /></p></li><li><p>不加<code>-c</code>表示切换分支</p></li></ul></li><li><p><code>git branch</code>：查看所有分支</p><ul><li>当前分支名前会有一个*号</li></ul></li><li><p><code>git merge &lt;分支名&gt;</code>：合并指定分支的工作到当前分支下</p></li><li><p><code>git branch -d &lt;分支名&gt;</code>：删除分支</p></li></ul><h2 id="分支冲突"><a class="markdownIt-Anchor" href="#分支冲突"></a> 分支冲突</h2><ul><li><p>合并冲突：</p><ul><li><p>当创建多分支时，如果修改不同文件，则合并不会提示冲突</p></li><li><p>如果修改相同文件，合并时会提示冲突，需要手动修改冲突，确定文件的最终版本</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919023000423040/0" alt="img" /></p></li></ul></li><li><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容</p></li><li><p>合并策略：</p><ul><li><p>默认使用<code>Fast forward</code>，会直接将Master分支指向Develop分支。在这种模式下，删除分支后，会丢掉分支信息</p><p><img src="C:%5CUsers%5CAdministrator.USER-20201209JD%5CDesktop%5Cbg2012070505(1).png" alt="bg2012070505(1)" /></p></li><li><p><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code></p><ul><li><p>使用<code>--no-ff</code>参数后，会执行正常合并，在Master分支上生成一个新节点</p><p><img src="C:%5CUsers%5CAdministrator.USER-20201209JD%5CDesktop%5Cbg2012070506(1).png" alt="bg2012070506(1)" /></p></li></ul></li></ul></li><li><p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并</p></li></ul><h2 id="分支管理策略"><a class="markdownIt-Anchor" href="#分支管理策略"></a> 分支管理策略</h2><p><img src="https://www.liaoxuefeng.com/files/attachments/919023260793600/0" alt="img" /></p><ul><li><p><mark>主分支main(master)</mark>:代码库应该有一个、且仅有一个主分支。仅用来发布新版本，平时不能在上面干活.</p></li><li><p><mark>工作分支dev</mark>：日常开发。如果想正式对外发布，就在分支上，对Develop分支进行&quot;合并&quot;</p></li><li><p><strong>临时分支</strong>：</p><ul><li><p><mark>功能分支feature-xxx</mark>：为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop</p><p><img src="C:%5CUsers%5CAdministrator.USER-20201209JD%5CDesktop%5Cd4806f137df9563d148afb17a51a1134_bg2012070507.png" alt="d4806f137df9563d148afb17a51a1134_bg2012070507" /></p></li><li><p><mark>预发布分支release-xxx</mark>：指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支.</p></li><li><p><mark>修补bug分支fixbug-xxx</mark>：修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支</p></li></ul></li></ul><p><strong>扩展阅读</strong></p><ul><li><a href="http://www.ruanyifeng.com/blog/2012/07/git.html">Git分支管理策略</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/27/3.%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <url>/2021/07/27/3.%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="远程仓库"><a class="markdownIt-Anchor" href="#远程仓库"></a> 远程仓库</h1><h2 id="配置ssh"><a class="markdownIt-Anchor" href="#配置ssh"></a> 配置SSH</h2><ul><li><p>本地Git仓库和GitHub仓库之间的传输是通过SSH加密的、</p></li><li><p>第1步：创建SSH Key。打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span>  ~<span class="hljs-string">/.ssh</span><span class="hljs-string">//</span>检查本机是否有ssh,如果提示没有则需要创建<br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><span class="hljs-string">//</span>创建ssh,一路回车，使用默认值即可<br><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/.ssh</span> <span class="hljs-string">//</span>进入文件<br>ll<span class="hljs-string">//</span>查看是否存在有id_rsa（私匙）和id_rsa.pub（公匙）两个文件<br>cat id_rsa.pub<span class="hljs-string">//</span>查看公匙<br></code></pre></td></tr></table></figure></li><li><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面</p><ul><li>点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容</li></ul></li><li><p>GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p></li></ul><h2 id="本地仓库关联远程仓库"><a class="markdownIt-Anchor" href="#本地仓库关联远程仓库"></a> 本地仓库关联远程仓库</h2><h3 id="命令"><a class="markdownIt-Anchor" href="#命令"></a> 命令</h3><ul><li><code>git remote add origin &lt;仓库地址&gt;</code>：连接远程仓库<ul><li>仓库地址选择git开头的那个</li><li>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的</li></ul></li><li><code>git push -u &lt;远程仓库名&gt; &lt;本地分支名&gt;</code>：将当前本地仓库分支推送到远程仓库<ul><li><code>-u</code>：第一次推送<code>master</code>分支时，加上<code>-u</code>参数，Git不但会把本地的<code>main</code>分支内容推送的远程新的<code>main</code>分支，还会把本地的<code>main</code>分支和远程的<code>main</code>分支关联起来，在以后的推送或者拉取时就可以简化命令,直接使用<code>git push</code></li><li><code>&lt;本地分支名&gt;:&lt;远程分支名&gt;</code>：推送到远程仓库的分支重新命名</li></ul></li><li><code>git remote rm &lt;远程仓库名&gt;</code>：解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动</li><li><code>git remote -v</code>：查看远程库信息</li></ul><h2 id="克隆远程库"><a class="markdownIt-Anchor" href="#克隆远程库"></a> 克隆远程库</h2><h3 id="命令-2"><a class="markdownIt-Anchor" href="#命令-2"></a> 命令</h3><ul><li><code>git clone &lt;仓库地址&gt;</code></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/27/2.%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/"/>
    <url>/2021/07/27/2.%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="本地仓库"><a class="markdownIt-Anchor" href="#本地仓库"></a> 本地仓库</h1><h2 id="仓库版本控制"><a class="markdownIt-Anchor" href="#仓库版本控制"></a> 仓库版本控制</h2><ul><li><code>git status</code>：查看本地仓库状态</li><li><code>git diff</code>：查看仓库和之前版本的区别</li><li><code>git log</code>：显示从最近的最远的提交日志<ul><li><code>--grapt</code>：显示分支合并图</li><li><code>--pretty=oneline</code>：简化日志信息，将每个提交放在一行显示，<strong>查看的提交数很大时非常有用</strong></li></ul></li><li><code>git reset --hard xxx</code>：回退仓库版本xxx<ul><li><code>xxx</code><ul><li>Git中用<code>head</code>表示当前版本，上个版本是<code>head^</code>，上上个版本是<code>head^^</code>,也可用<code>head~10</code>来表示上10个版本</li><li>直接用<code>git log</code>中提交<code>commit id（版本号）</code>前几位</li></ul></li></ul></li><li><code>git reflog</code>：记录使用的每一次命令</li></ul><h2 id="工作区和暂存区"><a class="markdownIt-Anchor" href="#工作区和暂存区"></a> 工作区和暂存区</h2><ul><li><mark>工作区</mark>：就是你在电脑里能看到的目录</li><li><mark>版本库</mark>：工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库<ul><li>版本库中存在一个称为stage(或index)的<mark>暂存区</mark>，还有Git为为我们自动创建的第一个分支<code>main</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code></li></ul></li></ul><p><img src="https://www.liaoxuefeng.com/files/attachments/919020037470528/0" alt="img" /></p><ul><li><p>我们把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改</p></li></ul><h2 id="管理修改"><a class="markdownIt-Anchor" href="#管理修改"></a> 管理修改</h2><p><strong>为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件</strong></p><ul><li>git每次都会对仓库内发生的修改情况进行记录，只要存在修改就会存在记录</li><li>考虑这样一种情况：第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code><ul><li>add会将第一次修改提交到暂存区，commit只会将暂存区的文件提交</li><li>但是这并不意味着第二次修改不存在了，我们可以再进行add后再提交，仍然可以提交第二次修改</li></ul></li></ul><h2 id="撤销修改"><a class="markdownIt-Anchor" href="#撤销修改"></a> 撤销修改</h2><ul><li><code>git checkout</code> 可以用来新建或者切换分支， 也可以用来回退文件版本</li><li>从 <code>Git 2.23</code> 版本开始引入了两个新的命令：<ul><li><code>git switch</code> 切换分支</li><li><code>git restore</code>：还原工作区的文件<ul><li><code>--staged</code>:将暂存区的文件从暂存区撤出，但不会更改文件的内容</li><li>如果文件还未add,那么不需要加上面参数；如果一级add,那么回退顺序应该是先回退暂存区，再回退文件（直接回退文件是没用的）</li></ul></li></ul></li><li>如果修改被commit了，那么只能回退版本</li></ul><h2 id="删除文件"><a class="markdownIt-Anchor" href="#删除文件"></a> 删除文件</h2><ul><li>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了</li><li>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了</li><li>现在你有两个选择，<ul><li>一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code><ul><li>或者用<code>git add &lt;file&gt;</code>删掉</li></ul></li><li>另一种情况是删错了，因为版本库里还有，所以当然可以撤销修改</li></ul></li><li><strong>注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</strong></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git简介</title>
    <link href="/2021/07/27/1.Git%E7%AE%80%E4%BB%8B/"/>
    <url>/2021/07/27/1.Git%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="git简介"><a class="markdownIt-Anchor" href="#git简介"></a> Git简介</h1><h2 id="git起源"><a class="markdownIt-Anchor" href="#git起源"></a> Git起源</h2><ul><li>在2002年以前，世界各地的志愿者把源代码文件通过<mark>diff<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><mark>的方式发给Linus，然后由Linus本人通过手工方式合并</mark>代码</mark></li><li>到了2002年,Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统</li><li>2005,Linux社区牛人试图破解BitKeeper的协议，BitMover公司要收回Linux社区的免费使用权</li><li>Linus花了两周时间自己用C写了一个分布式版本控制系统——Git！一个月之内，Linux系统的源码已经由Git管理了</li></ul><h2 id="版本控制系统"><a class="markdownIt-Anchor" href="#版本控制系统"></a> 版本控制系统<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></h2><ul><li>集中式：<ul><li>集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。</li><li>集中式版本控制系统最大的毛病就是必须联网才能工作，受限于网速</li></ul></li><li>分布式：<ul><li>分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，工作的时候，就不需要联网</li><li>个人的对库文件的修改只需通过局域网推送给对方即可看到</li><li>分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已</li></ul></li><li>Git是目前世界上最先进的<mark>分布式版本控制系统<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></mark></li></ul><h2 id="安装git"><a class="markdownIt-Anchor" href="#安装git"></a> 安装Git</h2><ul><li><p>Linux：直接用命令行安装</p></li><li><p>Win：在官网下载安装程序，并配置机器名字和地址</p></li><li><p>具体操作互联网搜索即可</p></li><li><p>第一次安装需要配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name &quot;xxx&quot;<br></code></pre></td></tr></table></figure></li></ul><h2 id="版本库"><a class="markdownIt-Anchor" href="#版本库"></a> 版本库</h2><ul><li>版本库（<em>repository</em>)：可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”</li></ul><h3 id="操作过程"><a class="markdownIt-Anchor" href="#操作过程"></a> 操作过程</h3><ul><li><code>git init</code>：在指定目录中使用，可以将该目录变成Git可以管理的仓库<ul><li>会在该目录下生成一个<code>.git</code>目录，是Git用来跟踪管理版本库的，一般不需改动</li><li>该仓库是一个本地仓库</li></ul></li><li><code>git add xxx</code>：把位于指定目录的文件添加到仓库</li><li><code>git commit -m &quot;xxx&quot;</code>：将文件提交到仓库<ul><li>一次commit会将之前所有的add都会提交</li></ul></li></ul><p><strong>扩展阅读</strong></p><ul><li><a href="https://baike.so.com/doc/5903265-6116166.html">百科-版本控制</a></li><li><a href="https://www.cnblogs.com/wx1993/p/7680877.html">集中式（SVN）和分布式（Git）版本控制系统的简单比较</a></li></ul><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>diff 命令比较文本文件,它能比较单个文件或者目录内容。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>一种软体工程技巧，籍以在开发的过程中，确保由不同人所编辑的同一档案都得到更新。版本控制透过文档控制(documentation control)记录程序各个模组的改动，并为每次改动编上序号 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>每个人都可以创建一个独立的代码仓库用于管理，各种版本控制的操作都可以在本地完成。每个人修改的代码都可以推送合并到另外一个代码仓库中 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <categories>
      
      <category>Git学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github+Hexo搭建个人博客</title>
    <link href="/2021/07/26/Github+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/07/26/Github+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="githubhexo搭建个人博客"><a class="markdownIt-Anchor" href="#githubhexo搭建个人博客"></a> Github+Hexo搭建个人博客</h1><h2 id="工具准备"><a class="markdownIt-Anchor" href="#工具准备"></a> 工具准备</h2><ul><li>git安装：直接官网下载即可</li><li>Node.js安装<ul><li>官网下载后，可以配置一下依赖的安装环境，即配置环境变量</li></ul></li><li>Hexo安装</li></ul><h2 id="博客初始化"><a class="markdownIt-Anchor" href="#博客初始化"></a> 博客初始化</h2><h2 id="主题相关配置"><a class="markdownIt-Anchor" href="#主题相关配置"></a> 主题相关配置</h2><ul><li><p>根目录下<code>_config.yam</code>配置博客基本信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><br></code></pre></td></tr></table></figure></li><li><p>配置网站头像</p></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
